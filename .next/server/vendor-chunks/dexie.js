"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dexie";
exports.ids = ["vendor-chunks/dexie"];
exports.modules = {

/***/ "(ssr)/./node_modules/dexie/dist/modern/dexie.mjs":
/*!**************************************************!*\
  !*** ./node_modules/dexie/dist/modern/dexie.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Dexie: () => (/* binding */ Dexie$1),\n/* harmony export */   RangeSet: () => (/* binding */ RangeSet),\n/* harmony export */   \"default\": () => (/* binding */ Dexie$1),\n/* harmony export */   liveQuery: () => (/* binding */ liveQuery),\n/* harmony export */   mergeRanges: () => (/* binding */ mergeRanges),\n/* harmony export */   rangesOverlap: () => (/* binding */ rangesOverlap)\n/* harmony export */ });\n/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 3.2.7, Wed Mar 20 2024\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */ const _global = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self :  false ? 0 : global;\nconst keys = Object.keys;\nconst isArray = Array.isArray;\nif (typeof Promise !== \"undefined\" && !_global.Promise) {\n    _global.Promise = Promise;\n}\nfunction extend(obj, extension) {\n    if (typeof extension !== \"object\") return obj;\n    keys(extension).forEach(function(key) {\n        obj[key] = extension[key];\n    });\n    return obj;\n}\nconst getProto = Object.getPrototypeOf;\nconst _hasOwn = {}.hasOwnProperty;\nfunction hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n}\nfunction props(proto, extension) {\n    if (typeof extension === \"function\") extension = extension(getProto(proto));\n    (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach((key)=>{\n        setProp(proto, key, extension[key]);\n    });\n}\nconst defineProperty = Object.defineProperty;\nfunction setProp(obj, prop, functionOrGetSet, options) {\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === \"function\" ? {\n        get: functionOrGetSet.get,\n        set: functionOrGetSet.set,\n        configurable: true\n    } : {\n        value: functionOrGetSet,\n        configurable: true,\n        writable: true\n    }, options));\n}\nfunction derive(Child) {\n    return {\n        from: function(Parent) {\n            Child.prototype = Object.create(Parent.prototype);\n            setProp(Child.prototype, \"constructor\", Child);\n            return {\n                extend: props.bind(null, Child.prototype)\n            };\n        }\n    };\n}\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nfunction getPropertyDescriptor(obj, prop) {\n    const pd = getOwnPropertyDescriptor(obj, prop);\n    let proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\nconst _slice = [].slice;\nfunction slice(args, start, end) {\n    return _slice.call(args, start, end);\n}\nfunction override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n}\nfunction assert(b) {\n    if (!b) throw new Error(\"Assertion Failed\");\n}\nfunction asap$1(fn) {\n    if (_global.setImmediate) setImmediate(fn);\n    else setTimeout(fn, 0);\n}\nfunction arrayToObject(array, extractor) {\n    return array.reduce((result, item, i)=>{\n        var nameAndValue = extractor(item, i);\n        if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];\n        return result;\n    }, {});\n}\nfunction tryCatch(fn, onerror, args) {\n    try {\n        fn.apply(null, args);\n    } catch (ex) {\n        onerror && onerror(ex);\n    }\n}\nfunction getByKeyPath(obj, keyPath) {\n    if (typeof keyPath === \"string\" && hasOwn(obj, keyPath)) return obj[keyPath];\n    if (!keyPath) return obj;\n    if (typeof keyPath !== \"string\") {\n        var rv = [];\n        for(var i = 0, l = keyPath.length; i < l; ++i){\n            var val = getByKeyPath(obj, keyPath[i]);\n            rv.push(val);\n        }\n        return rv;\n    }\n    var period = keyPath.indexOf(\".\");\n    if (period !== -1) {\n        var innerObj = obj[keyPath.substr(0, period)];\n        return innerObj == null ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n}\nfunction setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined) return;\n    if (\"isFrozen\" in Object && Object.isFrozen(obj)) return;\n    if (typeof keyPath !== \"string\" && \"length\" in keyPath) {\n        assert(typeof value !== \"string\" && \"length\" in value);\n        for(var i = 0, l = keyPath.length; i < l; ++i){\n            setByKeyPath(obj, keyPath[i], value[i]);\n        }\n    } else {\n        var period = keyPath.indexOf(\".\");\n        if (period !== -1) {\n            var currentKeyPath = keyPath.substr(0, period);\n            var remainingKeyPath = keyPath.substr(period + 1);\n            if (remainingKeyPath === \"\") if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(currentKeyPath))) obj.splice(currentKeyPath, 1);\n                else delete obj[currentKeyPath];\n            } else obj[currentKeyPath] = value;\n            else {\n                var innerObj = obj[currentKeyPath];\n                if (!innerObj || !hasOwn(obj, currentKeyPath)) innerObj = obj[currentKeyPath] = {};\n                setByKeyPath(innerObj, remainingKeyPath, value);\n            }\n        } else {\n            if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(keyPath))) obj.splice(keyPath, 1);\n                else delete obj[keyPath];\n            } else obj[keyPath] = value;\n        }\n    }\n}\nfunction delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === \"string\") setByKeyPath(obj, keyPath, undefined);\n    else if (\"length\" in keyPath) [].map.call(keyPath, function(kp) {\n        setByKeyPath(obj, kp, undefined);\n    });\n}\nfunction shallowClone(obj) {\n    var rv = {};\n    for(var m in obj){\n        if (hasOwn(obj, m)) rv[m] = obj[m];\n    }\n    return rv;\n}\nconst concat = [].concat;\nfunction flatten(a) {\n    return concat.apply([], a);\n}\nconst intrinsicTypeNames = \"BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\".split(\",\").concat(flatten([\n    8,\n    16,\n    32,\n    64\n].map((num)=>[\n        \"Int\",\n        \"Uint\",\n        \"Float\"\n    ].map((t)=>t + num + \"Array\")))).filter((t)=>_global[t]);\nconst intrinsicTypes = intrinsicTypeNames.map((t)=>_global[t]);\narrayToObject(intrinsicTypeNames, (x)=>[\n        x,\n        true\n    ]);\nlet circularRefs = null;\nfunction deepClone(any) {\n    circularRefs = typeof WeakMap !== \"undefined\" && new WeakMap();\n    const rv = innerDeepClone(any);\n    circularRefs = null;\n    return rv;\n}\nfunction innerDeepClone(any) {\n    if (!any || typeof any !== \"object\") return any;\n    let rv = circularRefs && circularRefs.get(any);\n    if (rv) return rv;\n    if (isArray(any)) {\n        rv = [];\n        circularRefs && circularRefs.set(any, rv);\n        for(var i = 0, l = any.length; i < l; ++i){\n            rv.push(innerDeepClone(any[i]));\n        }\n    } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n        rv = any;\n    } else {\n        const proto = getProto(any);\n        rv = proto === Object.prototype ? {} : Object.create(proto);\n        circularRefs && circularRefs.set(any, rv);\n        for(var prop in any){\n            if (hasOwn(any, prop)) {\n                rv[prop] = innerDeepClone(any[prop]);\n            }\n        }\n    }\n    return rv;\n}\nconst { toString } = {};\nfunction toStringTag(o) {\n    return toString.call(o).slice(8, -1);\n}\nconst iteratorSymbol = typeof Symbol !== \"undefined\" ? Symbol.iterator : \"@@iterator\";\nconst getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function(x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function() {\n    return null;\n};\nconst NO_CHAR_ARRAY = {};\nfunction getArrayOf(arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n        if (isArray(arrayLike)) return arrayLike.slice();\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === \"string\") return [\n            arrayLike\n        ];\n        if (it = getIteratorOf(arrayLike)) {\n            a = [];\n            while(x = it.next(), !x.done)a.push(x.value);\n            return a;\n        }\n        if (arrayLike == null) return [\n            arrayLike\n        ];\n        i = arrayLike.length;\n        if (typeof i === \"number\") {\n            a = new Array(i);\n            while(i--)a[i] = arrayLike[i];\n            return a;\n        }\n        return [\n            arrayLike\n        ];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while(i--)a[i] = arguments[i];\n    return a;\n}\nconst isAsyncFunction = typeof Symbol !== \"undefined\" ? (fn)=>fn[Symbol.toStringTag] === \"AsyncFunction\" : ()=>false;\nvar debug = typeof location !== \"undefined\" && /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n}\nvar libraryFilter = ()=>true;\nconst NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\nfunction getErrorWithStack() {\n    if (NEEDS_THROW_FOR_STACK) try {\n        getErrorWithStack.arguments;\n        throw new Error();\n    } catch (e) {\n        return e;\n    }\n    return new Error();\n}\nfunction prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack) return \"\";\n    numIgnoredFrames = numIgnoredFrames || 0;\n    if (stack.indexOf(exception.name) === 0) numIgnoredFrames += (exception.name + exception.message).split(\"\\n\").length;\n    return stack.split(\"\\n\").slice(numIgnoredFrames).filter(libraryFilter).map((frame)=>\"\\n\" + frame).join(\"\");\n}\nvar dexieErrorNames = [\n    \"Modify\",\n    \"Bulk\",\n    \"OpenFailed\",\n    \"VersionChange\",\n    \"Schema\",\n    \"Upgrade\",\n    \"InvalidTable\",\n    \"MissingAPI\",\n    \"NoSuchDatabase\",\n    \"InvalidArgument\",\n    \"SubTransaction\",\n    \"Unsupported\",\n    \"Internal\",\n    \"DatabaseClosed\",\n    \"PrematureCommit\",\n    \"ForeignAwait\"\n];\nvar idbDomErrorNames = [\n    \"Unknown\",\n    \"Constraint\",\n    \"Data\",\n    \"TransactionInactive\",\n    \"ReadOnly\",\n    \"Version\",\n    \"NotFound\",\n    \"InvalidState\",\n    \"InvalidAccess\",\n    \"Abort\",\n    \"Timeout\",\n    \"QuotaExceeded\",\n    \"Syntax\",\n    \"DataClone\"\n];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\nfunction DexieError(name, msg) {\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n}\nderive(DexieError).from(Error).extend({\n    stack: {\n        get: function() {\n            return this._stack || (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n        }\n    },\n    toString: function() {\n        return this.name + \": \" + this.message;\n    }\n});\nfunction getMultiErrorMessage(msg, failures) {\n    return msg + \". Errors: \" + Object.keys(failures).map((key)=>failures[key].toString()).filter((v, i, s)=>s.indexOf(v) === i).join(\"\\n\");\n}\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(ModifyError).from(DexieError);\nfunction BulkError(msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = Object.keys(failures).map((pos)=>failures[pos]);\n    this.failuresByPos = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce((obj, name)=>(obj[name] = name + \"Error\", obj), {});\nconst BaseException = DexieError;\nvar exceptions = errorList.reduce((obj, name)=>{\n    var fullName = name + \"Error\";\n    function DexieError(msgOrInner, inner) {\n        this._e = getErrorWithStack();\n        this.name = fullName;\n        if (!msgOrInner) {\n            this.message = defaultTexts[name] || fullName;\n            this.inner = null;\n        } else if (typeof msgOrInner === \"string\") {\n            this.message = `${msgOrInner}${!inner ? \"\" : \"\\n \" + inner}`;\n            this.inner = inner || null;\n        } else if (typeof msgOrInner === \"object\") {\n            this.message = `${msgOrInner.name} ${msgOrInner.message}`;\n            this.inner = msgOrInner;\n        }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name] = DexieError;\n    return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce((obj, name)=>{\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfunction mapError(domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name]) return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n        setProp(rv, \"stack\", {\n            get: function() {\n                return this.inner.stack;\n            }\n        });\n    }\n    return rv;\n}\nvar fullNameExceptions = errorList.reduce((obj, name)=>{\n    if ([\n        \"Syntax\",\n        \"Type\",\n        \"Range\"\n    ].indexOf(name) === -1) obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\nfunction nop() {}\nfunction mirror(val) {\n    return val;\n}\nfunction pureFunctionChain(f1, f2) {\n    if (f1 == null || f1 === mirror) return f2;\n    return function(val) {\n        return f2(f1(val));\n    };\n}\nfunction callBoth(on1, on2) {\n    return function() {\n        on1.apply(this, arguments);\n        on2.apply(this, arguments);\n    };\n}\nfunction hookCreatingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function() {\n        var res = f1.apply(this, arguments);\n        if (res !== undefined) arguments[0] = res;\n        var onsuccess = this.onsuccess, onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res2 !== undefined ? res2 : res;\n    };\n}\nfunction hookDeletingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function() {\n        f1.apply(this, arguments);\n        var onsuccess = this.onsuccess, onerror = this.onerror;\n        this.onsuccess = this.onerror = null;\n        f2.apply(this, arguments);\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n}\nfunction hookUpdatingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function(modifications) {\n        var res = f1.apply(this, arguments);\n        extend(modifications, res);\n        var onsuccess = this.onsuccess, onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res === undefined ? res2 === undefined ? undefined : res2 : extend(res, res2);\n    };\n}\nfunction reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function() {\n        if (f2.apply(this, arguments) === false) return false;\n        return f1.apply(this, arguments);\n    };\n}\nfunction promisableChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function() {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === \"function\") {\n            var thiz = this, i = arguments.length, args = new Array(i);\n            while(i--)args[i] = arguments[i];\n            return res.then(function() {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\nvar INTERNAL = {};\nconst LONG_STACKS_CLIP_LIMIT = 100, MAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === \"undefined\" ? [] : (()=>{\n    let globalP = Promise.resolve();\n    if (typeof crypto === \"undefined\" || !crypto.subtle) return [\n        globalP,\n        getProto(globalP),\n        globalP\n    ];\n    const nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([\n        0\n    ]));\n    return [\n        nativeP,\n        getProto(nativeP),\n        globalP\n    ];\n})(), nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nconst NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nconst patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ? ()=>{\n    resolvedGlobalPromise.then(physicalTick);\n} : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? ()=>{\n    var hiddenDiv = document.createElement(\"div\");\n    new MutationObserver(()=>{\n        physicalTick();\n        hiddenDiv = null;\n    }).observe(hiddenDiv, {\n        attributes: true\n    });\n    hiddenDiv.setAttribute(\"i\", \"1\");\n} : ()=>{\n    setTimeout(physicalTick, 0);\n};\nvar asap = function(callback, args) {\n    microtickQueue.push([\n        callback,\n        args\n    ]);\n    if (needsNewPhysicalTick) {\n        schedulePhysicalTick();\n        needsNewPhysicalTick = false;\n    }\n};\nvar isOutsideMicroTick = true, needsNewPhysicalTick = true, unhandledErrors = [], rejectingErrors = [], currentFulfiller = null, rejectionMapper = mirror;\nvar globalPSD = {\n    id: \"global\",\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    pgp: false,\n    env: {},\n    finalize: function() {\n        this.unhandleds.forEach((uh)=>{\n            try {\n                globalError(uh[0], uh[1]);\n            } catch (e) {}\n        });\n    }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\nfunction DexiePromise(fn) {\n    if (typeof this !== \"object\") throw new TypeError(\"Promises must be constructed via new\");\n    this._listeners = [];\n    this.onuncatched = nop;\n    this._lib = false;\n    var psd = this._PSD = PSD;\n    if (debug) {\n        this._stackHolder = getErrorWithStack();\n        this._prev = null;\n        this._numPrev = 0;\n    }\n    if (typeof fn !== \"function\") {\n        if (fn !== INTERNAL) throw new TypeError(\"Not a function\");\n        this._state = arguments[1];\n        this._value = arguments[2];\n        if (this._state === false) handleRejection(this, this._value);\n        return;\n    }\n    this._state = null;\n    this._value = null;\n    ++psd.ref;\n    executePromiseTask(this, fn);\n}\nconst thenProp = {\n    get: function() {\n        var psd = PSD, microTaskId = totalEchoes;\n        function then(onFulfilled, onRejected) {\n            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n            const cleanup = possibleAwait && !decrementExpectedAwaits();\n            var rv = new DexiePromise((resolve, reject)=>{\n                propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n            });\n            debug && linkToPreviousPromise(rv, this);\n            return rv;\n        }\n        then.prototype = INTERNAL;\n        return then;\n    },\n    set: function(value) {\n        setProp(this, \"then\", value && value.prototype === INTERNAL ? thenProp : {\n            get: function() {\n                return value;\n            },\n            set: thenProp.set\n        });\n    }\n};\nprops(DexiePromise.prototype, {\n    then: thenProp,\n    _then: function(onFulfilled, onRejected) {\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n    },\n    catch: function(onRejected) {\n        if (arguments.length === 1) return this.then(null, onRejected);\n        var type = arguments[0], handler = arguments[1];\n        return typeof type === \"function\" ? this.then(null, (err)=>err instanceof type ? handler(err) : PromiseReject(err)) : this.then(null, (err)=>err && err.name === type ? handler(err) : PromiseReject(err));\n    },\n    finally: function(onFinally) {\n        return this.then((value)=>{\n            onFinally();\n            return value;\n        }, (err)=>{\n            onFinally();\n            return PromiseReject(err);\n        });\n    },\n    stack: {\n        get: function() {\n            if (this._stack) return this._stack;\n            try {\n                stack_being_generated = true;\n                var stacks = getStack(this, [], MAX_LONG_STACKS);\n                var stack = stacks.join(\"\\nFrom previous: \");\n                if (this._state !== null) this._stack = stack;\n                return stack;\n            } finally{\n                stack_being_generated = false;\n            }\n        }\n    },\n    timeout: function(ms, msg) {\n        return ms < Infinity ? new DexiePromise((resolve, reject)=>{\n            var handle = setTimeout(()=>reject(new exceptions.Timeout(msg)), ms);\n            this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n        }) : this;\n    }\n});\nif (typeof Symbol !== \"undefined\" && Symbol.toStringTag) setProp(DexiePromise.prototype, Symbol.toStringTag, \"Dexie.Promise\");\nglobalPSD.env = snapShot();\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n    this.onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : null;\n    this.onRejected = typeof onRejected === \"function\" ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = zone;\n}\nprops(DexiePromise, {\n    all: function() {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise(function(resolve, reject) {\n            if (values.length === 0) resolve([]);\n            var remaining = values.length;\n            values.forEach((a, i)=>DexiePromise.resolve(a).then((x)=>{\n                    values[i] = x;\n                    if (!--remaining) resolve(values);\n                }, reject));\n        });\n    },\n    resolve: (value)=>{\n        if (value instanceof DexiePromise) return value;\n        if (value && typeof value.then === \"function\") return new DexiePromise((resolve, reject)=>{\n            value.then(resolve, reject);\n        });\n        var rv = new DexiePromise(INTERNAL, true, value);\n        linkToPreviousPromise(rv, currentFulfiller);\n        return rv;\n    },\n    reject: PromiseReject,\n    race: function() {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject)=>{\n            values.map((value)=>DexiePromise.resolve(value).then(resolve, reject));\n        });\n    },\n    PSD: {\n        get: ()=>PSD,\n        set: (value)=>PSD = value\n    },\n    totalEchoes: {\n        get: ()=>totalEchoes\n    },\n    newPSD: newScope,\n    usePSD: usePSD,\n    scheduler: {\n        get: ()=>asap,\n        set: (value)=>{\n            asap = value;\n        }\n    },\n    rejectionMapper: {\n        get: ()=>rejectionMapper,\n        set: (value)=>{\n            rejectionMapper = value;\n        }\n    },\n    follow: (fn, zoneProps)=>{\n        return new DexiePromise((resolve, reject)=>{\n            return newScope((resolve, reject)=>{\n                var psd = PSD;\n                psd.unhandleds = [];\n                psd.onunhandled = reject;\n                psd.finalize = callBoth(function() {\n                    run_at_end_of_this_or_next_physical_tick(()=>{\n                        this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);\n                    });\n                }, psd.finalize);\n                fn();\n            }, zoneProps, resolve, reject);\n        });\n    }\n});\nif (NativePromise) {\n    if (NativePromise.allSettled) setProp(DexiePromise, \"allSettled\", function() {\n        const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve)=>{\n            if (possiblePromises.length === 0) resolve([]);\n            let remaining = possiblePromises.length;\n            const results = new Array(remaining);\n            possiblePromises.forEach((p, i)=>DexiePromise.resolve(p).then((value)=>results[i] = {\n                        status: \"fulfilled\",\n                        value\n                    }, (reason)=>results[i] = {\n                        status: \"rejected\",\n                        reason\n                    }).then(()=>--remaining || resolve(results)));\n        });\n    });\n    if (NativePromise.any && typeof AggregateError !== \"undefined\") setProp(DexiePromise, \"any\", function() {\n        const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject)=>{\n            if (possiblePromises.length === 0) reject(new AggregateError([]));\n            let remaining = possiblePromises.length;\n            const failures = new Array(remaining);\n            possiblePromises.forEach((p, i)=>DexiePromise.resolve(p).then((value)=>resolve(value), (failure)=>{\n                    failures[i] = failure;\n                    if (!--remaining) reject(new AggregateError(failures));\n                }));\n        });\n    });\n}\nfunction executePromiseTask(promise, fn) {\n    try {\n        fn((value)=>{\n            if (promise._state !== null) return;\n            if (value === promise) throw new TypeError(\"A promise cannot be resolved with itself.\");\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\n            if (value && typeof value.then === \"function\") {\n                executePromiseTask(promise, (resolve, reject)=>{\n                    value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);\n                });\n            } else {\n                promise._state = true;\n                promise._value = value;\n                propagateAllListeners(promise);\n            }\n            if (shouldExecuteTick) endMicroTickScope();\n        }, handleRejection.bind(null, promise));\n    } catch (ex) {\n        handleRejection(promise, ex);\n    }\n}\nfunction handleRejection(promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null) return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === \"object\" && !reason._promise && tryCatch(()=>{\n        var origProp = getPropertyDescriptor(reason, \"stack\");\n        reason._promise = promise;\n        setProp(reason, \"stack\", {\n            get: ()=>stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack\n        });\n    });\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick) endMicroTickScope();\n}\nfunction propagateAllListeners(promise) {\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for(var i = 0, len = listeners.length; i < len; ++i){\n        propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize();\n    if (numScheduledCalls === 0) {\n        ++numScheduledCalls;\n        asap(()=>{\n            if (--numScheduledCalls === 0) finalizePhysicalTick();\n        }, []);\n    }\n}\nfunction propagateToListener(promise, listener) {\n    if (promise._state === null) {\n        promise._listeners.push(listener);\n        return;\n    }\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n        return (promise._state ? listener.resolve : listener.reject)(promise._value);\n    }\n    ++listener.psd.ref;\n    ++numScheduledCalls;\n    asap(callListener, [\n        cb,\n        promise,\n        listener\n    ]);\n}\nfunction callListener(cb, promise, listener) {\n    try {\n        currentFulfiller = promise;\n        var ret, value = promise._value;\n        if (promise._state) {\n            ret = cb(value);\n        } else {\n            if (rejectingErrors.length) rejectingErrors = [];\n            ret = cb(value);\n            if (rejectingErrors.indexOf(value) === -1) markErrorAsHandled(promise);\n        }\n        listener.resolve(ret);\n    } catch (e) {\n        listener.reject(e);\n    } finally{\n        currentFulfiller = null;\n        if (--numScheduledCalls === 0) finalizePhysicalTick();\n        --listener.psd.ref || listener.psd.finalize();\n    }\n}\nfunction getStack(promise, stacks, limit) {\n    if (stacks.length === limit) return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n        var failure = promise._value, errorName, message;\n        if (failure != null) {\n            errorName = failure.name || \"Error\";\n            message = failure.message || failure;\n            stack = prettyStack(failure, 0);\n        } else {\n            errorName = failure;\n            message = \"\";\n        }\n        stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n        stack = prettyStack(promise._stackHolder, 2);\n        if (stack && stacks.indexOf(stack) === -1) stacks.push(stack);\n        if (promise._prev) getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n}\nfunction linkToPreviousPromise(promise, prev) {\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n        promise._prev = prev;\n        promise._numPrev = numPrev;\n    }\n}\nfunction physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n}\nfunction beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n}\nfunction endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n        while(microtickQueue.length > 0){\n            callbacks = microtickQueue;\n            microtickQueue = [];\n            l = callbacks.length;\n            for(i = 0; i < l; ++i){\n                var item = callbacks[i];\n                item[0].apply(null, item[1]);\n            }\n        }\n    }while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n}\nfunction finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach((p)=>{\n        p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0);\n    var i = finalizers.length;\n    while(i)finalizers[--i]();\n}\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n    function finalizer() {\n        fn();\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap(()=>{\n        if (--numScheduledCalls === 0) finalizePhysicalTick();\n    }, []);\n}\nfunction addPossiblyUnhandledError(promise) {\n    if (!unhandledErrors.some((p)=>p._value === promise._value)) unhandledErrors.push(promise);\n}\nfunction markErrorAsHandled(promise) {\n    var i = unhandledErrors.length;\n    while(i)if (unhandledErrors[--i]._value === promise._value) {\n        unhandledErrors.splice(i, 1);\n        return;\n    }\n}\nfunction PromiseReject(reason) {\n    return new DexiePromise(INTERNAL, false, reason);\n}\nfunction wrap(fn, errorCatcher) {\n    var psd = PSD;\n    return function() {\n        var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn.apply(this, arguments);\n        } catch (e) {\n            errorCatcher && errorCatcher(e);\n        } finally{\n            switchToZone(outerScope, false);\n            if (wasRootExec) endMicroTickScope();\n        }\n    };\n}\nconst task = {\n    awaits: 0,\n    echoes: 0,\n    id: 0\n};\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\nfunction newScope(fn, props, a1, a2) {\n    var parent = PSD, psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    psd.id = ++zone_id_counter;\n    var globalEnv = globalPSD.env;\n    psd.env = patchGlobalPromise ? {\n        Promise: DexiePromise,\n        PromiseProp: {\n            value: DexiePromise,\n            configurable: true,\n            writable: true\n        },\n        all: DexiePromise.all,\n        race: DexiePromise.race,\n        allSettled: DexiePromise.allSettled,\n        any: DexiePromise.any,\n        resolve: DexiePromise.resolve,\n        reject: DexiePromise.reject,\n        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n        gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n    } : {};\n    if (props) extend(psd, props);\n    ++parent.ref;\n    psd.finalize = function() {\n        --this.parent.ref || this.parent.finalize();\n    };\n    var rv = usePSD(psd, fn, a1, a2);\n    if (psd.ref === 0) psd.finalize();\n    return rv;\n}\nfunction incrementExpectedAwaits() {\n    if (!task.id) task.id = ++taskCounter;\n    ++task.awaits;\n    task.echoes += ZONE_ECHO_LIMIT;\n    return task.id;\n}\nfunction decrementExpectedAwaits() {\n    if (!task.awaits) return false;\n    if (--task.awaits === 0) task.id = 0;\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n    return true;\n}\nif ((\"\" + nativePromiseThen).indexOf(\"[native code]\") === -1) {\n    incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\nfunction onPossibleParallellAsync(possiblePromise) {\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n        incrementExpectedAwaits();\n        return possiblePromise.then((x)=>{\n            decrementExpectedAwaits();\n            return x;\n        }, (e)=>{\n            decrementExpectedAwaits();\n            return rejection(e);\n        });\n    }\n    return possiblePromise;\n}\nfunction zoneEnterEcho(targetZone) {\n    ++totalEchoes;\n    if (!task.echoes || --task.echoes === 0) {\n        task.echoes = task.id = 0;\n    }\n    zoneStack.push(PSD);\n    switchToZone(targetZone, true);\n}\nfunction zoneLeaveEcho() {\n    var zone = zoneStack[zoneStack.length - 1];\n    zoneStack.pop();\n    switchToZone(zone, false);\n}\nfunction switchToZone(targetZone, bEnteringZone) {\n    var currentZone = PSD;\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n    }\n    if (targetZone === PSD) return;\n    PSD = targetZone;\n    if (currentZone === globalPSD) globalPSD.env = snapShot();\n    if (patchGlobalPromise) {\n        var GlobalPromise = globalPSD.env.Promise;\n        var targetEnv = targetZone.env;\n        nativePromiseProto.then = targetEnv.nthen;\n        GlobalPromise.prototype.then = targetEnv.gthen;\n        if (currentZone.global || targetZone.global) {\n            Object.defineProperty(_global, \"Promise\", targetEnv.PromiseProp);\n            GlobalPromise.all = targetEnv.all;\n            GlobalPromise.race = targetEnv.race;\n            GlobalPromise.resolve = targetEnv.resolve;\n            GlobalPromise.reject = targetEnv.reject;\n            if (targetEnv.allSettled) GlobalPromise.allSettled = targetEnv.allSettled;\n            if (targetEnv.any) GlobalPromise.any = targetEnv.any;\n        }\n    }\n}\nfunction snapShot() {\n    var GlobalPromise = _global.Promise;\n    return patchGlobalPromise ? {\n        Promise: GlobalPromise,\n        PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n        all: GlobalPromise.all,\n        race: GlobalPromise.race,\n        allSettled: GlobalPromise.allSettled,\n        any: GlobalPromise.any,\n        resolve: GlobalPromise.resolve,\n        reject: GlobalPromise.reject,\n        nthen: nativePromiseProto.then,\n        gthen: GlobalPromise.prototype.then\n    } : {};\n}\nfunction usePSD(psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n        switchToZone(psd, true);\n        return fn(a1, a2, a3);\n    } finally{\n        switchToZone(outerScope, false);\n    }\n}\nfunction enqueueNativeMicroTask(job) {\n    nativePromiseThen.call(resolvedNativePromise, job);\n}\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n    return typeof fn !== \"function\" ? fn : function() {\n        var outerZone = PSD;\n        if (possibleAwait) incrementExpectedAwaits();\n        switchToZone(zone, true);\n        try {\n            return fn.apply(this, arguments);\n        } finally{\n            switchToZone(outerZone, false);\n            if (cleanup) enqueueNativeMicroTask(decrementExpectedAwaits);\n        }\n    };\n}\nfunction getPatchedPromiseThen(origThen, zone) {\n    return function(onResolved, onRejected) {\n        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n    };\n}\nconst UNHANDLEDREJECTION = \"unhandledrejection\";\nfunction globalError(err, promise) {\n    var rv;\n    try {\n        rv = promise.onuncatched(err);\n    } catch (e) {}\n    if (rv !== false) try {\n        var event, eventData = {\n            promise: promise,\n            reason: err\n        };\n        if (_global.document && document.createEvent) {\n            event = document.createEvent(\"Event\");\n            event.initEvent(UNHANDLEDREJECTION, true, true);\n            extend(event, eventData);\n        } else if (_global.CustomEvent) {\n            event = new CustomEvent(UNHANDLEDREJECTION, {\n                detail: eventData\n            });\n            extend(event, eventData);\n        }\n        if (event && _global.dispatchEvent) {\n            dispatchEvent(event);\n            if (!_global.PromiseRejectionEvent && _global.onunhandledrejection) try {\n                _global.onunhandledrejection(event);\n            } catch (_) {}\n        }\n        if (debug && event && !event.defaultPrevented) {\n            console.warn(`Unhandled rejection: ${err.stack || err}`);\n        }\n    } catch (e) {}\n}\nvar rejection = DexiePromise.reject;\nfunction tempTransaction(db, mode, storeNames, fn) {\n    if (!db.idbdb || !db._state.openComplete && !PSD.letThrough && !db._vip) {\n        if (db._state.openComplete) {\n            return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n        }\n        if (!db._state.isBeingOpened) {\n            if (!db._options.autoOpen) return rejection(new exceptions.DatabaseClosed());\n            db.open().catch(nop);\n        }\n        return db._state.dbReadyPromise.then(()=>tempTransaction(db, mode, storeNames, fn));\n    } else {\n        var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n        try {\n            trans.create();\n            db._state.PR1398_maxLoop = 3;\n        } catch (ex) {\n            if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                console.warn(\"Dexie: Need to reopen db\");\n                db._close();\n                return db.open().then(()=>tempTransaction(db, mode, storeNames, fn));\n            }\n            return rejection(ex);\n        }\n        return trans._promise(mode, (resolve, reject)=>{\n            return newScope(()=>{\n                PSD.trans = trans;\n                return fn(resolve, reject, trans);\n            });\n        }).then((result)=>{\n            return trans._completion.then(()=>result);\n        });\n    }\n}\nconst DEXIE_VERSION = \"3.2.7\";\nconst maxString = String.fromCharCode(65535);\nconst minKey = -Infinity;\nconst INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nconst STRING_EXPECTED = \"String expected.\";\nconst connections = [];\nconst isIEOrEdge = typeof navigator !== \"undefined\" && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nconst hasIEDeleteObjectStoreBug = isIEOrEdge;\nconst hangsOnDeleteLargeKeyRange = isIEOrEdge;\nconst dexieStackFrameFilter = (frame)=>!/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\nconst DBNAMES_DB = \"__dbnames\";\nconst READONLY = \"readonly\";\nconst READWRITE = \"readwrite\";\nfunction combine(filter1, filter2) {\n    return filter1 ? filter2 ? function() {\n        return filter1.apply(this, arguments) && filter2.apply(this, arguments);\n    } : filter1 : filter2;\n}\nconst AnyRange = {\n    type: 3,\n    lower: -Infinity,\n    lowerOpen: false,\n    upper: [\n        []\n    ],\n    upperOpen: false\n};\nfunction workaroundForUndefinedPrimKey(keyPath) {\n    return typeof keyPath === \"string\" && !/\\./.test(keyPath) ? (obj)=>{\n        if (obj[keyPath] === undefined && keyPath in obj) {\n            obj = deepClone(obj);\n            delete obj[keyPath];\n        }\n        return obj;\n    } : (obj)=>obj;\n}\nclass Table {\n    _trans(mode, fn, writeLocked) {\n        const trans = this._tx || PSD.trans;\n        const tableName = this.name;\n        function checkTableInTransaction(resolve, reject, trans) {\n            if (!trans.schema[tableName]) throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n            return fn(trans.idbtrans, trans);\n        }\n        const wasRootExec = beginMicroTickScope();\n        try {\n            return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(()=>trans._promise(mode, checkTableInTransaction, writeLocked), {\n                trans: trans,\n                transless: PSD.transless || PSD\n            }) : tempTransaction(this.db, mode, [\n                this.name\n            ], checkTableInTransaction);\n        } finally{\n            if (wasRootExec) endMicroTickScope();\n        }\n    }\n    get(keyOrCrit, cb) {\n        if (keyOrCrit && keyOrCrit.constructor === Object) return this.where(keyOrCrit).first(cb);\n        return this._trans(\"readonly\", (trans)=>{\n            return this.core.get({\n                trans,\n                key: keyOrCrit\n            }).then((res)=>this.hook.reading.fire(res));\n        }).then(cb);\n    }\n    where(indexOrCrit) {\n        if (typeof indexOrCrit === \"string\") return new this.db.WhereClause(this, indexOrCrit);\n        if (isArray(indexOrCrit)) return new this.db.WhereClause(this, `[${indexOrCrit.join(\"+\")}]`);\n        const keyPaths = keys(indexOrCrit);\n        if (keyPaths.length === 1) return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);\n        const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter((ix)=>{\n            if (ix.compound && keyPaths.every((keyPath)=>ix.keyPath.indexOf(keyPath) >= 0)) {\n                for(let i = 0; i < keyPaths.length; ++i){\n                    if (keyPaths.indexOf(ix.keyPath[i]) === -1) return false;\n                }\n                return true;\n            }\n            return false;\n        }).sort((a, b)=>a.keyPath.length - b.keyPath.length)[0];\n        if (compoundIndex && this.db._maxKey !== maxString) {\n            const keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);\n            return this.where(keyPathsInValidOrder).equals(keyPathsInValidOrder.map((kp)=>indexOrCrit[kp]));\n        }\n        if (!compoundIndex && debug) console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a ` + `compound index [${keyPaths.join(\"+\")}]`);\n        const { idxByName } = this.schema;\n        const idb = this.db._deps.indexedDB;\n        function equals(a, b) {\n            try {\n                return idb.cmp(a, b) === 0;\n            } catch (e) {\n                return false;\n            }\n        }\n        const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath)=>{\n            const index = idxByName[keyPath];\n            const value = indexOrCrit[keyPath];\n            return [\n                prevIndex || index,\n                prevIndex || !index ? combine(prevFilterFn, index && index.multi ? (x)=>{\n                    const prop = getByKeyPath(x, keyPath);\n                    return isArray(prop) && prop.some((item)=>equals(value, item));\n                } : (x)=>equals(value, getByKeyPath(x, keyPath))) : prevFilterFn\n            ];\n        }, [\n            null,\n            null\n        ]);\n        return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals(\"\");\n    }\n    filter(filterFunction) {\n        return this.toCollection().and(filterFunction);\n    }\n    count(thenShortcut) {\n        return this.toCollection().count(thenShortcut);\n    }\n    offset(offset) {\n        return this.toCollection().offset(offset);\n    }\n    limit(numRows) {\n        return this.toCollection().limit(numRows);\n    }\n    each(callback) {\n        return this.toCollection().each(callback);\n    }\n    toArray(thenShortcut) {\n        return this.toCollection().toArray(thenShortcut);\n    }\n    toCollection() {\n        return new this.db.Collection(new this.db.WhereClause(this));\n    }\n    orderBy(index) {\n        return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ? `[${index.join(\"+\")}]` : index));\n    }\n    reverse() {\n        return this.toCollection().reverse();\n    }\n    mapToClass(constructor) {\n        this.schema.mappedClass = constructor;\n        const readHook = (obj)=>{\n            if (!obj) return obj;\n            const res = Object.create(constructor.prototype);\n            for(var m in obj)if (hasOwn(obj, m)) try {\n                res[m] = obj[m];\n            } catch (_) {}\n            return res;\n        };\n        if (this.schema.readHook) {\n            this.hook.reading.unsubscribe(this.schema.readHook);\n        }\n        this.schema.readHook = readHook;\n        this.hook(\"reading\", readHook);\n        return constructor;\n    }\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return this.mapToClass(Class);\n    }\n    add(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans(\"readwrite\", (trans)=>{\n            return this.core.mutate({\n                trans,\n                type: \"add\",\n                keys: key != null ? [\n                    key\n                ] : null,\n                values: [\n                    objToAdd\n                ]\n            });\n        }).then((res)=>res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult)=>{\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                } catch (_) {}\n            }\n            return lastResult;\n        });\n    }\n    update(keyOrObject, modifications) {\n        if (typeof keyOrObject === \"object\" && !isArray(keyOrObject)) {\n            const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n            if (key === undefined) return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n            try {\n                if (typeof modifications !== \"function\") {\n                    keys(modifications).forEach((keyPath)=>{\n                        setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n                    });\n                } else {\n                    modifications(keyOrObject, {\n                        value: keyOrObject,\n                        primKey: key\n                    });\n                }\n            } catch (_a) {}\n            return this.where(\":id\").equals(key).modify(modifications);\n        } else {\n            return this.where(\":id\").equals(keyOrObject).modify(modifications);\n        }\n    }\n    put(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans(\"readwrite\", (trans)=>this.core.mutate({\n                trans,\n                type: \"put\",\n                values: [\n                    objToAdd\n                ],\n                keys: key != null ? [\n                    key\n                ] : null\n            })).then((res)=>res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult)=>{\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                } catch (_) {}\n            }\n            return lastResult;\n        });\n    }\n    delete(key) {\n        return this._trans(\"readwrite\", (trans)=>this.core.mutate({\n                trans,\n                type: \"delete\",\n                keys: [\n                    key\n                ]\n            })).then((res)=>res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    clear() {\n        return this._trans(\"readwrite\", (trans)=>this.core.mutate({\n                trans,\n                type: \"deleteRange\",\n                range: AnyRange\n            })).then((res)=>res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    bulkGet(keys) {\n        return this._trans(\"readonly\", (trans)=>{\n            return this.core.getMany({\n                keys,\n                trans\n            }).then((result)=>result.map((res)=>this.hook.reading.fire(res)));\n        });\n    }\n    bulkAdd(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans(\"readwrite\", (trans)=>{\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys) throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;\n            return this.core.mutate({\n                trans,\n                type: \"add\",\n                keys: keys,\n                values: objectsToAdd,\n                wantResults\n            }).then(({ numFailures, results, lastResult, failures })=>{\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0) return result;\n                throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkPut(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans(\"readwrite\", (trans)=>{\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys) throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;\n            return this.core.mutate({\n                trans,\n                type: \"put\",\n                keys: keys,\n                values: objectsToPut,\n                wantResults\n            }).then(({ numFailures, results, lastResult, failures })=>{\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0) return result;\n                throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkDelete(keys) {\n        const numKeys = keys.length;\n        return this._trans(\"readwrite\", (trans)=>{\n            return this.core.mutate({\n                trans,\n                type: \"delete\",\n                keys: keys\n            });\n        }).then(({ numFailures, lastResult, failures })=>{\n            if (numFailures === 0) return lastResult;\n            throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);\n        });\n    }\n}\nfunction Events(ctx) {\n    var evs = {};\n    var rv = function(eventName, subscriber) {\n        if (subscriber) {\n            var i = arguments.length, args = new Array(i - 1);\n            while(--i)args[i - 1] = arguments[i];\n            evs[eventName].subscribe.apply(null, args);\n            return ctx;\n        } else if (typeof eventName === \"string\") {\n            return evs[eventName];\n        }\n    };\n    rv.addEventType = add;\n    for(var i = 1, l = arguments.length; i < l; ++i){\n        add(arguments[i]);\n    }\n    return rv;\n    function add(eventName, chainFunction, defaultFunction) {\n        if (typeof eventName === \"object\") return addConfiguredEvents(eventName);\n        if (!chainFunction) chainFunction = reverseStoppableEventChain;\n        if (!defaultFunction) defaultFunction = nop;\n        var context = {\n            subscribers: [],\n            fire: defaultFunction,\n            subscribe: function(cb) {\n                if (context.subscribers.indexOf(cb) === -1) {\n                    context.subscribers.push(cb);\n                    context.fire = chainFunction(context.fire, cb);\n                }\n            },\n            unsubscribe: function(cb) {\n                context.subscribers = context.subscribers.filter(function(fn) {\n                    return fn !== cb;\n                });\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n            }\n        };\n        evs[eventName] = rv[eventName] = context;\n        return context;\n    }\n    function addConfiguredEvents(cfg) {\n        keys(cfg).forEach(function(eventName) {\n            var args = cfg[eventName];\n            if (isArray(args)) {\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\n            } else if (args === \"asap\") {\n                var context = add(eventName, mirror, function fire() {\n                    var i = arguments.length, args = new Array(i);\n                    while(i--)args[i] = arguments[i];\n                    context.subscribers.forEach(function(fn) {\n                        asap$1(function fireEvent() {\n                            fn.apply(null, args);\n                        });\n                    });\n                });\n            } else throw new exceptions.InvalidArgument(\"Invalid event config\");\n        });\n    }\n}\nfunction makeClassConstructor(prototype, constructor) {\n    derive(constructor).from({\n        prototype\n    });\n    return constructor;\n}\nfunction createTableConstructor(db) {\n    return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n        this.db = db;\n        this._tx = trans;\n        this.name = name;\n        this.schema = tableSchema;\n        this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n            \"creating\": [\n                hookCreatingChain,\n                nop\n            ],\n            \"reading\": [\n                pureFunctionChain,\n                mirror\n            ],\n            \"updating\": [\n                hookUpdatingChain,\n                nop\n            ],\n            \"deleting\": [\n                hookDeletingChain,\n                nop\n            ]\n        });\n    });\n}\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n    return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\nfunction addFilter(ctx, fn) {\n    ctx.filter = combine(ctx.filter, fn);\n}\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n    var curr = ctx.replayFilter;\n    ctx.replayFilter = curr ? ()=>combine(curr(), factory()) : factory;\n    ctx.justLimit = isLimitFilter && !curr;\n}\nfunction addMatchFilter(ctx, fn) {\n    ctx.isMatch = combine(ctx.isMatch, fn);\n}\nfunction getIndexOrStore(ctx, coreSchema) {\n    if (ctx.isPrimKey) return coreSchema.primaryKey;\n    const index = coreSchema.getIndexByKeyPath(ctx.index);\n    if (!index) throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n    return index;\n}\nfunction openCursor(ctx, coreTable, trans) {\n    const index = getIndexOrStore(ctx, coreTable.schema);\n    return coreTable.openCursor({\n        trans,\n        values: !ctx.keysOnly,\n        reverse: ctx.dir === \"prev\",\n        unique: !!ctx.unique,\n        query: {\n            index,\n            range: ctx.range\n        }\n    });\n}\nfunction iter(ctx, fn, coreTrans, coreTable) {\n    const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n    if (!ctx.or) {\n        return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n    } else {\n        const set = {};\n        const union = (item, cursor, advance)=>{\n            if (!filter || filter(cursor, advance, (result)=>cursor.stop(result), (err)=>cursor.fail(err))) {\n                var primaryKey = cursor.primaryKey;\n                var key = \"\" + primaryKey;\n                if (key === \"[object ArrayBuffer]\") key = \"\" + new Uint8Array(primaryKey);\n                if (!hasOwn(set, key)) {\n                    set[key] = true;\n                    fn(item, cursor, advance);\n                }\n            }\n        };\n        return Promise.all([\n            ctx.or._iterate(union, coreTrans),\n            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n        ]);\n    }\n}\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n    var mappedFn = valueMapper ? (x, c, a)=>fn(valueMapper(x), c, a) : fn;\n    var wrappedFn = wrap(mappedFn);\n    return cursorPromise.then((cursor)=>{\n        if (cursor) {\n            return cursor.start(()=>{\n                var c = ()=>cursor.continue();\n                if (!filter || filter(cursor, (advancer)=>c = advancer, (val)=>{\n                    cursor.stop(val);\n                    c = nop;\n                }, (e)=>{\n                    cursor.fail(e);\n                    c = nop;\n                })) wrappedFn(cursor.value, cursor, (advancer)=>c = advancer);\n                c();\n            });\n        }\n    });\n}\nfunction cmp(a, b) {\n    try {\n        const ta = type(a);\n        const tb = type(b);\n        if (ta !== tb) {\n            if (ta === \"Array\") return 1;\n            if (tb === \"Array\") return -1;\n            if (ta === \"binary\") return 1;\n            if (tb === \"binary\") return -1;\n            if (ta === \"string\") return 1;\n            if (tb === \"string\") return -1;\n            if (ta === \"Date\") return 1;\n            if (tb !== \"Date\") return NaN;\n            return -1;\n        }\n        switch(ta){\n            case \"number\":\n            case \"Date\":\n            case \"string\":\n                return a > b ? 1 : a < b ? -1 : 0;\n            case \"binary\":\n                {\n                    return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n                }\n            case \"Array\":\n                return compareArrays(a, b);\n        }\n    } catch (_a) {}\n    return NaN;\n}\nfunction compareArrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for(let i = 0; i < l; ++i){\n        const res = cmp(a[i], b[i]);\n        if (res !== 0) return res;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction compareUint8Arrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for(let i = 0; i < l; ++i){\n        if (a[i] !== b[i]) return a[i] < b[i] ? -1 : 1;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction type(x) {\n    const t = typeof x;\n    if (t !== \"object\") return t;\n    if (ArrayBuffer.isView(x)) return \"binary\";\n    const tsTag = toStringTag(x);\n    return tsTag === \"ArrayBuffer\" ? \"binary\" : tsTag;\n}\nfunction getUint8Array(a) {\n    if (a instanceof Uint8Array) return a;\n    if (ArrayBuffer.isView(a)) return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return new Uint8Array(a);\n}\nclass Collection {\n    _read(fn, cb) {\n        var ctx = this._ctx;\n        return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans(\"readonly\", fn).then(cb);\n    }\n    _write(fn) {\n        var ctx = this._ctx;\n        return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans(\"readwrite\", fn, \"locked\");\n    }\n    _addAlgorithm(fn) {\n        var ctx = this._ctx;\n        ctx.algorithm = combine(ctx.algorithm, fn);\n    }\n    _iterate(fn, coreTrans) {\n        return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n    }\n    clone(props) {\n        var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n        if (props) extend(ctx, props);\n        rv._ctx = ctx;\n        return rv;\n    }\n    raw() {\n        this._ctx.valueMapper = null;\n        return this;\n    }\n    each(fn) {\n        var ctx = this._ctx;\n        return this._read((trans)=>iter(ctx, fn, trans, ctx.table.core));\n    }\n    count(cb) {\n        return this._read((trans)=>{\n            const ctx = this._ctx;\n            const coreTable = ctx.table.core;\n            if (isPlainKeyRange(ctx, true)) {\n                return coreTable.count({\n                    trans,\n                    query: {\n                        index: getIndexOrStore(ctx, coreTable.schema),\n                        range: ctx.range\n                    }\n                }).then((count)=>Math.min(count, ctx.limit));\n            } else {\n                var count = 0;\n                return iter(ctx, ()=>{\n                    ++count;\n                    return false;\n                }, trans, coreTable).then(()=>count);\n            }\n        }).then(cb);\n    }\n    sortBy(keyPath, cb) {\n        const parts = keyPath.split(\".\").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n        function getval(obj, i) {\n            if (i) return getval(obj[parts[i]], i - 1);\n            return obj[lastPart];\n        }\n        var order = this._ctx.dir === \"next\" ? 1 : -1;\n        function sorter(a, b) {\n            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n            return aVal < bVal ? -order : aVal > bVal ? order : 0;\n        }\n        return this.toArray(function(a) {\n            return a.sort(sorter);\n        }).then(cb);\n    }\n    toArray(cb) {\n        return this._read((trans)=>{\n            var ctx = this._ctx;\n            if (ctx.dir === \"next\" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                const { valueMapper } = ctx;\n                const index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    limit: ctx.limit,\n                    values: true,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                }).then(({ result })=>valueMapper ? result.map(valueMapper) : result);\n            } else {\n                const a = [];\n                return iter(ctx, (item)=>a.push(item), trans, ctx.table.core).then(()=>a);\n            }\n        }, cb);\n    }\n    offset(offset) {\n        var ctx = this._ctx;\n        if (offset <= 0) return this;\n        ctx.offset += offset;\n        if (isPlainKeyRange(ctx)) {\n            addReplayFilter(ctx, ()=>{\n                var offsetLeft = offset;\n                return (cursor, advance)=>{\n                    if (offsetLeft === 0) return true;\n                    if (offsetLeft === 1) {\n                        --offsetLeft;\n                        return false;\n                    }\n                    advance(()=>{\n                        cursor.advance(offsetLeft);\n                        offsetLeft = 0;\n                    });\n                    return false;\n                };\n            });\n        } else {\n            addReplayFilter(ctx, ()=>{\n                var offsetLeft = offset;\n                return ()=>--offsetLeft < 0;\n            });\n        }\n        return this;\n    }\n    limit(numRows) {\n        this._ctx.limit = Math.min(this._ctx.limit, numRows);\n        addReplayFilter(this._ctx, ()=>{\n            var rowsLeft = numRows;\n            return function(cursor, advance, resolve) {\n                if (--rowsLeft <= 0) advance(resolve);\n                return rowsLeft >= 0;\n            };\n        }, true);\n        return this;\n    }\n    until(filterFunction, bIncludeStopEntry) {\n        addFilter(this._ctx, function(cursor, advance, resolve) {\n            if (filterFunction(cursor.value)) {\n                advance(resolve);\n                return bIncludeStopEntry;\n            } else {\n                return true;\n            }\n        });\n        return this;\n    }\n    first(cb) {\n        return this.limit(1).toArray(function(a) {\n            return a[0];\n        }).then(cb);\n    }\n    last(cb) {\n        return this.reverse().first(cb);\n    }\n    filter(filterFunction) {\n        addFilter(this._ctx, function(cursor) {\n            return filterFunction(cursor.value);\n        });\n        addMatchFilter(this._ctx, filterFunction);\n        return this;\n    }\n    and(filter) {\n        return this.filter(filter);\n    }\n    or(indexName) {\n        return new this.db.WhereClause(this._ctx.table, indexName, this);\n    }\n    reverse() {\n        this._ctx.dir = this._ctx.dir === \"prev\" ? \"next\" : \"prev\";\n        if (this._ondirectionchange) this._ondirectionchange(this._ctx.dir);\n        return this;\n    }\n    desc() {\n        return this.reverse();\n    }\n    eachKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function(val, cursor) {\n            cb(cursor.key, cursor);\n        });\n    }\n    eachUniqueKey(cb) {\n        this._ctx.unique = \"unique\";\n        return this.eachKey(cb);\n    }\n    eachPrimaryKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function(val, cursor) {\n            cb(cursor.primaryKey, cursor);\n        });\n    }\n    keys(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function(item, cursor) {\n            a.push(cursor.key);\n        }).then(function() {\n            return a;\n        }).then(cb);\n    }\n    primaryKeys(cb) {\n        var ctx = this._ctx;\n        if (ctx.dir === \"next\" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n            return this._read((trans)=>{\n                var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    values: false,\n                    limit: ctx.limit,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                });\n            }).then(({ result })=>result).then(cb);\n        }\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function(item, cursor) {\n            a.push(cursor.primaryKey);\n        }).then(function() {\n            return a;\n        }).then(cb);\n    }\n    uniqueKeys(cb) {\n        this._ctx.unique = \"unique\";\n        return this.keys(cb);\n    }\n    firstKey(cb) {\n        return this.limit(1).keys(function(a) {\n            return a[0];\n        }).then(cb);\n    }\n    lastKey(cb) {\n        return this.reverse().firstKey(cb);\n    }\n    distinct() {\n        var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n        if (!idx || !idx.multi) return this;\n        var set = {};\n        addFilter(this._ctx, function(cursor) {\n            var strKey = cursor.primaryKey.toString();\n            var found = hasOwn(set, strKey);\n            set[strKey] = true;\n            return !found;\n        });\n        return this;\n    }\n    modify(changes) {\n        var ctx = this._ctx;\n        return this._write((trans)=>{\n            var modifyer;\n            if (typeof changes === \"function\") {\n                modifyer = changes;\n            } else {\n                var keyPaths = keys(changes);\n                var numKeys = keyPaths.length;\n                modifyer = function(item) {\n                    var anythingModified = false;\n                    for(var i = 0; i < numKeys; ++i){\n                        var keyPath = keyPaths[i], val = changes[keyPath];\n                        if (getByKeyPath(item, keyPath) !== val) {\n                            setByKeyPath(item, keyPath, val);\n                            anythingModified = true;\n                        }\n                    }\n                    return anythingModified;\n                };\n            }\n            const coreTable = ctx.table.core;\n            const { outbound, extractKey } = coreTable.schema.primaryKey;\n            const limit = this.db._options.modifyChunkSize || 200;\n            const totalFailures = [];\n            let successCount = 0;\n            const failedKeys = [];\n            const applyMutateResult = (expectedCount, res)=>{\n                const { failures, numFailures } = res;\n                successCount += expectedCount - numFailures;\n                for (let pos of keys(failures)){\n                    totalFailures.push(failures[pos]);\n                }\n            };\n            return this.clone().primaryKeys().then((keys)=>{\n                const nextChunk = (offset)=>{\n                    const count = Math.min(limit, keys.length - offset);\n                    return coreTable.getMany({\n                        trans,\n                        keys: keys.slice(offset, offset + count),\n                        cache: \"immutable\"\n                    }).then((values)=>{\n                        const addValues = [];\n                        const putValues = [];\n                        const putKeys = outbound ? [] : null;\n                        const deleteKeys = [];\n                        for(let i = 0; i < count; ++i){\n                            const origValue = values[i];\n                            const ctx = {\n                                value: deepClone(origValue),\n                                primKey: keys[offset + i]\n                            };\n                            if (modifyer.call(ctx, ctx.value, ctx) !== false) {\n                                if (ctx.value == null) {\n                                    deleteKeys.push(keys[offset + i]);\n                                } else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {\n                                    deleteKeys.push(keys[offset + i]);\n                                    addValues.push(ctx.value);\n                                } else {\n                                    putValues.push(ctx.value);\n                                    if (outbound) putKeys.push(keys[offset + i]);\n                                }\n                            }\n                        }\n                        const criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== \"function\" || changes === deleteCallback) && {\n                            index: ctx.index,\n                            range: ctx.range\n                        };\n                        return Promise.resolve(addValues.length > 0 && coreTable.mutate({\n                            trans,\n                            type: \"add\",\n                            values: addValues\n                        }).then((res)=>{\n                            for(let pos in res.failures){\n                                deleteKeys.splice(parseInt(pos), 1);\n                            }\n                            applyMutateResult(addValues.length, res);\n                        })).then(()=>(putValues.length > 0 || criteria && typeof changes === \"object\") && coreTable.mutate({\n                                trans,\n                                type: \"put\",\n                                keys: putKeys,\n                                values: putValues,\n                                criteria,\n                                changeSpec: typeof changes !== \"function\" && changes\n                            }).then((res)=>applyMutateResult(putValues.length, res))).then(()=>(deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({\n                                trans,\n                                type: \"delete\",\n                                keys: deleteKeys,\n                                criteria\n                            }).then((res)=>applyMutateResult(deleteKeys.length, res))).then(()=>{\n                            return keys.length > offset + count && nextChunk(offset + limit);\n                        });\n                    });\n                };\n                return nextChunk(0).then(()=>{\n                    if (totalFailures.length > 0) throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                    return keys.length;\n                });\n            });\n        });\n    }\n    delete() {\n        var ctx = this._ctx, range = ctx.range;\n        if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range.type === 3)) {\n            return this._write((trans)=>{\n                const { primaryKey } = ctx.table.core.schema;\n                const coreRange = range;\n                return ctx.table.core.count({\n                    trans,\n                    query: {\n                        index: primaryKey,\n                        range: coreRange\n                    }\n                }).then((count)=>{\n                    return ctx.table.core.mutate({\n                        trans,\n                        type: \"deleteRange\",\n                        range: coreRange\n                    }).then(({ failures, lastResult, results, numFailures })=>{\n                        if (numFailures) throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map((pos)=>failures[pos]), count - numFailures);\n                        return count - numFailures;\n                    });\n                });\n            });\n        }\n        return this.modify(deleteCallback);\n    }\n}\nconst deleteCallback = (value, ctx)=>ctx.value = null;\nfunction createCollectionConstructor(db) {\n    return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n        this.db = db;\n        let keyRange = AnyRange, error = null;\n        if (keyRangeGenerator) try {\n            keyRange = keyRangeGenerator();\n        } catch (ex) {\n            error = ex;\n        }\n        const whereCtx = whereClause._ctx;\n        const table = whereCtx.table;\n        const readingHook = table.hook.reading.fire;\n        this._ctx = {\n            table: table,\n            index: whereCtx.index,\n            isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,\n            range: keyRange,\n            keysOnly: false,\n            dir: \"next\",\n            unique: \"\",\n            algorithm: null,\n            filter: null,\n            replayFilter: null,\n            justLimit: true,\n            isMatch: null,\n            offset: 0,\n            limit: Infinity,\n            error: error,\n            or: whereCtx.or,\n            valueMapper: readingHook !== mirror ? readingHook : null\n        };\n    });\n}\nfunction simpleCompare(a, b) {\n    return a < b ? -1 : a === b ? 0 : 1;\n}\nfunction simpleCompareReverse(a, b) {\n    return a > b ? -1 : a === b ? 0 : 1;\n}\nfunction fail(collectionOrWhereClause, err, T) {\n    var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;\n    collection._ctx.error = T ? new T(err) : new TypeError(err);\n    return collection;\n}\nfunction emptyCollection(whereClause) {\n    return new whereClause.Collection(whereClause, ()=>rangeEqual(\"\")).limit(0);\n}\nfunction upperFactory(dir) {\n    return dir === \"next\" ? (s)=>s.toUpperCase() : (s)=>s.toLowerCase();\n}\nfunction lowerFactory(dir) {\n    return dir === \"next\" ? (s)=>s.toLowerCase() : (s)=>s.toUpperCase();\n}\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n    var length = Math.min(key.length, lowerNeedle.length);\n    var llp = -1;\n    for(var i = 0; i < length; ++i){\n        var lwrKeyChar = lowerKey[i];\n        if (lwrKeyChar !== lowerNeedle[i]) {\n            if (cmp(key[i], upperNeedle[i]) < 0) return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n            if (cmp(key[i], lowerNeedle[i]) < 0) return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n            if (llp >= 0) return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n            return null;\n        }\n        if (cmp(key[i], lwrKeyChar) < 0) llp = i;\n    }\n    if (length < lowerNeedle.length && dir === \"next\") return key + upperNeedle.substr(key.length);\n    if (length < key.length && dir === \"prev\") return key.substr(0, upperNeedle.length);\n    return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);\n}\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n    var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n    if (!needles.every((s)=>typeof s === \"string\")) {\n        return fail(whereClause, STRING_EXPECTED);\n    }\n    function initDirection(dir) {\n        upper = upperFactory(dir);\n        lower = lowerFactory(dir);\n        compare = dir === \"next\" ? simpleCompare : simpleCompareReverse;\n        var needleBounds = needles.map(function(needle) {\n            return {\n                lower: lower(needle),\n                upper: upper(needle)\n            };\n        }).sort(function(a, b) {\n            return compare(a.lower, b.lower);\n        });\n        upperNeedles = needleBounds.map(function(nb) {\n            return nb.upper;\n        });\n        lowerNeedles = needleBounds.map(function(nb) {\n            return nb.lower;\n        });\n        direction = dir;\n        nextKeySuffix = dir === \"next\" ? \"\" : suffix;\n    }\n    initDirection(\"next\");\n    var c = new whereClause.Collection(whereClause, ()=>createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));\n    c._ondirectionchange = function(direction) {\n        initDirection(direction);\n    };\n    var firstPossibleNeedle = 0;\n    c._addAlgorithm(function(cursor, advance, resolve) {\n        var key = cursor.key;\n        if (typeof key !== \"string\") return false;\n        var lowerKey = lower(key);\n        if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n            return true;\n        } else {\n            var lowestPossibleCasing = null;\n            for(var i = firstPossibleNeedle; i < needlesLen; ++i){\n                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                if (casing === null && lowestPossibleCasing === null) firstPossibleNeedle = i + 1;\n                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                    lowestPossibleCasing = casing;\n                }\n            }\n            if (lowestPossibleCasing !== null) {\n                advance(function() {\n                    cursor.continue(lowestPossibleCasing + nextKeySuffix);\n                });\n            } else {\n                advance(resolve);\n            }\n            return false;\n        }\n    });\n    return c;\n}\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n    return {\n        type: 2,\n        lower,\n        upper,\n        lowerOpen,\n        upperOpen\n    };\n}\nfunction rangeEqual(value) {\n    return {\n        type: 1,\n        lower: value,\n        upper: value\n    };\n}\nclass WhereClause {\n    get Collection() {\n        return this._ctx.table.db.Collection;\n    }\n    between(lower, upper, includeLower, includeUpper) {\n        includeLower = includeLower !== false;\n        includeUpper = includeUpper === true;\n        try {\n            if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)) return emptyCollection(this);\n            return new this.Collection(this, ()=>createRange(lower, upper, !includeLower, !includeUpper));\n        } catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n    }\n    equals(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>rangeEqual(value));\n    }\n    above(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>createRange(value, undefined, true));\n    }\n    aboveOrEqual(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>createRange(value, undefined, false));\n    }\n    below(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>createRange(undefined, value, false, true));\n    }\n    belowOrEqual(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>createRange(undefined, value));\n    }\n    startsWith(str) {\n        if (typeof str !== \"string\") return fail(this, STRING_EXPECTED);\n        return this.between(str, str + maxString, true, true);\n    }\n    startsWithIgnoreCase(str) {\n        if (str === \"\") return this.startsWith(str);\n        return addIgnoreCaseAlgorithm(this, (x, a)=>x.indexOf(a[0]) === 0, [\n            str\n        ], maxString);\n    }\n    equalsIgnoreCase(str) {\n        return addIgnoreCaseAlgorithm(this, (x, a)=>x === a[0], [\n            str\n        ], \"\");\n    }\n    anyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0) return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a)=>a.indexOf(x) !== -1, set, \"\");\n    }\n    startsWithAnyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0) return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a)=>a.some((n)=>x.indexOf(n) === 0), set, maxString);\n    }\n    anyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        let compare = this._cmp;\n        try {\n            set.sort(compare);\n        } catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        if (set.length === 0) return emptyCollection(this);\n        const c = new this.Collection(this, ()=>createRange(set[0], set[set.length - 1]));\n        c._ondirectionchange = (direction)=>{\n            compare = direction === \"next\" ? this._ascending : this._descending;\n            set.sort(compare);\n        };\n        let i = 0;\n        c._addAlgorithm((cursor, advance, resolve)=>{\n            const key = cursor.key;\n            while(compare(key, set[i]) > 0){\n                ++i;\n                if (i === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (compare(key, set[i]) === 0) {\n                return true;\n            } else {\n                advance(()=>{\n                    cursor.continue(set[i]);\n                });\n                return false;\n            }\n        });\n        return c;\n    }\n    notEqual(value) {\n        return this.inAnyRange([\n            [\n                minKey,\n                value\n            ],\n            [\n                value,\n                this.db._maxKey\n            ]\n        ], {\n            includeLowers: false,\n            includeUppers: false\n        });\n    }\n    noneOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0) return new this.Collection(this);\n        try {\n            set.sort(this._ascending);\n        } catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        const ranges = set.reduce((res, val)=>res ? res.concat([\n                [\n                    res[res.length - 1][1],\n                    val\n                ]\n            ]) : [\n                [\n                    minKey,\n                    val\n                ]\n            ], null);\n        ranges.push([\n            set[set.length - 1],\n            this.db._maxKey\n        ]);\n        return this.inAnyRange(ranges, {\n            includeLowers: false,\n            includeUppers: false\n        });\n    }\n    inAnyRange(ranges, options) {\n        const cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n        if (ranges.length === 0) return emptyCollection(this);\n        if (!ranges.every((range)=>range[0] !== undefined && range[1] !== undefined && ascending(range[0], range[1]) <= 0)) {\n            return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n        }\n        const includeLowers = !options || options.includeLowers !== false;\n        const includeUppers = options && options.includeUppers === true;\n        function addRange(ranges, newRange) {\n            let i = 0, l = ranges.length;\n            for(; i < l; ++i){\n                const range = ranges[i];\n                if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                    range[0] = min(range[0], newRange[0]);\n                    range[1] = max(range[1], newRange[1]);\n                    break;\n                }\n            }\n            if (i === l) ranges.push(newRange);\n            return ranges;\n        }\n        let sortDirection = ascending;\n        function rangeSorter(a, b) {\n            return sortDirection(a[0], b[0]);\n        }\n        let set;\n        try {\n            set = ranges.reduce(addRange, []);\n            set.sort(rangeSorter);\n        } catch (ex) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        let rangePos = 0;\n        const keyIsBeyondCurrentEntry = includeUppers ? (key)=>ascending(key, set[rangePos][1]) > 0 : (key)=>ascending(key, set[rangePos][1]) >= 0;\n        const keyIsBeforeCurrentEntry = includeLowers ? (key)=>descending(key, set[rangePos][0]) > 0 : (key)=>descending(key, set[rangePos][0]) >= 0;\n        function keyWithinCurrentRange(key) {\n            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n        }\n        let checkKey = keyIsBeyondCurrentEntry;\n        const c = new this.Collection(this, ()=>createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));\n        c._ondirectionchange = (direction)=>{\n            if (direction === \"next\") {\n                checkKey = keyIsBeyondCurrentEntry;\n                sortDirection = ascending;\n            } else {\n                checkKey = keyIsBeforeCurrentEntry;\n                sortDirection = descending;\n            }\n            set.sort(rangeSorter);\n        };\n        c._addAlgorithm((cursor, advance, resolve)=>{\n            var key = cursor.key;\n            while(checkKey(key)){\n                ++rangePos;\n                if (rangePos === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (keyWithinCurrentRange(key)) {\n                return true;\n            } else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {\n                return false;\n            } else {\n                advance(()=>{\n                    if (sortDirection === ascending) cursor.continue(set[rangePos][0]);\n                    else cursor.continue(set[rangePos][1]);\n                });\n                return false;\n            }\n        });\n        return c;\n    }\n    startsWithAnyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (!set.every((s)=>typeof s === \"string\")) {\n            return fail(this, \"startsWithAnyOf() only works with strings\");\n        }\n        if (set.length === 0) return emptyCollection(this);\n        return this.inAnyRange(set.map((str)=>[\n                str,\n                str + maxString\n            ]));\n    }\n}\nfunction createWhereClauseConstructor(db) {\n    return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n        this.db = db;\n        this._ctx = {\n            table: table,\n            index: index === \":id\" ? null : index,\n            or: orCollection\n        };\n        const indexedDB1 = db._deps.indexedDB;\n        if (!indexedDB1) throw new exceptions.MissingAPI();\n        this._cmp = this._ascending = indexedDB1.cmp.bind(indexedDB1);\n        this._descending = (a, b)=>indexedDB1.cmp(b, a);\n        this._max = (a, b)=>indexedDB1.cmp(a, b) > 0 ? a : b;\n        this._min = (a, b)=>indexedDB1.cmp(a, b) < 0 ? a : b;\n        this._IDBKeyRange = db._deps.IDBKeyRange;\n    });\n}\nfunction eventRejectHandler(reject) {\n    return wrap(function(event) {\n        preventDefault(event);\n        reject(event.target.error);\n        return false;\n    });\n}\nfunction preventDefault(event) {\n    if (event.stopPropagation) event.stopPropagation();\n    if (event.preventDefault) event.preventDefault();\n}\nconst DEXIE_STORAGE_MUTATED_EVENT_NAME = \"storagemutated\";\nconst STORAGE_MUTATED_DOM_EVENT_NAME = \"x-storagemutated-1\";\nconst globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\nclass Transaction {\n    _lock() {\n        assert(!PSD.global);\n        ++this._reculock;\n        if (this._reculock === 1 && !PSD.global) PSD.lockOwnerFor = this;\n        return this;\n    }\n    _unlock() {\n        assert(!PSD.global);\n        if (--this._reculock === 0) {\n            if (!PSD.global) PSD.lockOwnerFor = null;\n            while(this._blockedFuncs.length > 0 && !this._locked()){\n                var fnAndPSD = this._blockedFuncs.shift();\n                try {\n                    usePSD(fnAndPSD[1], fnAndPSD[0]);\n                } catch (e) {}\n            }\n        }\n        return this;\n    }\n    _locked() {\n        return this._reculock && PSD.lockOwnerFor !== this;\n    }\n    create(idbtrans) {\n        if (!this.mode) return this;\n        const idbdb = this.db.idbdb;\n        const dbOpenError = this.db._state.dbOpenError;\n        assert(!this.idbtrans);\n        if (!idbtrans && !idbdb) {\n            switch(dbOpenError && dbOpenError.name){\n                case \"DatabaseClosedError\":\n                    throw new exceptions.DatabaseClosed(dbOpenError);\n                case \"MissingAPIError\":\n                    throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                default:\n                    throw new exceptions.OpenFailed(dbOpenError);\n            }\n        }\n        if (!this.active) throw new exceptions.TransactionInactive();\n        assert(this._completion._state === null);\n        idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, {\n            durability: this.chromeTransactionDurability\n        }) : idbdb.transaction(this.storeNames, this.mode, {\n            durability: this.chromeTransactionDurability\n        }));\n        idbtrans.onerror = wrap((ev)=>{\n            preventDefault(ev);\n            this._reject(idbtrans.error);\n        });\n        idbtrans.onabort = wrap((ev)=>{\n            preventDefault(ev);\n            this.active && this._reject(new exceptions.Abort(idbtrans.error));\n            this.active = false;\n            this.on(\"abort\").fire(ev);\n        });\n        idbtrans.oncomplete = wrap(()=>{\n            this.active = false;\n            this._resolve();\n            if (\"mutatedParts\" in idbtrans) {\n                globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n            }\n        });\n        return this;\n    }\n    _promise(mode, fn, bWriteLock) {\n        if (mode === \"readwrite\" && this.mode !== \"readwrite\") return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n        if (!this.active) return rejection(new exceptions.TransactionInactive());\n        if (this._locked()) {\n            return new DexiePromise((resolve, reject)=>{\n                this._blockedFuncs.push([\n                    ()=>{\n                        this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                    },\n                    PSD\n                ]);\n            });\n        } else if (bWriteLock) {\n            return newScope(()=>{\n                var p = new DexiePromise((resolve, reject)=>{\n                    this._lock();\n                    const rv = fn(resolve, reject, this);\n                    if (rv && rv.then) rv.then(resolve, reject);\n                });\n                p.finally(()=>this._unlock());\n                p._lib = true;\n                return p;\n            });\n        } else {\n            var p = new DexiePromise((resolve, reject)=>{\n                var rv = fn(resolve, reject, this);\n                if (rv && rv.then) rv.then(resolve, reject);\n            });\n            p._lib = true;\n            return p;\n        }\n    }\n    _root() {\n        return this.parent ? this.parent._root() : this;\n    }\n    waitFor(promiseLike) {\n        var root = this._root();\n        const promise = DexiePromise.resolve(promiseLike);\n        if (root._waitingFor) {\n            root._waitingFor = root._waitingFor.then(()=>promise);\n        } else {\n            root._waitingFor = promise;\n            root._waitingQueue = [];\n            var store = root.idbtrans.objectStore(root.storeNames[0]);\n            (function spin() {\n                ++root._spinCount;\n                while(root._waitingQueue.length)root._waitingQueue.shift()();\n                if (root._waitingFor) store.get(-Infinity).onsuccess = spin;\n            })();\n        }\n        var currentWaitPromise = root._waitingFor;\n        return new DexiePromise((resolve, reject)=>{\n            promise.then((res)=>root._waitingQueue.push(wrap(resolve.bind(null, res))), (err)=>root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(()=>{\n                if (root._waitingFor === currentWaitPromise) {\n                    root._waitingFor = null;\n                }\n            });\n        });\n    }\n    abort() {\n        if (this.active) {\n            this.active = false;\n            if (this.idbtrans) this.idbtrans.abort();\n            this._reject(new exceptions.Abort());\n        }\n    }\n    table(tableName) {\n        const memoizedTables = this._memoizedTables || (this._memoizedTables = {});\n        if (hasOwn(memoizedTables, tableName)) return memoizedTables[tableName];\n        const tableSchema = this.schema[tableName];\n        if (!tableSchema) {\n            throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n        }\n        const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n        transactionBoundTable.core = this.db.core.table(tableName);\n        memoizedTables[tableName] = transactionBoundTable;\n        return transactionBoundTable;\n    }\n}\nfunction createTransactionConstructor(db) {\n    return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n        this.db = db;\n        this.mode = mode;\n        this.storeNames = storeNames;\n        this.schema = dbschema;\n        this.chromeTransactionDurability = chromeTransactionDurability;\n        this.idbtrans = null;\n        this.on = Events(this, \"complete\", \"error\", \"abort\");\n        this.parent = parent || null;\n        this.active = true;\n        this._reculock = 0;\n        this._blockedFuncs = [];\n        this._resolve = null;\n        this._reject = null;\n        this._waitingFor = null;\n        this._waitingQueue = null;\n        this._spinCount = 0;\n        this._completion = new DexiePromise((resolve, reject)=>{\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        this._completion.then(()=>{\n            this.active = false;\n            this.on.complete.fire();\n        }, (e)=>{\n            var wasActive = this.active;\n            this.active = false;\n            this.on.error.fire(e);\n            this.parent ? this.parent._reject(e) : wasActive && this.idbtrans && this.idbtrans.abort();\n            return rejection(e);\n        });\n    });\n}\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n    return {\n        name,\n        keyPath,\n        unique,\n        multi,\n        auto,\n        compound,\n        src: (unique && !isPrimKey ? \"&\" : \"\") + (multi ? \"*\" : \"\") + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n    };\n}\nfunction nameFromKeyPath(keyPath) {\n    return typeof keyPath === \"string\" ? keyPath : keyPath ? \"[\" + [].join.call(keyPath, \"+\") + \"]\" : \"\";\n}\nfunction createTableSchema(name, primKey, indexes) {\n    return {\n        name,\n        primKey,\n        indexes,\n        mappedClass: null,\n        idxByName: arrayToObject(indexes, (index)=>[\n                index.name,\n                index\n            ])\n    };\n}\nfunction safariMultiStoreFix(storeNames) {\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\nlet getMaxKey = (IdbKeyRange)=>{\n    try {\n        IdbKeyRange.only([\n            []\n        ]);\n        getMaxKey = ()=>[\n                []\n            ];\n        return [\n            []\n        ];\n    } catch (e) {\n        getMaxKey = ()=>maxString;\n        return maxString;\n    }\n};\nfunction getKeyExtractor(keyPath) {\n    if (keyPath == null) {\n        return ()=>undefined;\n    } else if (typeof keyPath === \"string\") {\n        return getSinglePathKeyExtractor(keyPath);\n    } else {\n        return (obj)=>getByKeyPath(obj, keyPath);\n    }\n}\nfunction getSinglePathKeyExtractor(keyPath) {\n    const split = keyPath.split(\".\");\n    if (split.length === 1) {\n        return (obj)=>obj[keyPath];\n    } else {\n        return (obj)=>getByKeyPath(obj, keyPath);\n    }\n}\nfunction arrayify(arrayLike) {\n    return [].slice.call(arrayLike);\n}\nlet _id_counter = 0;\nfunction getKeyPathAlias(keyPath) {\n    return keyPath == null ? \":id\" : typeof keyPath === \"string\" ? keyPath : `[${keyPath.join(\"+\")}]`;\n}\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n    function extractSchema(db, trans) {\n        const tables = arrayify(db.objectStoreNames);\n        return {\n            schema: {\n                name: db.name,\n                tables: tables.map((table)=>trans.objectStore(table)).map((store)=>{\n                    const { keyPath, autoIncrement } = store;\n                    const compound = isArray(keyPath);\n                    const outbound = keyPath == null;\n                    const indexByKeyPath = {};\n                    const result = {\n                        name: store.name,\n                        primaryKey: {\n                            name: null,\n                            isPrimaryKey: true,\n                            outbound,\n                            compound,\n                            keyPath,\n                            autoIncrement,\n                            unique: true,\n                            extractKey: getKeyExtractor(keyPath)\n                        },\n                        indexes: arrayify(store.indexNames).map((indexName)=>store.index(indexName)).map((index)=>{\n                            const { name, unique, multiEntry, keyPath } = index;\n                            const compound = isArray(keyPath);\n                            const result = {\n                                name,\n                                compound,\n                                keyPath,\n                                unique,\n                                multiEntry,\n                                extractKey: getKeyExtractor(keyPath)\n                            };\n                            indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                            return result;\n                        }),\n                        getIndexByKeyPath: (keyPath)=>indexByKeyPath[getKeyPathAlias(keyPath)]\n                    };\n                    indexByKeyPath[\":id\"] = result.primaryKey;\n                    if (keyPath != null) {\n                        indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                    }\n                    return result;\n                })\n            },\n            hasGetAll: tables.length > 0 && \"getAll\" in trans.objectStore(tables[0]) && !(typeof navigator !== \"undefined\" && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n        };\n    }\n    function makeIDBKeyRange(range) {\n        if (range.type === 3) return null;\n        if (range.type === 4) throw new Error(\"Cannot convert never type to IDBKeyRange\");\n        const { lower, upper, lowerOpen, upperOpen } = range;\n        const idbRange = lower === undefined ? upper === undefined ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === undefined ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n        return idbRange;\n    }\n    function createDbCoreTable(tableSchema) {\n        const tableName = tableSchema.name;\n        function mutate({ trans, type, keys, values, range }) {\n            return new Promise((resolve, reject)=>{\n                resolve = wrap(resolve);\n                const store = trans.objectStore(tableName);\n                const outbound = store.keyPath == null;\n                const isAddOrPut = type === \"put\" || type === \"add\";\n                if (!isAddOrPut && type !== \"delete\" && type !== \"deleteRange\") throw new Error(\"Invalid operation type: \" + type);\n                const { length } = keys || values || {\n                    length: 1\n                };\n                if (keys && values && keys.length !== values.length) {\n                    throw new Error(\"Given keys array must have same length as given values array.\");\n                }\n                if (length === 0) return resolve({\n                    numFailures: 0,\n                    failures: {},\n                    results: [],\n                    lastResult: undefined\n                });\n                let req;\n                const reqs = [];\n                const failures = [];\n                let numFailures = 0;\n                const errorHandler = (event)=>{\n                    ++numFailures;\n                    preventDefault(event);\n                };\n                if (type === \"deleteRange\") {\n                    if (range.type === 4) return resolve({\n                        numFailures,\n                        failures,\n                        results: [],\n                        lastResult: undefined\n                    });\n                    if (range.type === 3) reqs.push(req = store.clear());\n                    else reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                } else {\n                    const [args1, args2] = isAddOrPut ? outbound ? [\n                        values,\n                        keys\n                    ] : [\n                        values,\n                        null\n                    ] : [\n                        keys,\n                        null\n                    ];\n                    if (isAddOrPut) {\n                        for(let i = 0; i < length; ++i){\n                            reqs.push(req = args2 && args2[i] !== undefined ? store[type](args1[i], args2[i]) : store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    } else {\n                        for(let i = 0; i < length; ++i){\n                            reqs.push(req = store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                }\n                const done = (event)=>{\n                    const lastResult = event.target.result;\n                    reqs.forEach((req, i)=>req.error != null && (failures[i] = req.error));\n                    resolve({\n                        numFailures,\n                        failures,\n                        results: type === \"delete\" ? keys : reqs.map((req)=>req.result),\n                        lastResult\n                    });\n                };\n                req.onerror = (event)=>{\n                    errorHandler(event);\n                    done(event);\n                };\n                req.onsuccess = done;\n            });\n        }\n        function openCursor({ trans, values, query, reverse, unique }) {\n            return new Promise((resolve, reject)=>{\n                resolve = wrap(resolve);\n                const { index, range } = query;\n                const store = trans.objectStore(tableName);\n                const source = index.isPrimaryKey ? store : store.index(index.name);\n                const direction = reverse ? unique ? \"prevunique\" : \"prev\" : unique ? \"nextunique\" : \"next\";\n                const req = values || !(\"openKeyCursor\" in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);\n                req.onerror = eventRejectHandler(reject);\n                req.onsuccess = wrap((ev)=>{\n                    const cursor = req.result;\n                    if (!cursor) {\n                        resolve(null);\n                        return;\n                    }\n                    cursor.___id = ++_id_counter;\n                    cursor.done = false;\n                    const _cursorContinue = cursor.continue.bind(cursor);\n                    let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                    if (_cursorContinuePrimaryKey) _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                    const _cursorAdvance = cursor.advance.bind(cursor);\n                    const doThrowCursorIsNotStarted = ()=>{\n                        throw new Error(\"Cursor not started\");\n                    };\n                    const doThrowCursorIsStopped = ()=>{\n                        throw new Error(\"Cursor not stopped\");\n                    };\n                    cursor.trans = trans;\n                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                    cursor.fail = wrap(reject);\n                    cursor.next = function() {\n                        let gotOne = 1;\n                        return this.start(()=>gotOne-- ? this.continue() : this.stop()).then(()=>this);\n                    };\n                    cursor.start = (callback)=>{\n                        const iterationPromise = new Promise((resolveIteration, rejectIteration)=>{\n                            resolveIteration = wrap(resolveIteration);\n                            req.onerror = eventRejectHandler(rejectIteration);\n                            cursor.fail = rejectIteration;\n                            cursor.stop = (value)=>{\n                                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                resolveIteration(value);\n                            };\n                        });\n                        const guardedCallback = ()=>{\n                            if (req.result) {\n                                try {\n                                    callback();\n                                } catch (err) {\n                                    cursor.fail(err);\n                                }\n                            } else {\n                                cursor.done = true;\n                                cursor.start = ()=>{\n                                    throw new Error(\"Cursor behind last entry\");\n                                };\n                                cursor.stop();\n                            }\n                        };\n                        req.onsuccess = wrap((ev)=>{\n                            req.onsuccess = guardedCallback;\n                            guardedCallback();\n                        });\n                        cursor.continue = _cursorContinue;\n                        cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                        cursor.advance = _cursorAdvance;\n                        guardedCallback();\n                        return iterationPromise;\n                    };\n                    resolve(cursor);\n                }, reject);\n            });\n        }\n        function query(hasGetAll) {\n            return (request)=>{\n                return new Promise((resolve, reject)=>{\n                    resolve = wrap(resolve);\n                    const { trans, values, limit, query } = request;\n                    const nonInfinitLimit = limit === Infinity ? undefined : limit;\n                    const { index, range } = query;\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    if (limit === 0) return resolve({\n                        result: []\n                    });\n                    if (hasGetAll) {\n                        const req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                        req.onsuccess = (event)=>resolve({\n                                result: event.target.result\n                            });\n                        req.onerror = eventRejectHandler(reject);\n                    } else {\n                        let count = 0;\n                        const req = values || !(\"openKeyCursor\" in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);\n                        const result = [];\n                        req.onsuccess = (event)=>{\n                            const cursor = req.result;\n                            if (!cursor) return resolve({\n                                result\n                            });\n                            result.push(values ? cursor.value : cursor.primaryKey);\n                            if (++count === limit) return resolve({\n                                result\n                            });\n                            cursor.continue();\n                        };\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                });\n            };\n        }\n        return {\n            name: tableName,\n            schema: tableSchema,\n            mutate,\n            getMany ({ trans, keys }) {\n                return new Promise((resolve, reject)=>{\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const length = keys.length;\n                    const result = new Array(length);\n                    let keyCount = 0;\n                    let callbackCount = 0;\n                    let req;\n                    const successHandler = (event)=>{\n                        const req = event.target;\n                        if ((result[req._pos] = req.result) != null) ;\n                        if (++callbackCount === keyCount) resolve(result);\n                    };\n                    const errorHandler = eventRejectHandler(reject);\n                    for(let i = 0; i < length; ++i){\n                        const key = keys[i];\n                        if (key != null) {\n                            req = store.get(keys[i]);\n                            req._pos = i;\n                            req.onsuccess = successHandler;\n                            req.onerror = errorHandler;\n                            ++keyCount;\n                        }\n                    }\n                    if (keyCount === 0) resolve(result);\n                });\n            },\n            get ({ trans, key }) {\n                return new Promise((resolve, reject)=>{\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const req = store.get(key);\n                    req.onsuccess = (event)=>resolve(event.target.result);\n                    req.onerror = eventRejectHandler(reject);\n                });\n            },\n            query: query(hasGetAll),\n            openCursor,\n            count ({ query, trans }) {\n                const { index, range } = query;\n                return new Promise((resolve, reject)=>{\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    const req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                    req.onsuccess = wrap((ev)=>resolve(ev.target.result));\n                    req.onerror = eventRejectHandler(reject);\n                });\n            }\n        };\n    }\n    const { schema, hasGetAll } = extractSchema(db, tmpTrans);\n    const tables = schema.tables.map((tableSchema)=>createDbCoreTable(tableSchema));\n    const tableMap = {};\n    tables.forEach((table)=>tableMap[table.name] = table);\n    return {\n        stack: \"dbcore\",\n        transaction: db.transaction.bind(db),\n        table (name) {\n            const result = tableMap[name];\n            if (!result) throw new Error(`Table '${name}' not found`);\n            return tableMap[name];\n        },\n        MIN_KEY: -Infinity,\n        MAX_KEY: getMaxKey(IdbKeyRange),\n        schema\n    };\n}\nfunction createMiddlewareStack(stackImpl, middlewares) {\n    return middlewares.reduce((down, { create })=>({\n            ...down,\n            ...create(down)\n        }), stackImpl);\n}\nfunction createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange, indexedDB: indexedDB1 }, tmpTrans) {\n    const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n    return {\n        dbcore\n    };\n}\nfunction generateMiddlewareStacks({ _novip: db }, tmpTrans) {\n    const idbdb = tmpTrans.db;\n    const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n    db.core = stacks.dbcore;\n    db.tables.forEach((table)=>{\n        const tableName = table.name;\n        if (db.core.schema.tables.some((tbl)=>tbl.name === tableName)) {\n            table.core = db.core.table(tableName);\n            if (db[tableName] instanceof db.Table) {\n                db[tableName].core = table.core;\n            }\n        }\n    });\n}\nfunction setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {\n    tableNames.forEach((tableName)=>{\n        const schema = dbschema[tableName];\n        objs.forEach((obj)=>{\n            const propDesc = getPropertyDescriptor(obj, tableName);\n            if (!propDesc || \"value\" in propDesc && propDesc.value === undefined) {\n                if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                    setProp(obj, tableName, {\n                        get () {\n                            return this.table(tableName);\n                        },\n                        set (value) {\n                            defineProperty(this, tableName, {\n                                value,\n                                writable: true,\n                                configurable: true,\n                                enumerable: true\n                            });\n                        }\n                    });\n                } else {\n                    obj[tableName] = new db.Table(tableName, schema);\n                }\n            }\n        });\n    });\n}\nfunction removeTablesApi({ _novip: db }, objs) {\n    objs.forEach((obj)=>{\n        for(let key in obj){\n            if (obj[key] instanceof db.Table) delete obj[key];\n        }\n    });\n}\nfunction lowerVersionFirst(a, b) {\n    return a._cfg.version - b._cfg.version;\n}\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n    const globalSchema = db._dbSchema;\n    const trans = db._createTransaction(\"readwrite\", db._storeNames, globalSchema);\n    trans.create(idbUpgradeTrans);\n    trans._completion.catch(reject);\n    const rejectTransaction = trans._reject.bind(trans);\n    const transless = PSD.transless || PSD;\n    newScope(()=>{\n        PSD.trans = trans;\n        PSD.transless = transless;\n        if (oldVersion === 0) {\n            keys(globalSchema).forEach((tableName)=>{\n                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n            });\n            generateMiddlewareStacks(db, idbUpgradeTrans);\n            DexiePromise.follow(()=>db.on.populate.fire(trans)).catch(rejectTransaction);\n        } else updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n    });\n}\nfunction updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {\n    const queue = [];\n    const versions = db._versions;\n    let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n    let anyContentUpgraderHasRun = false;\n    const versToRun = versions.filter((v)=>v._cfg.version >= oldVersion);\n    versToRun.forEach((version)=>{\n        queue.push(()=>{\n            const oldSchema = globalSchema;\n            const newSchema = version._cfg.dbschema;\n            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n            globalSchema = db._dbSchema = newSchema;\n            const diff = getSchemaDiff(oldSchema, newSchema);\n            diff.add.forEach((tuple)=>{\n                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n            });\n            diff.change.forEach((change)=>{\n                if (change.recreate) {\n                    throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                } else {\n                    const store = idbUpgradeTrans.objectStore(change.name);\n                    change.add.forEach((idx)=>addIndex(store, idx));\n                    change.change.forEach((idx)=>{\n                        store.deleteIndex(idx.name);\n                        addIndex(store, idx);\n                    });\n                    change.del.forEach((idxName)=>store.deleteIndex(idxName));\n                }\n            });\n            const contentUpgrade = version._cfg.contentUpgrade;\n            if (contentUpgrade && version._cfg.version > oldVersion) {\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                trans._memoizedTables = {};\n                anyContentUpgraderHasRun = true;\n                let upgradeSchema = shallowClone(newSchema);\n                diff.del.forEach((table)=>{\n                    upgradeSchema[table] = oldSchema[table];\n                });\n                removeTablesApi(db, [\n                    db.Transaction.prototype\n                ]);\n                setApiOnPlace(db, [\n                    db.Transaction.prototype\n                ], keys(upgradeSchema), upgradeSchema);\n                trans.schema = upgradeSchema;\n                const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n                if (contentUpgradeIsAsync) {\n                    incrementExpectedAwaits();\n                }\n                let returnValue;\n                const promiseFollowed = DexiePromise.follow(()=>{\n                    returnValue = contentUpgrade(trans);\n                    if (returnValue) {\n                        if (contentUpgradeIsAsync) {\n                            var decrementor = decrementExpectedAwaits.bind(null, null);\n                            returnValue.then(decrementor, decrementor);\n                        }\n                    }\n                });\n                return returnValue && typeof returnValue.then === \"function\" ? DexiePromise.resolve(returnValue) : promiseFollowed.then(()=>returnValue);\n            }\n        });\n        queue.push((idbtrans)=>{\n            if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n                const newSchema = version._cfg.dbschema;\n                deleteRemovedTables(newSchema, idbtrans);\n            }\n            removeTablesApi(db, [\n                db.Transaction.prototype\n            ]);\n            setApiOnPlace(db, [\n                db.Transaction.prototype\n            ], db._storeNames, db._dbSchema);\n            trans.schema = db._dbSchema;\n        });\n    });\n    function runQueue() {\n        return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();\n    }\n    return runQueue().then(()=>{\n        createMissingTables(globalSchema, idbUpgradeTrans);\n    });\n}\nfunction getSchemaDiff(oldSchema, newSchema) {\n    const diff = {\n        del: [],\n        add: [],\n        change: []\n    };\n    let table;\n    for(table in oldSchema){\n        if (!newSchema[table]) diff.del.push(table);\n    }\n    for(table in newSchema){\n        const oldDef = oldSchema[table], newDef = newSchema[table];\n        if (!oldDef) {\n            diff.add.push([\n                table,\n                newDef\n            ]);\n        } else {\n            const change = {\n                name: table,\n                def: newDef,\n                recreate: false,\n                del: [],\n                add: [],\n                change: []\n            };\n            if (\"\" + (oldDef.primKey.keyPath || \"\") !== \"\" + (newDef.primKey.keyPath || \"\") || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {\n                change.recreate = true;\n                diff.change.push(change);\n            } else {\n                const oldIndexes = oldDef.idxByName;\n                const newIndexes = newDef.idxByName;\n                let idxName;\n                for(idxName in oldIndexes){\n                    if (!newIndexes[idxName]) change.del.push(idxName);\n                }\n                for(idxName in newIndexes){\n                    const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                    if (!oldIdx) change.add.push(newIdx);\n                    else if (oldIdx.src !== newIdx.src) change.change.push(newIdx);\n                }\n                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                    diff.change.push(change);\n                }\n            }\n        }\n    }\n    return diff;\n}\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n    const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? {\n        keyPath: primKey.keyPath,\n        autoIncrement: primKey.auto\n    } : {\n        autoIncrement: primKey.auto\n    });\n    indexes.forEach((idx)=>addIndex(store, idx));\n    return store;\n}\nfunction createMissingTables(newSchema, idbtrans) {\n    keys(newSchema).forEach((tableName)=>{\n        if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n        }\n    });\n}\nfunction deleteRemovedTables(newSchema, idbtrans) {\n    [].slice.call(idbtrans.db.objectStoreNames).forEach((storeName)=>newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));\n}\nfunction addIndex(store, idx) {\n    store.createIndex(idx.name, idx.keyPath, {\n        unique: idx.unique,\n        multiEntry: idx.multi\n    });\n}\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n    const globalSchema = {};\n    const dbStoreNames = slice(idbdb.objectStoreNames, 0);\n    dbStoreNames.forEach((storeName)=>{\n        const store = tmpTrans.objectStore(storeName);\n        let keyPath = store.keyPath;\n        const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n        const indexes = [];\n        for(let j = 0; j < store.indexNames.length; ++j){\n            const idbindex = store.index(store.indexNames[j]);\n            keyPath = idbindex.keyPath;\n            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n            indexes.push(index);\n        }\n        globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n    });\n    return globalSchema;\n}\nfunction readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {\n    db.verno = idbdb.version / 10;\n    const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n    db._storeNames = slice(idbdb.objectStoreNames, 0);\n    setApiOnPlace(db, [\n        db._allTables\n    ], keys(globalSchema), globalSchema);\n}\nfunction verifyInstalledSchema(db, tmpTrans) {\n    const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n    const diff = getSchemaDiff(installedSchema, db._dbSchema);\n    return !(diff.add.length || diff.change.some((ch)=>ch.add.length || ch.change.length));\n}\nfunction adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {\n    const storeNames = idbtrans.db.objectStoreNames;\n    for(let i = 0; i < storeNames.length; ++i){\n        const storeName = storeNames[i];\n        const store = idbtrans.objectStore(storeName);\n        db._hasGetAll = \"getAll\" in store;\n        for(let j = 0; j < store.indexNames.length; ++j){\n            const indexName = store.indexNames[j];\n            const keyPath = store.index(indexName).keyPath;\n            const dexieName = typeof keyPath === \"string\" ? keyPath : \"[\" + slice(keyPath).join(\"+\") + \"]\";\n            if (schema[storeName]) {\n                const indexSpec = schema[storeName].idxByName[dexieName];\n                if (indexSpec) {\n                    indexSpec.name = indexName;\n                    delete schema[storeName].idxByName[dexieName];\n                    schema[storeName].idxByName[indexName] = indexSpec;\n                }\n            }\n        }\n    }\n    if (typeof navigator !== \"undefined\" && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n        db._hasGetAll = false;\n    }\n}\nfunction parseIndexSyntax(primKeyAndIndexes) {\n    return primKeyAndIndexes.split(\",\").map((index, indexNum)=>{\n        index = index.trim();\n        const name = index.replace(/([&*]|\\+\\+)/g, \"\");\n        const keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split(\"+\") : name;\n        return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n    });\n}\nclass Version {\n    _parseStoresSpec(stores, outSchema) {\n        keys(stores).forEach((tableName)=>{\n            if (stores[tableName] !== null) {\n                var indexes = parseIndexSyntax(stores[tableName]);\n                var primKey = indexes.shift();\n                if (primKey.multi) throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                indexes.forEach((idx)=>{\n                    if (idx.auto) throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                    if (!idx.keyPath) throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                });\n                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n            }\n        });\n    }\n    stores(stores) {\n        const db = this.db;\n        this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;\n        const versions = db._versions;\n        const storesSpec = {};\n        let dbschema = {};\n        versions.forEach((version)=>{\n            extend(storesSpec, version._cfg.storesSource);\n            dbschema = version._cfg.dbschema = {};\n            version._parseStoresSpec(storesSpec, dbschema);\n        });\n        db._dbSchema = dbschema;\n        removeTablesApi(db, [\n            db._allTables,\n            db,\n            db.Transaction.prototype\n        ]);\n        setApiOnPlace(db, [\n            db._allTables,\n            db,\n            db.Transaction.prototype,\n            this._cfg.tables\n        ], keys(dbschema), dbschema);\n        db._storeNames = keys(dbschema);\n        return this;\n    }\n    upgrade(upgradeFunction) {\n        this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n        return this;\n    }\n}\nfunction createVersionConstructor(db) {\n    return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n        this.db = db;\n        this._cfg = {\n            version: versionNumber,\n            storesSource: null,\n            dbschema: {},\n            tables: {},\n            contentUpgrade: null\n        };\n    });\n}\nfunction getDbNamesTable(indexedDB1, IDBKeyRange) {\n    let dbNamesDB = indexedDB1[\"_dbNamesDB\"];\n    if (!dbNamesDB) {\n        dbNamesDB = indexedDB1[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n            addons: [],\n            indexedDB: indexedDB1,\n            IDBKeyRange\n        });\n        dbNamesDB.version(1).stores({\n            dbnames: \"name\"\n        });\n    }\n    return dbNamesDB.table(\"dbnames\");\n}\nfunction hasDatabasesNative(indexedDB1) {\n    return indexedDB1 && typeof indexedDB1.databases === \"function\";\n}\nfunction getDatabaseNames({ indexedDB: indexedDB1, IDBKeyRange }) {\n    return hasDatabasesNative(indexedDB1) ? Promise.resolve(indexedDB1.databases()).then((infos)=>infos.map((info)=>info.name).filter((name)=>name !== DBNAMES_DB)) : getDbNamesTable(indexedDB1, IDBKeyRange).toCollection().primaryKeys();\n}\nfunction _onDatabaseCreated({ indexedDB: indexedDB1, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB1) && name !== DBNAMES_DB && getDbNamesTable(indexedDB1, IDBKeyRange).put({\n        name\n    }).catch(nop);\n}\nfunction _onDatabaseDeleted({ indexedDB: indexedDB1, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB1) && name !== DBNAMES_DB && getDbNamesTable(indexedDB1, IDBKeyRange).delete(name).catch(nop);\n}\nfunction vip(fn) {\n    return newScope(function() {\n        PSD.letThrough = true;\n        return fn();\n    });\n}\nfunction idbReady() {\n    var isSafari = !navigator.userAgentData && /Safari\\//.test(navigator.userAgent) && !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    if (!isSafari || !indexedDB.databases) return Promise.resolve();\n    var intervalId;\n    return new Promise(function(resolve) {\n        var tryIdb = function() {\n            return indexedDB.databases().finally(resolve);\n        };\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(function() {\n        return clearInterval(intervalId);\n    });\n}\nfunction dexieOpen(db) {\n    const state = db._state;\n    const { indexedDB: indexedDB1 } = db._deps;\n    if (state.isBeingOpened || db.idbdb) return state.dbReadyPromise.then(()=>state.dbOpenError ? rejection(state.dbOpenError) : db);\n    debug && (state.openCanceller._stackHolder = getErrorWithStack());\n    state.isBeingOpened = true;\n    state.dbOpenError = null;\n    state.openComplete = false;\n    const openCanceller = state.openCanceller;\n    function throwIfCancelled() {\n        if (state.openCanceller !== openCanceller) throw new exceptions.DatabaseClosed(\"db.open() was cancelled\");\n    }\n    let resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;\n    const tryOpenDB = ()=>new DexiePromise((resolve, reject)=>{\n            throwIfCancelled();\n            if (!indexedDB1) throw new exceptions.MissingAPI();\n            const dbName = db.name;\n            const req = state.autoSchema ? indexedDB1.open(dbName) : indexedDB1.open(dbName, Math.round(db.verno * 10));\n            if (!req) throw new exceptions.MissingAPI();\n            req.onerror = eventRejectHandler(reject);\n            req.onblocked = wrap(db._fireOnBlocked);\n            req.onupgradeneeded = wrap((e)=>{\n                upgradeTransaction = req.transaction;\n                if (state.autoSchema && !db._options.allowEmptyDB) {\n                    req.onerror = preventDefault;\n                    upgradeTransaction.abort();\n                    req.result.close();\n                    const delreq = indexedDB1.deleteDatabase(dbName);\n                    delreq.onsuccess = delreq.onerror = wrap(()=>{\n                        reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));\n                    });\n                } else {\n                    upgradeTransaction.onerror = eventRejectHandler(reject);\n                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                    wasCreated = oldVer < 1;\n                    db._novip.idbdb = req.result;\n                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n                }\n            }, reject);\n            req.onsuccess = wrap(()=>{\n                upgradeTransaction = null;\n                const idbdb = db._novip.idbdb = req.result;\n                const objectStoreNames = slice(idbdb.objectStoreNames);\n                if (objectStoreNames.length > 0) try {\n                    const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), \"readonly\");\n                    if (state.autoSchema) readGlobalSchema(db, idbdb, tmpTrans);\n                    else {\n                        adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                        if (!verifyInstalledSchema(db, tmpTrans)) {\n                            console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);\n                        }\n                    }\n                    generateMiddlewareStacks(db, tmpTrans);\n                } catch (e) {}\n                connections.push(db);\n                idbdb.onversionchange = wrap((ev)=>{\n                    state.vcFired = true;\n                    db.on(\"versionchange\").fire(ev);\n                });\n                idbdb.onclose = wrap((ev)=>{\n                    db.on(\"close\").fire(ev);\n                });\n                if (wasCreated) _onDatabaseCreated(db._deps, dbName);\n                resolve();\n            }, reject);\n        }).catch((err)=>{\n            if (err && err.name === \"UnknownError\" && state.PR1398_maxLoop > 0) {\n                state.PR1398_maxLoop--;\n                console.warn(\"Dexie: Workaround for Chrome UnknownError on open()\");\n                return tryOpenDB();\n            } else {\n                return DexiePromise.reject(err);\n            }\n        });\n    return DexiePromise.race([\n        openCanceller,\n        (typeof navigator === \"undefined\" ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)\n    ]).then(()=>{\n        throwIfCancelled();\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(()=>db.on.ready.fire(db.vip))).then(function fireRemainders() {\n            if (state.onReadyBeingFired.length > 0) {\n                let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n                state.onReadyBeingFired = [];\n                return DexiePromise.resolve(vip(()=>remainders(db.vip))).then(fireRemainders);\n            }\n        });\n    }).finally(()=>{\n        state.onReadyBeingFired = null;\n        state.isBeingOpened = false;\n    }).then(()=>{\n        return db;\n    }).catch((err)=>{\n        state.dbOpenError = err;\n        try {\n            upgradeTransaction && upgradeTransaction.abort();\n        } catch (_a) {}\n        if (openCanceller === state.openCanceller) {\n            db._close();\n        }\n        return rejection(err);\n    }).finally(()=>{\n        state.openComplete = true;\n        resolveDbReady();\n    });\n}\nfunction awaitIterator(iterator) {\n    var callNext = (result)=>iterator.next(result), doThrow = (error)=>iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);\n    function step(getNext) {\n        return (val)=>{\n            var next = getNext(val), value = next.value;\n            return next.done ? value : !value || typeof value.then !== \"function\" ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);\n        };\n    }\n    return step(callNext)();\n}\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n    var i = arguments.length;\n    if (i < 2) throw new exceptions.InvalidArgument(\"Too few arguments\");\n    var args = new Array(i - 1);\n    while(--i)args[i - 1] = arguments[i];\n    scopeFunc = args.pop();\n    var tables = flatten(args);\n    return [\n        mode,\n        tables,\n        scopeFunc\n    ];\n}\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n    return DexiePromise.resolve().then(()=>{\n        const transless = PSD.transless || PSD;\n        const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n        const zoneProps = {\n            trans: trans,\n            transless: transless\n        };\n        if (parentTransaction) {\n            trans.idbtrans = parentTransaction.idbtrans;\n        } else {\n            try {\n                trans.create();\n                db._state.PR1398_maxLoop = 3;\n            } catch (ex) {\n                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                    console.warn(\"Dexie: Need to reopen db\");\n                    db._close();\n                    return db.open().then(()=>enterTransactionScope(db, mode, storeNames, null, scopeFunc));\n                }\n                return rejection(ex);\n            }\n        }\n        const scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n        if (scopeFuncIsAsync) {\n            incrementExpectedAwaits();\n        }\n        let returnValue;\n        const promiseFollowed = DexiePromise.follow(()=>{\n            returnValue = scopeFunc.call(trans, trans);\n            if (returnValue) {\n                if (scopeFuncIsAsync) {\n                    var decrementor = decrementExpectedAwaits.bind(null, null);\n                    returnValue.then(decrementor, decrementor);\n                } else if (typeof returnValue.next === \"function\" && typeof returnValue.throw === \"function\") {\n                    returnValue = awaitIterator(returnValue);\n                }\n            }\n        }, zoneProps);\n        return (returnValue && typeof returnValue.then === \"function\" ? DexiePromise.resolve(returnValue).then((x)=>trans.active ? x : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\"))) : promiseFollowed.then(()=>returnValue)).then((x)=>{\n            if (parentTransaction) trans._resolve();\n            return trans._completion.then(()=>x);\n        }).catch((e)=>{\n            trans._reject(e);\n            return rejection(e);\n        });\n    });\n}\nfunction pad(a, value, count) {\n    const result = isArray(a) ? a.slice() : [\n        a\n    ];\n    for(let i = 0; i < count; ++i)result.push(value);\n    return result;\n}\nfunction createVirtualIndexMiddleware(down) {\n    return {\n        ...down,\n        table (tableName) {\n            const table = down.table(tableName);\n            const { schema } = table;\n            const indexLookup = {};\n            const allVirtualIndexes = [];\n            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                const keyPathAlias = getKeyPathAlias(keyPath);\n                const indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];\n                const keyLength = keyPath == null ? 0 : typeof keyPath === \"string\" ? 1 : keyPath.length;\n                const isVirtual = keyTail > 0;\n                const virtualIndex = {\n                    ...lowLevelIndex,\n                    isVirtual,\n                    keyTail,\n                    keyLength,\n                    extractKey: getKeyExtractor(keyPath),\n                    unique: !isVirtual && lowLevelIndex.unique\n                };\n                indexList.push(virtualIndex);\n                if (!virtualIndex.isPrimaryKey) {\n                    allVirtualIndexes.push(virtualIndex);\n                }\n                if (keyLength > 1) {\n                    const virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);\n                    addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                }\n                indexList.sort((a, b)=>a.keyTail - b.keyTail);\n                return virtualIndex;\n            }\n            const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n            indexLookup[\":id\"] = [\n                primaryKey\n            ];\n            for (const index of schema.indexes){\n                addVirtualIndexes(index.keyPath, 0, index);\n            }\n            function findBestIndex(keyPath) {\n                const result = indexLookup[getKeyPathAlias(keyPath)];\n                return result && result[0];\n            }\n            function translateRange(range, keyTail) {\n                return {\n                    type: range.type === 1 ? 2 : range.type,\n                    lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                    lowerOpen: true,\n                    upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                    upperOpen: true\n                };\n            }\n            function translateRequest(req) {\n                const index = req.query.index;\n                return index.isVirtual ? {\n                    ...req,\n                    query: {\n                        index,\n                        range: translateRange(req.query.range, index.keyTail)\n                    }\n                } : req;\n            }\n            const result = {\n                ...table,\n                schema: {\n                    ...schema,\n                    primaryKey,\n                    indexes: allVirtualIndexes,\n                    getIndexByKeyPath: findBestIndex\n                },\n                count (req) {\n                    return table.count(translateRequest(req));\n                },\n                query (req) {\n                    return table.query(translateRequest(req));\n                },\n                openCursor (req) {\n                    const { keyTail, isVirtual, keyLength } = req.query.index;\n                    if (!isVirtual) return table.openCursor(req);\n                    function createVirtualCursor(cursor) {\n                        function _continue(key) {\n                            key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();\n                        }\n                        const virtualCursor = Object.create(cursor, {\n                            continue: {\n                                value: _continue\n                            },\n                            continuePrimaryKey: {\n                                value (key, primaryKey) {\n                                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                }\n                            },\n                            primaryKey: {\n                                get () {\n                                    return cursor.primaryKey;\n                                }\n                            },\n                            key: {\n                                get () {\n                                    const key = cursor.key;\n                                    return keyLength === 1 ? key[0] : key.slice(0, keyLength);\n                                }\n                            },\n                            value: {\n                                get () {\n                                    return cursor.value;\n                                }\n                            }\n                        });\n                        return virtualCursor;\n                    }\n                    return table.openCursor(translateRequest(req)).then((cursor)=>cursor && createVirtualCursor(cursor));\n                }\n            };\n            return result;\n        }\n    };\n}\nconst virtualIndexMiddleware = {\n    stack: \"dbcore\",\n    name: \"VirtualIndexMiddleware\",\n    level: 1,\n    create: createVirtualIndexMiddleware\n};\nfunction getObjectDiff(a, b, rv, prfx) {\n    rv = rv || {};\n    prfx = prfx || \"\";\n    keys(a).forEach((prop)=>{\n        if (!hasOwn(b, prop)) {\n            rv[prfx + prop] = undefined;\n        } else {\n            var ap = a[prop], bp = b[prop];\n            if (typeof ap === \"object\" && typeof bp === \"object\" && ap && bp) {\n                const apTypeName = toStringTag(ap);\n                const bpTypeName = toStringTag(bp);\n                if (apTypeName !== bpTypeName) {\n                    rv[prfx + prop] = b[prop];\n                } else if (apTypeName === \"Object\") {\n                    getObjectDiff(ap, bp, rv, prfx + prop + \".\");\n                } else if (ap !== bp) {\n                    rv[prfx + prop] = b[prop];\n                }\n            } else if (ap !== bp) rv[prfx + prop] = b[prop];\n        }\n    });\n    keys(b).forEach((prop)=>{\n        if (!hasOwn(a, prop)) {\n            rv[prfx + prop] = b[prop];\n        }\n    });\n    return rv;\n}\nfunction getEffectiveKeys(primaryKey, req) {\n    if (req.type === \"delete\") return req.keys;\n    return req.keys || req.values.map(primaryKey.extractKey);\n}\nconst hooksMiddleware = {\n    stack: \"dbcore\",\n    name: \"HooksMiddleware\",\n    level: 2,\n    create: (downCore)=>({\n            ...downCore,\n            table (tableName) {\n                const downTable = downCore.table(tableName);\n                const { primaryKey } = downTable.schema;\n                const tableMiddleware = {\n                    ...downTable,\n                    mutate (req) {\n                        const dxTrans = PSD.trans;\n                        const { deleting, creating, updating } = dxTrans.table(tableName).hook;\n                        switch(req.type){\n                            case \"add\":\n                                if (creating.fire === nop) break;\n                                return dxTrans._promise(\"readwrite\", ()=>addPutOrDelete(req), true);\n                            case \"put\":\n                                if (creating.fire === nop && updating.fire === nop) break;\n                                return dxTrans._promise(\"readwrite\", ()=>addPutOrDelete(req), true);\n                            case \"delete\":\n                                if (deleting.fire === nop) break;\n                                return dxTrans._promise(\"readwrite\", ()=>addPutOrDelete(req), true);\n                            case \"deleteRange\":\n                                if (deleting.fire === nop) break;\n                                return dxTrans._promise(\"readwrite\", ()=>deleteRange(req), true);\n                        }\n                        return downTable.mutate(req);\n                        function addPutOrDelete(req) {\n                            const dxTrans = PSD.trans;\n                            const keys = req.keys || getEffectiveKeys(primaryKey, req);\n                            if (!keys) throw new Error(\"Keys missing\");\n                            req = req.type === \"add\" || req.type === \"put\" ? {\n                                ...req,\n                                keys\n                            } : {\n                                ...req\n                            };\n                            if (req.type !== \"delete\") req.values = [\n                                ...req.values\n                            ];\n                            if (req.keys) req.keys = [\n                                ...req.keys\n                            ];\n                            return getExistingValues(downTable, req, keys).then((existingValues)=>{\n                                const contexts = keys.map((key, i)=>{\n                                    const existingValue = existingValues[i];\n                                    const ctx = {\n                                        onerror: null,\n                                        onsuccess: null\n                                    };\n                                    if (req.type === \"delete\") {\n                                        deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                    } else if (req.type === \"add\" || existingValue === undefined) {\n                                        const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                        if (key == null && generatedPrimaryKey != null) {\n                                            key = generatedPrimaryKey;\n                                            req.keys[i] = key;\n                                            if (!primaryKey.outbound) {\n                                                setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                            }\n                                        }\n                                    } else {\n                                        const objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                        const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                        if (additionalChanges) {\n                                            const requestedValue = req.values[i];\n                                            Object.keys(additionalChanges).forEach((keyPath)=>{\n                                                if (hasOwn(requestedValue, keyPath)) {\n                                                    requestedValue[keyPath] = additionalChanges[keyPath];\n                                                } else {\n                                                    setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                                                }\n                                            });\n                                        }\n                                    }\n                                    return ctx;\n                                });\n                                return downTable.mutate(req).then(({ failures, results, numFailures, lastResult })=>{\n                                    for(let i = 0; i < keys.length; ++i){\n                                        const primKey = results ? results[i] : keys[i];\n                                        const ctx = contexts[i];\n                                        if (primKey == null) {\n                                            ctx.onerror && ctx.onerror(failures[i]);\n                                        } else {\n                                            ctx.onsuccess && ctx.onsuccess(req.type === \"put\" && existingValues[i] ? req.values[i] : primKey);\n                                        }\n                                    }\n                                    return {\n                                        failures,\n                                        results,\n                                        numFailures,\n                                        lastResult\n                                    };\n                                }).catch((error)=>{\n                                    contexts.forEach((ctx)=>ctx.onerror && ctx.onerror(error));\n                                    return Promise.reject(error);\n                                });\n                            });\n                        }\n                        function deleteRange(req) {\n                            return deleteNextChunk(req.trans, req.range, 10000);\n                        }\n                        function deleteNextChunk(trans, range, limit) {\n                            return downTable.query({\n                                trans,\n                                values: false,\n                                query: {\n                                    index: primaryKey,\n                                    range\n                                },\n                                limit\n                            }).then(({ result })=>{\n                                return addPutOrDelete({\n                                    type: \"delete\",\n                                    keys: result,\n                                    trans\n                                }).then((res)=>{\n                                    if (res.numFailures > 0) return Promise.reject(res.failures[0]);\n                                    if (result.length < limit) {\n                                        return {\n                                            failures: [],\n                                            numFailures: 0,\n                                            lastResult: undefined\n                                        };\n                                    } else {\n                                        return deleteNextChunk(trans, {\n                                            ...range,\n                                            lower: result[result.length - 1],\n                                            lowerOpen: true\n                                        }, limit);\n                                    }\n                                });\n                            });\n                        }\n                    }\n                };\n                return tableMiddleware;\n            }\n        })\n};\nfunction getExistingValues(table, req, effectiveKeys) {\n    return req.type === \"add\" ? Promise.resolve([]) : table.getMany({\n        trans: req.trans,\n        keys: effectiveKeys,\n        cache: \"immutable\"\n    });\n}\nfunction getFromTransactionCache(keys, cache, clone) {\n    try {\n        if (!cache) return null;\n        if (cache.keys.length < keys.length) return null;\n        const result = [];\n        for(let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i){\n            if (cmp(cache.keys[i], keys[j]) !== 0) continue;\n            result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n            ++j;\n        }\n        return result.length === keys.length ? result : null;\n    } catch (_a) {\n        return null;\n    }\n}\nconst cacheExistingValuesMiddleware = {\n    stack: \"dbcore\",\n    level: -1,\n    create: (core)=>{\n        return {\n            table: (tableName)=>{\n                const table = core.table(tableName);\n                return {\n                    ...table,\n                    getMany: (req)=>{\n                        if (!req.cache) {\n                            return table.getMany(req);\n                        }\n                        const cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                        if (cachedResult) {\n                            return DexiePromise.resolve(cachedResult);\n                        }\n                        return table.getMany(req).then((res)=>{\n                            req.trans[\"_cache\"] = {\n                                keys: req.keys,\n                                values: req.cache === \"clone\" ? deepClone(res) : res\n                            };\n                            return res;\n                        });\n                    },\n                    mutate: (req)=>{\n                        if (req.type !== \"add\") req.trans[\"_cache\"] = null;\n                        return table.mutate(req);\n                    }\n                };\n            }\n        };\n    }\n};\nfunction isEmptyRange(node) {\n    return !(\"from\" in node);\n}\nconst RangeSet = function(fromOrTree, to) {\n    if (this) {\n        extend(this, arguments.length ? {\n            d: 1,\n            from: fromOrTree,\n            to: arguments.length > 1 ? to : fromOrTree\n        } : {\n            d: 0\n        });\n    } else {\n        const rv = new RangeSet();\n        if (fromOrTree && \"d\" in fromOrTree) {\n            extend(rv, fromOrTree);\n        }\n        return rv;\n    }\n};\nprops(RangeSet.prototype, {\n    add (rangeSet) {\n        mergeRanges(this, rangeSet);\n        return this;\n    },\n    addKey (key) {\n        addRange(this, key, key);\n        return this;\n    },\n    addKeys (keys) {\n        keys.forEach((key)=>addRange(this, key, key));\n        return this;\n    },\n    [iteratorSymbol] () {\n        return getRangeSetIterator(this);\n    }\n});\nfunction addRange(target, from, to) {\n    const diff = cmp(from, to);\n    if (isNaN(diff)) return;\n    if (diff > 0) throw RangeError();\n    if (isEmptyRange(target)) return extend(target, {\n        from,\n        to,\n        d: 1\n    });\n    const left = target.l;\n    const right = target.r;\n    if (cmp(to, target.from) < 0) {\n        left ? addRange(left, from, to) : target.l = {\n            from,\n            to,\n            d: 1,\n            l: null,\n            r: null\n        };\n        return rebalance(target);\n    }\n    if (cmp(from, target.to) > 0) {\n        right ? addRange(right, from, to) : target.r = {\n            from,\n            to,\n            d: 1,\n            l: null,\n            r: null\n        };\n        return rebalance(target);\n    }\n    if (cmp(from, target.from) < 0) {\n        target.from = from;\n        target.l = null;\n        target.d = right ? right.d + 1 : 1;\n    }\n    if (cmp(to, target.to) > 0) {\n        target.to = to;\n        target.r = null;\n        target.d = target.l ? target.l.d + 1 : 1;\n    }\n    const rightWasCutOff = !target.r;\n    if (left && !target.l) {\n        mergeRanges(target, left);\n    }\n    if (right && rightWasCutOff) {\n        mergeRanges(target, right);\n    }\n}\nfunction mergeRanges(target, newSet) {\n    function _addRangeSet(target, { from, to, l, r }) {\n        addRange(target, from, to);\n        if (l) _addRangeSet(target, l);\n        if (r) _addRangeSet(target, r);\n    }\n    if (!isEmptyRange(newSet)) _addRangeSet(target, newSet);\n}\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n    const i1 = getRangeSetIterator(rangeSet2);\n    let nextResult1 = i1.next();\n    if (nextResult1.done) return false;\n    let a = nextResult1.value;\n    const i2 = getRangeSetIterator(rangeSet1);\n    let nextResult2 = i2.next(a.from);\n    let b = nextResult2.value;\n    while(!nextResult1.done && !nextResult2.done){\n        if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0) return true;\n        cmp(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;\n    }\n    return false;\n}\nfunction getRangeSetIterator(node) {\n    let state = isEmptyRange(node) ? null : {\n        s: 0,\n        n: node\n    };\n    return {\n        next (key) {\n            const keyProvided = arguments.length > 0;\n            while(state){\n                switch(state.s){\n                    case 0:\n                        state.s = 1;\n                        if (keyProvided) {\n                            while(state.n.l && cmp(key, state.n.from) < 0)state = {\n                                up: state,\n                                n: state.n.l,\n                                s: 1\n                            };\n                        } else {\n                            while(state.n.l)state = {\n                                up: state,\n                                n: state.n.l,\n                                s: 1\n                            };\n                        }\n                    case 1:\n                        state.s = 2;\n                        if (!keyProvided || cmp(key, state.n.to) <= 0) return {\n                            value: state.n,\n                            done: false\n                        };\n                    case 2:\n                        if (state.n.r) {\n                            state.s = 3;\n                            state = {\n                                up: state,\n                                n: state.n.r,\n                                s: 0\n                            };\n                            continue;\n                        }\n                    case 3:\n                        state = state.up;\n                }\n            }\n            return {\n                done: true\n            };\n        }\n    };\n}\nfunction rebalance(target) {\n    var _a, _b;\n    const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n    const r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n    if (r) {\n        const l = r === \"r\" ? \"l\" : \"r\";\n        const rootClone = {\n            ...target\n        };\n        const oldRootRight = target[r];\n        target.from = oldRootRight.from;\n        target.to = oldRootRight.to;\n        target[r] = oldRootRight[r];\n        rootClone[r] = oldRootRight[l];\n        target[l] = rootClone;\n        rootClone.d = computeDepth(rootClone);\n    }\n    target.d = computeDepth(target);\n}\nfunction computeDepth({ r, l }) {\n    return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;\n}\nconst observabilityMiddleware = {\n    stack: \"dbcore\",\n    level: 0,\n    create: (core)=>{\n        const dbName = core.schema.name;\n        const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n        return {\n            ...core,\n            table: (tableName)=>{\n                const table = core.table(tableName);\n                const { schema } = table;\n                const { primaryKey } = schema;\n                const { extractKey, outbound } = primaryKey;\n                const tableClone = {\n                    ...table,\n                    mutate: (req)=>{\n                        const trans = req.trans;\n                        const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n                        const getRangeSet = (indexName)=>{\n                            const part = `idb://${dbName}/${tableName}/${indexName}`;\n                            return mutatedParts[part] || (mutatedParts[part] = new RangeSet());\n                        };\n                        const pkRangeSet = getRangeSet(\"\");\n                        const delsRangeSet = getRangeSet(\":dels\");\n                        const { type } = req;\n                        let [keys, newObjs] = req.type === \"deleteRange\" ? [\n                            req.range\n                        ] : req.type === \"delete\" ? [\n                            req.keys\n                        ] : req.values.length < 50 ? [\n                            [],\n                            req.values\n                        ] : [];\n                        const oldCache = req.trans[\"_cache\"];\n                        return table.mutate(req).then((res)=>{\n                            if (isArray(keys)) {\n                                if (type !== \"delete\") keys = res.results;\n                                pkRangeSet.addKeys(keys);\n                                const oldObjs = getFromTransactionCache(keys, oldCache);\n                                if (!oldObjs && type !== \"add\") {\n                                    delsRangeSet.addKeys(keys);\n                                }\n                                if (oldObjs || newObjs) {\n                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                                }\n                            } else if (keys) {\n                                const range = {\n                                    from: keys.lower,\n                                    to: keys.upper\n                                };\n                                delsRangeSet.add(range);\n                                pkRangeSet.add(range);\n                            } else {\n                                pkRangeSet.add(FULL_RANGE);\n                                delsRangeSet.add(FULL_RANGE);\n                                schema.indexes.forEach((idx)=>getRangeSet(idx.name).add(FULL_RANGE));\n                            }\n                            return res;\n                        });\n                    }\n                };\n                const getRange = ({ query: { index, range } })=>{\n                    var _a, _b;\n                    return [\n                        index,\n                        new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY)\n                    ];\n                };\n                const readSubscribers = {\n                    get: (req)=>[\n                            primaryKey,\n                            new RangeSet(req.key)\n                        ],\n                    getMany: (req)=>[\n                            primaryKey,\n                            new RangeSet().addKeys(req.keys)\n                        ],\n                    count: getRange,\n                    query: getRange,\n                    openCursor: getRange\n                };\n                keys(readSubscribers).forEach((method)=>{\n                    tableClone[method] = function(req) {\n                        const { subscr } = PSD;\n                        if (subscr) {\n                            const getRangeSet = (indexName)=>{\n                                const part = `idb://${dbName}/${tableName}/${indexName}`;\n                                return subscr[part] || (subscr[part] = new RangeSet());\n                            };\n                            const pkRangeSet = getRangeSet(\"\");\n                            const delsRangeSet = getRangeSet(\":dels\");\n                            const [queriedIndex, queriedRanges] = readSubscribers[method](req);\n                            getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                            if (!queriedIndex.isPrimaryKey) {\n                                if (method === \"count\") {\n                                    delsRangeSet.add(FULL_RANGE);\n                                } else {\n                                    const keysPromise = method === \"query\" && outbound && req.values && table.query({\n                                        ...req,\n                                        values: false\n                                    });\n                                    return table[method].apply(this, arguments).then((res)=>{\n                                        if (method === \"query\") {\n                                            if (outbound && req.values) {\n                                                return keysPromise.then(({ result: resultingKeys })=>{\n                                                    pkRangeSet.addKeys(resultingKeys);\n                                                    return res;\n                                                });\n                                            }\n                                            const pKeys = req.values ? res.result.map(extractKey) : res.result;\n                                            if (req.values) {\n                                                pkRangeSet.addKeys(pKeys);\n                                            } else {\n                                                delsRangeSet.addKeys(pKeys);\n                                            }\n                                        } else if (method === \"openCursor\") {\n                                            const cursor = res;\n                                            const wantValues = req.values;\n                                            return cursor && Object.create(cursor, {\n                                                key: {\n                                                    get () {\n                                                        delsRangeSet.addKey(cursor.primaryKey);\n                                                        return cursor.key;\n                                                    }\n                                                },\n                                                primaryKey: {\n                                                    get () {\n                                                        const pkey = cursor.primaryKey;\n                                                        delsRangeSet.addKey(pkey);\n                                                        return pkey;\n                                                    }\n                                                },\n                                                value: {\n                                                    get () {\n                                                        wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                                                        return cursor.value;\n                                                    }\n                                                }\n                                            });\n                                        }\n                                        return res;\n                                    });\n                                }\n                            }\n                        }\n                        return table[method].apply(this, arguments);\n                    };\n                });\n                return tableClone;\n            }\n        };\n    }\n};\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n    function addAffectedIndex(ix) {\n        const rangeSet = getRangeSet(ix.name || \"\");\n        function extractKey(obj) {\n            return obj != null ? ix.extractKey(obj) : null;\n        }\n        const addKeyOrKeys = (key)=>ix.multiEntry && isArray(key) ? key.forEach((key)=>rangeSet.addKey(key)) : rangeSet.addKey(key);\n        (oldObjs || newObjs).forEach((_, i)=>{\n            const oldKey = oldObjs && extractKey(oldObjs[i]);\n            const newKey = newObjs && extractKey(newObjs[i]);\n            if (cmp(oldKey, newKey) !== 0) {\n                if (oldKey != null) addKeyOrKeys(oldKey);\n                if (newKey != null) addKeyOrKeys(newKey);\n            }\n        });\n    }\n    schema.indexes.forEach(addAffectedIndex);\n}\nclass Dexie$1 {\n    constructor(name, options){\n        this._middlewares = {};\n        this.verno = 0;\n        const deps = Dexie$1.dependencies;\n        this._options = options = {\n            addons: Dexie$1.addons,\n            autoOpen: true,\n            indexedDB: deps.indexedDB,\n            IDBKeyRange: deps.IDBKeyRange,\n            ...options\n        };\n        this._deps = {\n            indexedDB: options.indexedDB,\n            IDBKeyRange: options.IDBKeyRange\n        };\n        const { addons } = options;\n        this._dbSchema = {};\n        this._versions = [];\n        this._storeNames = [];\n        this._allTables = {};\n        this.idbdb = null;\n        this._novip = this;\n        const state = {\n            dbOpenError: null,\n            isBeingOpened: false,\n            onReadyBeingFired: null,\n            openComplete: false,\n            dbReadyResolve: nop,\n            dbReadyPromise: null,\n            cancelOpen: nop,\n            openCanceller: null,\n            autoSchema: true,\n            PR1398_maxLoop: 3\n        };\n        state.dbReadyPromise = new DexiePromise((resolve)=>{\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject)=>{\n            state.cancelOpen = reject;\n        });\n        this._state = state;\n        this.name = name;\n        this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", {\n            ready: [\n                promisableChain,\n                nop\n            ]\n        });\n        this.on.ready.subscribe = override(this.on.ready.subscribe, (subscribe)=>{\n            return (subscriber, bSticky)=>{\n                Dexie$1.vip(()=>{\n                    const state = this._state;\n                    if (state.openComplete) {\n                        if (!state.dbOpenError) DexiePromise.resolve().then(subscriber);\n                        if (bSticky) subscribe(subscriber);\n                    } else if (state.onReadyBeingFired) {\n                        state.onReadyBeingFired.push(subscriber);\n                        if (bSticky) subscribe(subscriber);\n                    } else {\n                        subscribe(subscriber);\n                        const db = this;\n                        if (!bSticky) subscribe(function unsubscribe() {\n                            db.on.ready.unsubscribe(subscriber);\n                            db.on.ready.unsubscribe(unsubscribe);\n                        });\n                    }\n                });\n            };\n        });\n        this.Collection = createCollectionConstructor(this);\n        this.Table = createTableConstructor(this);\n        this.Transaction = createTransactionConstructor(this);\n        this.Version = createVersionConstructor(this);\n        this.WhereClause = createWhereClauseConstructor(this);\n        this.on(\"versionchange\", (ev)=>{\n            if (ev.newVersion > 0) console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);\n            else console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);\n            this.close();\n        });\n        this.on(\"blocked\", (ev)=>{\n            if (!ev.newVersion || ev.newVersion < ev.oldVersion) console.warn(`Dexie.delete('${this.name}') was blocked`);\n            else console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);\n        });\n        this._maxKey = getMaxKey(options.IDBKeyRange);\n        this._createTransaction = (mode, storeNames, dbschema, parentTransaction)=>new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);\n        this._fireOnBlocked = (ev)=>{\n            this.on(\"blocked\").fire(ev);\n            connections.filter((c)=>c.name === this.name && c !== this && !c._state.vcFired).map((c)=>c.on(\"versionchange\").fire(ev));\n        };\n        this.use(virtualIndexMiddleware);\n        this.use(hooksMiddleware);\n        this.use(observabilityMiddleware);\n        this.use(cacheExistingValuesMiddleware);\n        this.vip = Object.create(this, {\n            _vip: {\n                value: true\n            }\n        });\n        addons.forEach((addon)=>addon(this));\n    }\n    version(versionNumber) {\n        if (isNaN(versionNumber) || versionNumber < 0.1) throw new exceptions.Type(`Given version is not a positive number`);\n        versionNumber = Math.round(versionNumber * 10) / 10;\n        if (this.idbdb || this._state.isBeingOpened) throw new exceptions.Schema(\"Cannot add version when database is open\");\n        this.verno = Math.max(this.verno, versionNumber);\n        const versions = this._versions;\n        var versionInstance = versions.filter((v)=>v._cfg.version === versionNumber)[0];\n        if (versionInstance) return versionInstance;\n        versionInstance = new this.Version(versionNumber);\n        versions.push(versionInstance);\n        versions.sort(lowerVersionFirst);\n        versionInstance.stores({});\n        this._state.autoSchema = false;\n        return versionInstance;\n    }\n    _whenReady(fn) {\n        return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise((resolve, reject)=>{\n            if (this._state.openComplete) {\n                return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));\n            }\n            if (!this._state.isBeingOpened) {\n                if (!this._options.autoOpen) {\n                    reject(new exceptions.DatabaseClosed());\n                    return;\n                }\n                this.open().catch(nop);\n            }\n            this._state.dbReadyPromise.then(resolve, reject);\n        }).then(fn);\n    }\n    use({ stack, create, level, name }) {\n        if (name) this.unuse({\n            stack,\n            name\n        });\n        const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n        middlewares.push({\n            stack,\n            create,\n            level: level == null ? 10 : level,\n            name\n        });\n        middlewares.sort((a, b)=>a.level - b.level);\n        return this;\n    }\n    unuse({ stack, name, create }) {\n        if (stack && this._middlewares[stack]) {\n            this._middlewares[stack] = this._middlewares[stack].filter((mw)=>create ? mw.create !== create : name ? mw.name !== name : false);\n        }\n        return this;\n    }\n    open() {\n        return dexieOpen(this);\n    }\n    _close() {\n        const state = this._state;\n        const idx = connections.indexOf(this);\n        if (idx >= 0) connections.splice(idx, 1);\n        if (this.idbdb) {\n            try {\n                this.idbdb.close();\n            } catch (e) {}\n            this._novip.idbdb = null;\n        }\n        state.dbReadyPromise = new DexiePromise((resolve)=>{\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject)=>{\n            state.cancelOpen = reject;\n        });\n    }\n    close() {\n        this._close();\n        const state = this._state;\n        this._options.autoOpen = false;\n        state.dbOpenError = new exceptions.DatabaseClosed();\n        if (state.isBeingOpened) state.cancelOpen(state.dbOpenError);\n    }\n    delete() {\n        const hasArguments = arguments.length > 0;\n        const state = this._state;\n        return new DexiePromise((resolve, reject)=>{\n            const doDelete = ()=>{\n                this.close();\n                var req = this._deps.indexedDB.deleteDatabase(this.name);\n                req.onsuccess = wrap(()=>{\n                    _onDatabaseDeleted(this._deps, this.name);\n                    resolve();\n                });\n                req.onerror = eventRejectHandler(reject);\n                req.onblocked = this._fireOnBlocked;\n            };\n            if (hasArguments) throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n            if (state.isBeingOpened) {\n                state.dbReadyPromise.then(doDelete);\n            } else {\n                doDelete();\n            }\n        });\n    }\n    backendDB() {\n        return this.idbdb;\n    }\n    isOpen() {\n        return this.idbdb !== null;\n    }\n    hasBeenClosed() {\n        const dbOpenError = this._state.dbOpenError;\n        return dbOpenError && dbOpenError.name === \"DatabaseClosed\";\n    }\n    hasFailed() {\n        return this._state.dbOpenError !== null;\n    }\n    dynamicallyOpened() {\n        return this._state.autoSchema;\n    }\n    get tables() {\n        return keys(this._allTables).map((name)=>this._allTables[name]);\n    }\n    transaction() {\n        const args = extractTransactionArgs.apply(this, arguments);\n        return this._transaction.apply(this, args);\n    }\n    _transaction(mode, tables, scopeFunc) {\n        let parentTransaction = PSD.trans;\n        if (!parentTransaction || parentTransaction.db !== this || mode.indexOf(\"!\") !== -1) parentTransaction = null;\n        const onlyIfCompatible = mode.indexOf(\"?\") !== -1;\n        mode = mode.replace(\"!\", \"\").replace(\"?\", \"\");\n        let idbMode, storeNames;\n        try {\n            storeNames = tables.map((table)=>{\n                var storeName = table instanceof this.Table ? table.name : table;\n                if (typeof storeName !== \"string\") throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                return storeName;\n            });\n            if (mode == \"r\" || mode === READONLY) idbMode = READONLY;\n            else if (mode == \"rw\" || mode == READWRITE) idbMode = READWRITE;\n            else throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n            if (parentTransaction) {\n                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                    if (onlyIfCompatible) {\n                        parentTransaction = null;\n                    } else throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                }\n                if (parentTransaction) {\n                    storeNames.forEach((storeName)=>{\n                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                            if (onlyIfCompatible) {\n                                parentTransaction = null;\n                            } else throw new exceptions.SubTransaction(\"Table \" + storeName + \" not included in parent transaction.\");\n                        }\n                    });\n                }\n                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                    parentTransaction = null;\n                }\n            }\n        } catch (e) {\n            return parentTransaction ? parentTransaction._promise(null, (_, reject)=>{\n                reject(e);\n            }) : rejection(e);\n        }\n        const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n        return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, \"lock\") : PSD.trans ? usePSD(PSD.transless, ()=>this._whenReady(enterTransaction)) : this._whenReady(enterTransaction);\n    }\n    table(tableName) {\n        if (!hasOwn(this._allTables, tableName)) {\n            throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);\n        }\n        return this._allTables[tableName];\n    }\n}\nconst symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol ? Symbol.observable : \"@@observable\";\nclass Observable {\n    constructor(subscribe){\n        this._subscribe = subscribe;\n    }\n    subscribe(x, error, complete) {\n        return this._subscribe(!x || typeof x === \"function\" ? {\n            next: x,\n            error,\n            complete\n        } : x);\n    }\n    [symbolObservable]() {\n        return this;\n    }\n}\nfunction extendObservabilitySet(target, newSet) {\n    keys(newSet).forEach((part)=>{\n        const rangeSet = target[part] || (target[part] = new RangeSet());\n        mergeRanges(rangeSet, newSet[part]);\n    });\n    return target;\n}\nfunction liveQuery(querier) {\n    let hasValue = false;\n    let currentValue = undefined;\n    const observable = new Observable((observer)=>{\n        const scopeFuncIsAsync = isAsyncFunction(querier);\n        function execute(subscr) {\n            if (scopeFuncIsAsync) {\n                incrementExpectedAwaits();\n            }\n            const exec = ()=>newScope(querier, {\n                    subscr,\n                    trans: null\n                });\n            const rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();\n            if (scopeFuncIsAsync) {\n                rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n            }\n            return rv;\n        }\n        let closed = false;\n        let accumMuts = {};\n        let currentObs = {};\n        const subscription = {\n            get closed () {\n                return closed;\n            },\n            unsubscribe: ()=>{\n                closed = true;\n                globalEvents.storagemutated.unsubscribe(mutationListener);\n            }\n        };\n        observer.start && observer.start(subscription);\n        let querying = false, startedListening = false;\n        function shouldNotify() {\n            return keys(currentObs).some((key)=>accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));\n        }\n        const mutationListener = (parts)=>{\n            extendObservabilitySet(accumMuts, parts);\n            if (shouldNotify()) {\n                doQuery();\n            }\n        };\n        const doQuery = ()=>{\n            if (querying || closed) return;\n            accumMuts = {};\n            const subscr = {};\n            const ret = execute(subscr);\n            if (!startedListening) {\n                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                startedListening = true;\n            }\n            querying = true;\n            Promise.resolve(ret).then((result)=>{\n                hasValue = true;\n                currentValue = result;\n                querying = false;\n                if (closed) return;\n                if (shouldNotify()) {\n                    doQuery();\n                } else {\n                    accumMuts = {};\n                    currentObs = subscr;\n                    observer.next && observer.next(result);\n                }\n            }, (err)=>{\n                querying = false;\n                hasValue = false;\n                observer.error && observer.error(err);\n                subscription.unsubscribe();\n            });\n        };\n        doQuery();\n        return subscription;\n    });\n    observable.hasValue = ()=>hasValue;\n    observable.getValue = ()=>currentValue;\n    return observable;\n}\nlet domDeps;\ntry {\n    domDeps = {\n        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n    };\n} catch (e) {\n    domDeps = {\n        indexedDB: null,\n        IDBKeyRange: null\n    };\n}\nconst Dexie = Dexie$1;\nprops(Dexie, {\n    ...fullNameExceptions,\n    delete (databaseName) {\n        const db = new Dexie(databaseName, {\n            addons: []\n        });\n        return db.delete();\n    },\n    exists (name) {\n        return new Dexie(name, {\n            addons: []\n        }).open().then((db)=>{\n            db.close();\n            return true;\n        }).catch(\"NoSuchDatabaseError\", ()=>false);\n    },\n    getDatabaseNames (cb) {\n        try {\n            return getDatabaseNames(Dexie.dependencies).then(cb);\n        } catch (_a) {\n            return rejection(new exceptions.MissingAPI());\n        }\n    },\n    defineClass () {\n        function Class(content) {\n            extend(this, content);\n        }\n        return Class;\n    },\n    ignoreTransaction (scopeFunc) {\n        return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();\n    },\n    vip,\n    async: function(generatorFn) {\n        return function() {\n            try {\n                var rv = awaitIterator(generatorFn.apply(this, arguments));\n                if (!rv || typeof rv.then !== \"function\") return DexiePromise.resolve(rv);\n                return rv;\n            } catch (e) {\n                return rejection(e);\n            }\n        };\n    },\n    spawn: function(generatorFn, args, thiz) {\n        try {\n            var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n            if (!rv || typeof rv.then !== \"function\") return DexiePromise.resolve(rv);\n            return rv;\n        } catch (e) {\n            return rejection(e);\n        }\n    },\n    currentTransaction: {\n        get: ()=>PSD.trans || null\n    },\n    waitFor: function(promiseOrFunction, optionalTimeout) {\n        const promise = DexiePromise.resolve(typeof promiseOrFunction === \"function\" ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 60000);\n        return PSD.trans ? PSD.trans.waitFor(promise) : promise;\n    },\n    Promise: DexiePromise,\n    debug: {\n        get: ()=>debug,\n        set: (value)=>{\n            setDebug(value, value === \"dexie\" ? ()=>true : dexieStackFrameFilter);\n        }\n    },\n    derive: derive,\n    extend: extend,\n    props: props,\n    override: override,\n    Events: Events,\n    on: globalEvents,\n    liveQuery,\n    extendObservabilitySet,\n    getByKeyPath: getByKeyPath,\n    setByKeyPath: setByKeyPath,\n    delByKeyPath: delByKeyPath,\n    shallowClone: shallowClone,\n    deepClone: deepClone,\n    getObjectDiff: getObjectDiff,\n    cmp,\n    asap: asap$1,\n    minKey: minKey,\n    addons: [],\n    connections: connections,\n    errnames: errnames,\n    dependencies: domDeps,\n    semVer: DEXIE_VERSION,\n    version: DEXIE_VERSION.split(\".\").map((n)=>parseInt(n)).reduce((p, c, i)=>p + c / Math.pow(10, i * 2))\n});\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\nif (typeof dispatchEvent !== \"undefined\" && typeof addEventListener !== \"undefined\") {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (updatedParts)=>{\n        if (!propagatingLocally) {\n            let event;\n            if (isIEOrEdge) {\n                event = document.createEvent(\"CustomEvent\");\n                event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n            } else {\n                event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                    detail: updatedParts\n                });\n            }\n            propagatingLocally = true;\n            dispatchEvent(event);\n            propagatingLocally = false;\n        }\n    });\n    addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail })=>{\n        if (!propagatingLocally) {\n            propagateLocally(detail);\n        }\n    });\n}\nfunction propagateLocally(updateParts) {\n    let wasMe = propagatingLocally;\n    try {\n        propagatingLocally = true;\n        globalEvents.storagemutated.fire(updateParts);\n    } finally{\n        propagatingLocally = wasMe;\n    }\n}\nlet propagatingLocally = false;\nif (typeof BroadcastChannel !== \"undefined\") {\n    const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n    if (typeof bc.unref === \"function\") {\n        bc.unref();\n    }\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts)=>{\n        if (!propagatingLocally) {\n            bc.postMessage(changedParts);\n        }\n    });\n    bc.onmessage = (ev)=>{\n        if (ev.data) propagateLocally(ev.data);\n    };\n} else if (typeof self !== \"undefined\" && typeof navigator !== \"undefined\") {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts)=>{\n        try {\n            if (!propagatingLocally) {\n                if (typeof localStorage !== \"undefined\") {\n                    localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n                        trig: Math.random(),\n                        changedParts\n                    }));\n                }\n                if (typeof self[\"clients\"] === \"object\") {\n                    [\n                        ...self[\"clients\"].matchAll({\n                            includeUncontrolled: true\n                        })\n                    ].forEach((client)=>client.postMessage({\n                            type: STORAGE_MUTATED_DOM_EVENT_NAME,\n                            changedParts\n                        }));\n                }\n            }\n        } catch (_a) {}\n    });\n    if (typeof addEventListener !== \"undefined\") {\n        addEventListener(\"storage\", (ev)=>{\n            if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n                const data = JSON.parse(ev.newValue);\n                if (data) propagateLocally(data.changedParts);\n            }\n        });\n    }\n    const swContainer = self.document && navigator.serviceWorker;\n    if (swContainer) {\n        swContainer.addEventListener(\"message\", propagateMessageLocally);\n    }\n}\nfunction propagateMessageLocally({ data }) {\n    if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n        propagateLocally(data.changedParts);\n    }\n}\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\n //# sourceMappingURL=dexie.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGV4aWUvZGlzdC9tb2Rlcm4vZGV4aWUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7OztDQVdDLEdBRUQsTUFBTUEsVUFBVSxPQUFPQyxlQUFlLGNBQWNBLGFBQ2hELE9BQU9DLFNBQVMsY0FBY0EsT0FDMUIsTUFBa0IsR0FBY0MsQ0FBTUEsR0FDbENDO0FBRVosTUFBTUMsT0FBT0MsT0FBT0QsSUFBSTtBQUN4QixNQUFNRSxVQUFVQyxNQUFNRCxPQUFPO0FBQzdCLElBQUksT0FBT0UsWUFBWSxlQUFlLENBQUNULFFBQVFTLE9BQU8sRUFBRTtJQUNwRFQsUUFBUVMsT0FBTyxHQUFHQTtBQUN0QjtBQUNBLFNBQVNDLE9BQU9DLEdBQUcsRUFBRUMsU0FBUztJQUMxQixJQUFJLE9BQU9BLGNBQWMsVUFDckIsT0FBT0Q7SUFDWE4sS0FBS08sV0FBV0MsT0FBTyxDQUFDLFNBQVVDLEdBQUc7UUFDakNILEdBQUcsQ0FBQ0csSUFBSSxHQUFHRixTQUFTLENBQUNFLElBQUk7SUFDN0I7SUFDQSxPQUFPSDtBQUNYO0FBQ0EsTUFBTUksV0FBV1QsT0FBT1UsY0FBYztBQUN0QyxNQUFNQyxVQUFVLENBQUMsRUFBRUMsY0FBYztBQUNqQyxTQUFTQyxPQUFPUixHQUFHLEVBQUVTLElBQUk7SUFDckIsT0FBT0gsUUFBUUksSUFBSSxDQUFDVixLQUFLUztBQUM3QjtBQUNBLFNBQVNFLE1BQU1DLEtBQUssRUFBRVgsU0FBUztJQUMzQixJQUFJLE9BQU9BLGNBQWMsWUFDckJBLFlBQVlBLFVBQVVHLFNBQVNRO0lBQ2xDLFFBQU9DLFlBQVksY0FBY25CLE9BQU9tQixRQUFRQyxPQUFPLEVBQUViLFdBQVdDLE9BQU8sQ0FBQ0MsQ0FBQUE7UUFDekVZLFFBQVFILE9BQU9ULEtBQUtGLFNBQVMsQ0FBQ0UsSUFBSTtJQUN0QztBQUNKO0FBQ0EsTUFBTWEsaUJBQWlCckIsT0FBT3FCLGNBQWM7QUFDNUMsU0FBU0QsUUFBUWYsR0FB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LE1BQU1pYyxPQUFPdnRCLEtBQUsrdEIsS0FBSyxDQUFDemIsR0FBRzBiLFFBQVE7Z0JBQ25DLElBQUlULE1BQ0FULGlCQUFpQlMsS0FBS0gsWUFBWTtZQUMxQztRQUNKO0lBQ0o7SUFDQSxNQUFNYSxjQUFjcHJDLEtBQUs4TixRQUFRLElBQUlzTSxVQUFVaXhCLGFBQWE7SUFDNUQsSUFBSUQsYUFBYTtRQUNiQSxZQUFZdkIsZ0JBQWdCLENBQUMsV0FBV3lCO0lBQzVDO0FBQ0o7QUFDQSxTQUFTQSx3QkFBd0IsRUFBRVosSUFBSSxFQUFFO0lBQ3JDLElBQUlBLFFBQVFBLEtBQUtyNUIsSUFBSSxLQUFLb2QsZ0NBQWdDO1FBQ3REd2IsaUJBQWlCUyxLQUFLSCxZQUFZO0lBQ3RDO0FBQ0o7QUFFQTk2QixhQUFhZCxlQUFlLEdBQUd6RDtBQUMvQmpELFNBQVNKLE9BQU8yUztBQUVpRixDQUNqRyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sdW1pcmEvLi9ub2RlX21vZHVsZXMvZGV4aWUvZGlzdC9tb2Rlcm4vZGV4aWUubWpzPzUwZWUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIERleGllLmpzIC0gYSBtaW5pbWFsaXN0aWMgd3JhcHBlciBmb3IgSW5kZXhlZERCXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEJ5IERhdmlkIEZhaGxhbmRlciwgZGF2aWQuZmFobGFuZGVyQGdtYWlsLmNvbVxuICpcbiAqIFZlcnNpb24gMy4yLjcsIFdlZCBNYXIgMjAgMjAyNFxuICpcbiAqIGh0dHBzOi8vZGV4aWUub3JnXG4gKlxuICogQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIEphbnVhcnkgMjAwNCwgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL1xuICovXG4gXG5jb25zdCBfZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6XG4gICAgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6XG4gICAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDpcbiAgICAgICAgICAgIGdsb2JhbDtcblxuY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzO1xuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmICFfZ2xvYmFsLlByb21pc2UpIHtcbiAgICBfZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlO1xufVxuZnVuY3Rpb24gZXh0ZW5kKG9iaiwgZXh0ZW5zaW9uKSB7XG4gICAgaWYgKHR5cGVvZiBleHRlbnNpb24gIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIGtleXMoZXh0ZW5zaW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgb2JqW2tleV0gPSBleHRlbnNpb25ba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xufVxuY29uc3QgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5jb25zdCBfaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24ob2JqLCBwcm9wKSB7XG4gICAgcmV0dXJuIF9oYXNPd24uY2FsbChvYmosIHByb3ApO1xufVxuZnVuY3Rpb24gcHJvcHMocHJvdG8sIGV4dGVuc2lvbikge1xuICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uID09PSAnZnVuY3Rpb24nKVxuICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb24oZ2V0UHJvdG8ocHJvdG8pKTtcbiAgICAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgPyBrZXlzIDogUmVmbGVjdC5vd25LZXlzKShleHRlbnNpb24pLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgc2V0UHJvcChwcm90bywga2V5LCBleHRlbnNpb25ba2V5XSk7XG4gICAgfSk7XG59XG5jb25zdCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbmZ1bmN0aW9uIHNldFByb3Aob2JqLCBwcm9wLCBmdW5jdGlvbk9yR2V0U2V0LCBvcHRpb25zKSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBleHRlbmQoZnVuY3Rpb25PckdldFNldCAmJiBoYXNPd24oZnVuY3Rpb25PckdldFNldCwgXCJnZXRcIikgJiYgdHlwZW9mIGZ1bmN0aW9uT3JHZXRTZXQuZ2V0ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgeyBnZXQ6IGZ1bmN0aW9uT3JHZXRTZXQuZ2V0LCBzZXQ6IGZ1bmN0aW9uT3JHZXRTZXQuc2V0LCBjb25maWd1cmFibGU6IHRydWUgfSA6XG4gICAgICAgIHsgdmFsdWU6IGZ1bmN0aW9uT3JHZXRTZXQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSwgb3B0aW9ucykpO1xufVxuZnVuY3Rpb24gZGVyaXZlKENoaWxkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbTogZnVuY3Rpb24gKFBhcmVudCkge1xuICAgICAgICAgICAgQ2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQYXJlbnQucHJvdG90eXBlKTtcbiAgICAgICAgICAgIHNldFByb3AoQ2hpbGQucHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIENoaWxkKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXh0ZW5kOiBwcm9wcy5iaW5kKG51bGwsIENoaWxkLnByb3RvdHlwZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xufVxuY29uc3QgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmZ1bmN0aW9uIGdldFByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApIHtcbiAgICBjb25zdCBwZCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApO1xuICAgIGxldCBwcm90bztcbiAgICByZXR1cm4gcGQgfHwgKHByb3RvID0gZ2V0UHJvdG8ob2JqKSkgJiYgZ2V0UHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBwcm9wKTtcbn1cbmNvbnN0IF9zbGljZSA9IFtdLnNsaWNlO1xuZnVuY3Rpb24gc2xpY2UoYXJncywgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBfc2xpY2UuY2FsbChhcmdzLCBzdGFydCwgZW5kKTtcbn1cbmZ1bmN0aW9uIG92ZXJyaWRlKG9yaWdGdW5jLCBvdmVycmlkZWRGYWN0b3J5KSB7XG4gICAgcmV0dXJuIG92ZXJyaWRlZEZhY3Rvcnkob3JpZ0Z1bmMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0KGIpIHtcbiAgICBpZiAoIWIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzc2VydGlvbiBGYWlsZWRcIik7XG59XG5mdW5jdGlvbiBhc2FwJDEoZm4pIHtcbiAgICBpZiAoX2dsb2JhbC5zZXRJbW1lZGlhdGUpXG4gICAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgZWxzZVxuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbn1cbmZ1bmN0aW9uIGFycmF5VG9PYmplY3QoYXJyYXksIGV4dHJhY3Rvcikge1xuICAgIHJldHVybiBhcnJheS5yZWR1Y2UoKHJlc3VsdCwgaXRlbSwgaSkgPT4ge1xuICAgICAgICB2YXIgbmFtZUFuZFZhbHVlID0gZXh0cmFjdG9yKGl0ZW0sIGkpO1xuICAgICAgICBpZiAobmFtZUFuZFZhbHVlKVxuICAgICAgICAgICAgcmVzdWx0W25hbWVBbmRWYWx1ZVswXV0gPSBuYW1lQW5kVmFsdWVbMV07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9uZXJyb3IsIGFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgIG9uZXJyb3IgJiYgb25lcnJvcihleCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCkge1xuICAgIGlmICh0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgJiYgaGFzT3duKG9iaiwga2V5UGF0aCkpXG4gICAgICAgIHJldHVybiBvYmpba2V5UGF0aF07XG4gICAgaWYgKCFrZXlQYXRoKVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIGlmICh0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHJ2ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5UGF0aC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBnZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoW2ldKTtcbiAgICAgICAgICAgIHJ2LnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIHZhciBwZXJpb2QgPSBrZXlQYXRoLmluZGV4T2YoJy4nKTtcbiAgICBpZiAocGVyaW9kICE9PSAtMSkge1xuICAgICAgICB2YXIgaW5uZXJPYmogPSBvYmpba2V5UGF0aC5zdWJzdHIoMCwgcGVyaW9kKV07XG4gICAgICAgIHJldHVybiBpbm5lck9iaiA9PSBudWxsID8gdW5kZWZpbmVkIDogZ2V0QnlLZXlQYXRoKGlubmVyT2JqLCBrZXlQYXRoLnN1YnN0cihwZXJpb2QgKyAxKSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCB2YWx1ZSkge1xuICAgIGlmICghb2JqIHx8IGtleVBhdGggPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICgnaXNGcm96ZW4nIGluIE9iamVjdCAmJiBPYmplY3QuaXNGcm96ZW4ob2JqKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycgJiYgJ2xlbmd0aCcgaW4ga2V5UGF0aCkge1xuICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiAnbGVuZ3RoJyBpbiB2YWx1ZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5UGF0aC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGhbaV0sIHZhbHVlW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHBlcmlvZCA9IGtleVBhdGguaW5kZXhPZignLicpO1xuICAgICAgICBpZiAocGVyaW9kICE9PSAtMSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRLZXlQYXRoID0ga2V5UGF0aC5zdWJzdHIoMCwgcGVyaW9kKTtcbiAgICAgICAgICAgIHZhciByZW1haW5pbmdLZXlQYXRoID0ga2V5UGF0aC5zdWJzdHIocGVyaW9kICsgMSk7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nS2V5UGF0aCA9PT0gXCJcIilcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShvYmopICYmICFpc05hTihwYXJzZUludChjdXJyZW50S2V5UGF0aCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnNwbGljZShjdXJyZW50S2V5UGF0aCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpbY3VycmVudEtleVBhdGhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9ialtjdXJyZW50S2V5UGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbm5lck9iaiA9IG9ialtjdXJyZW50S2V5UGF0aF07XG4gICAgICAgICAgICAgICAgaWYgKCFpbm5lck9iaiB8fCAhaGFzT3duKG9iaiwgY3VycmVudEtleVBhdGgpKVxuICAgICAgICAgICAgICAgICAgICBpbm5lck9iaiA9IChvYmpbY3VycmVudEtleVBhdGhdID0ge30pO1xuICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChpbm5lck9iaiwgcmVtYWluaW5nS2V5UGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShvYmopICYmICFpc05hTihwYXJzZUludChrZXlQYXRoKSkpXG4gICAgICAgICAgICAgICAgICAgIG9iai5zcGxpY2Uoa2V5UGF0aCwgMSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleVBhdGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9ialtrZXlQYXRoXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZGVsQnlLZXlQYXRoKG9iaiwga2V5UGF0aCkge1xuICAgIGlmICh0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHVuZGVmaW5lZCk7XG4gICAgZWxzZSBpZiAoJ2xlbmd0aCcgaW4ga2V5UGF0aClcbiAgICAgICAgW10ubWFwLmNhbGwoa2V5UGF0aCwgZnVuY3Rpb24gKGtwKSB7XG4gICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrcCwgdW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG59XG5mdW5jdGlvbiBzaGFsbG93Q2xvbmUob2JqKSB7XG4gICAgdmFyIHJ2ID0ge307XG4gICAgZm9yICh2YXIgbSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc093bihvYmosIG0pKVxuICAgICAgICAgICAgcnZbbV0gPSBvYmpbbV07XG4gICAgfVxuICAgIHJldHVybiBydjtcbn1cbmNvbnN0IGNvbmNhdCA9IFtdLmNvbmNhdDtcbmZ1bmN0aW9uIGZsYXR0ZW4oYSkge1xuICAgIHJldHVybiBjb25jYXQuYXBwbHkoW10sIGEpO1xufVxuY29uc3QgaW50cmluc2ljVHlwZU5hbWVzID0gXCJCaWdVaW50NjRBcnJheSxCaWdJbnQ2NEFycmF5LEFycmF5LEJvb2xlYW4sU3RyaW5nLERhdGUsUmVnRXhwLEJsb2IsRmlsZSxGaWxlTGlzdCxGaWxlU3lzdGVtRmlsZUhhbmRsZSxGaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlLEFycmF5QnVmZmVyLERhdGFWaWV3LFVpbnQ4Q2xhbXBlZEFycmF5LEltYWdlQml0bWFwLEltYWdlRGF0YSxNYXAsU2V0LENyeXB0b0tleVwiXG4gICAgLnNwbGl0KCcsJykuY29uY2F0KGZsYXR0ZW4oWzgsIDE2LCAzMiwgNjRdLm1hcChudW0gPT4gW1wiSW50XCIsIFwiVWludFwiLCBcIkZsb2F0XCJdLm1hcCh0ID0+IHQgKyBudW0gKyBcIkFycmF5XCIpKSkpLmZpbHRlcih0ID0+IF9nbG9iYWxbdF0pO1xuY29uc3QgaW50cmluc2ljVHlwZXMgPSBpbnRyaW5zaWNUeXBlTmFtZXMubWFwKHQgPT4gX2dsb2JhbFt0XSk7XG5hcnJheVRvT2JqZWN0KGludHJpbnNpY1R5cGVOYW1lcywgeCA9PiBbeCwgdHJ1ZV0pO1xubGV0IGNpcmN1bGFyUmVmcyA9IG51bGw7XG5mdW5jdGlvbiBkZWVwQ2xvbmUoYW55KSB7XG4gICAgY2lyY3VsYXJSZWZzID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnICYmIG5ldyBXZWFrTWFwKCk7XG4gICAgY29uc3QgcnYgPSBpbm5lckRlZXBDbG9uZShhbnkpO1xuICAgIGNpcmN1bGFyUmVmcyA9IG51bGw7XG4gICAgcmV0dXJuIHJ2O1xufVxuZnVuY3Rpb24gaW5uZXJEZWVwQ2xvbmUoYW55KSB7XG4gICAgaWYgKCFhbnkgfHwgdHlwZW9mIGFueSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBhbnk7XG4gICAgbGV0IHJ2ID0gY2lyY3VsYXJSZWZzICYmIGNpcmN1bGFyUmVmcy5nZXQoYW55KTtcbiAgICBpZiAocnYpXG4gICAgICAgIHJldHVybiBydjtcbiAgICBpZiAoaXNBcnJheShhbnkpKSB7XG4gICAgICAgIHJ2ID0gW107XG4gICAgICAgIGNpcmN1bGFyUmVmcyAmJiBjaXJjdWxhclJlZnMuc2V0KGFueSwgcnYpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFueS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHJ2LnB1c2goaW5uZXJEZWVwQ2xvbmUoYW55W2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaW50cmluc2ljVHlwZXMuaW5kZXhPZihhbnkuY29uc3RydWN0b3IpID49IDApIHtcbiAgICAgICAgcnYgPSBhbnk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBwcm90byA9IGdldFByb3RvKGFueSk7XG4gICAgICAgIHJ2ID0gcHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUgPyB7fSA6IE9iamVjdC5jcmVhdGUocHJvdG8pO1xuICAgICAgICBjaXJjdWxhclJlZnMgJiYgY2lyY3VsYXJSZWZzLnNldChhbnksIHJ2KTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBhbnkpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24oYW55LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIHJ2W3Byb3BdID0gaW5uZXJEZWVwQ2xvbmUoYW55W3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnY7XG59XG5jb25zdCB7IHRvU3RyaW5nIH0gPSB7fTtcbmZ1bmN0aW9uIHRvU3RyaW5nVGFnKG8pIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG59XG5jb25zdCBpdGVyYXRvclN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID9cbiAgICBTeW1ib2wuaXRlcmF0b3IgOlxuICAgICdAQGl0ZXJhdG9yJztcbmNvbnN0IGdldEl0ZXJhdG9yT2YgPSB0eXBlb2YgaXRlcmF0b3JTeW1ib2wgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBpO1xuICAgIHJldHVybiB4ICE9IG51bGwgJiYgKGkgPSB4W2l0ZXJhdG9yU3ltYm9sXSkgJiYgaS5hcHBseSh4KTtcbn0gOiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuY29uc3QgTk9fQ0hBUl9BUlJBWSA9IHt9O1xuZnVuY3Rpb24gZ2V0QXJyYXlPZihhcnJheUxpa2UpIHtcbiAgICB2YXIgaSwgYSwgeCwgaXQ7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkoYXJyYXlMaWtlKSlcbiAgICAgICAgICAgIHJldHVybiBhcnJheUxpa2Uuc2xpY2UoKTtcbiAgICAgICAgaWYgKHRoaXMgPT09IE5PX0NIQVJfQVJSQVkgJiYgdHlwZW9mIGFycmF5TGlrZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gW2FycmF5TGlrZV07XG4gICAgICAgIGlmICgoaXQgPSBnZXRJdGVyYXRvck9mKGFycmF5TGlrZSkpKSB7XG4gICAgICAgICAgICBhID0gW107XG4gICAgICAgICAgICB3aGlsZSAoKHggPSBpdC5uZXh0KCkpLCAheC5kb25lKVxuICAgICAgICAgICAgICAgIGEucHVzaCh4LnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJheUxpa2UgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBbYXJyYXlMaWtlXTtcbiAgICAgICAgaSA9IGFycmF5TGlrZS5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGEgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgIGFbaV0gPSBhcnJheUxpa2VbaV07XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2FycmF5TGlrZV07XG4gICAgfVxuICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGEgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgYVtpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gYTtcbn1cbmNvbnN0IGlzQXN5bmNGdW5jdGlvbiA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnXG4gICAgPyAoZm4pID0+IGZuW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdBc3luY0Z1bmN0aW9uJ1xuICAgIDogKCkgPT4gZmFsc2U7XG5cbnZhciBkZWJ1ZyA9IHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvXihodHRwfGh0dHBzKTpcXC9cXC8obG9jYWxob3N0fDEyN1xcLjBcXC4wXFwuMSkvLnRlc3QobG9jYXRpb24uaHJlZik7XG5mdW5jdGlvbiBzZXREZWJ1Zyh2YWx1ZSwgZmlsdGVyKSB7XG4gICAgZGVidWcgPSB2YWx1ZTtcbiAgICBsaWJyYXJ5RmlsdGVyID0gZmlsdGVyO1xufVxudmFyIGxpYnJhcnlGaWx0ZXIgPSAoKSA9PiB0cnVlO1xuY29uc3QgTkVFRFNfVEhST1dfRk9SX1NUQUNLID0gIW5ldyBFcnJvcihcIlwiKS5zdGFjaztcbmZ1bmN0aW9uIGdldEVycm9yV2l0aFN0YWNrKCkge1xuICAgIGlmIChORUVEU19USFJPV19GT1JfU1RBQ0spXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBnZXRFcnJvcldpdGhTdGFjay5hcmd1bWVudHM7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCk7XG59XG5mdW5jdGlvbiBwcmV0dHlTdGFjayhleGNlcHRpb24sIG51bUlnbm9yZWRGcmFtZXMpIHtcbiAgICB2YXIgc3RhY2sgPSBleGNlcHRpb24uc3RhY2s7XG4gICAgaWYgKCFzdGFjaylcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgbnVtSWdub3JlZEZyYW1lcyA9IChudW1JZ25vcmVkRnJhbWVzIHx8IDApO1xuICAgIGlmIChzdGFjay5pbmRleE9mKGV4Y2VwdGlvbi5uYW1lKSA9PT0gMClcbiAgICAgICAgbnVtSWdub3JlZEZyYW1lcyArPSAoZXhjZXB0aW9uLm5hbWUgKyBleGNlcHRpb24ubWVzc2FnZSkuc3BsaXQoJ1xcbicpLmxlbmd0aDtcbiAgICByZXR1cm4gc3RhY2suc3BsaXQoJ1xcbicpXG4gICAgICAgIC5zbGljZShudW1JZ25vcmVkRnJhbWVzKVxuICAgICAgICAuZmlsdGVyKGxpYnJhcnlGaWx0ZXIpXG4gICAgICAgIC5tYXAoZnJhbWUgPT4gXCJcXG5cIiArIGZyYW1lKVxuICAgICAgICAuam9pbignJyk7XG59XG5cbnZhciBkZXhpZUVycm9yTmFtZXMgPSBbXG4gICAgJ01vZGlmeScsXG4gICAgJ0J1bGsnLFxuICAgICdPcGVuRmFpbGVkJyxcbiAgICAnVmVyc2lvbkNoYW5nZScsXG4gICAgJ1NjaGVtYScsXG4gICAgJ1VwZ3JhZGUnLFxuICAgICdJbnZhbGlkVGFibGUnLFxuICAgICdNaXNzaW5nQVBJJyxcbiAgICAnTm9TdWNoRGF0YWJhc2UnLFxuICAgICdJbnZhbGlkQXJndW1lbnQnLFxuICAgICdTdWJUcmFuc2FjdGlvbicsXG4gICAgJ1Vuc3VwcG9ydGVkJyxcbiAgICAnSW50ZXJuYWwnLFxuICAgICdEYXRhYmFzZUNsb3NlZCcsXG4gICAgJ1ByZW1hdHVyZUNvbW1pdCcsXG4gICAgJ0ZvcmVpZ25Bd2FpdCdcbl07XG52YXIgaWRiRG9tRXJyb3JOYW1lcyA9IFtcbiAgICAnVW5rbm93bicsXG4gICAgJ0NvbnN0cmFpbnQnLFxuICAgICdEYXRhJyxcbiAgICAnVHJhbnNhY3Rpb25JbmFjdGl2ZScsXG4gICAgJ1JlYWRPbmx5JyxcbiAgICAnVmVyc2lvbicsXG4gICAgJ05vdEZvdW5kJyxcbiAgICAnSW52YWxpZFN0YXRlJyxcbiAgICAnSW52YWxpZEFjY2VzcycsXG4gICAgJ0Fib3J0JyxcbiAgICAnVGltZW91dCcsXG4gICAgJ1F1b3RhRXhjZWVkZWQnLFxuICAgICdTeW50YXgnLFxuICAgICdEYXRhQ2xvbmUnXG5dO1xudmFyIGVycm9yTGlzdCA9IGRleGllRXJyb3JOYW1lcy5jb25jYXQoaWRiRG9tRXJyb3JOYW1lcyk7XG52YXIgZGVmYXVsdFRleHRzID0ge1xuICAgIFZlcnNpb25DaGFuZ2VkOiBcIkRhdGFiYXNlIHZlcnNpb24gY2hhbmdlZCBieSBvdGhlciBkYXRhYmFzZSBjb25uZWN0aW9uXCIsXG4gICAgRGF0YWJhc2VDbG9zZWQ6IFwiRGF0YWJhc2UgaGFzIGJlZW4gY2xvc2VkXCIsXG4gICAgQWJvcnQ6IFwiVHJhbnNhY3Rpb24gYWJvcnRlZFwiLFxuICAgIFRyYW5zYWN0aW9uSW5hY3RpdmU6IFwiVHJhbnNhY3Rpb24gaGFzIGFscmVhZHkgY29tcGxldGVkIG9yIGZhaWxlZFwiLFxuICAgIE1pc3NpbmdBUEk6IFwiSW5kZXhlZERCIEFQSSBtaXNzaW5nLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly90aW55dXJsLmNvbS95MnV1dnNrYlwiXG59O1xuZnVuY3Rpb24gRGV4aWVFcnJvcihuYW1lLCBtc2cpIHtcbiAgICB0aGlzLl9lID0gZ2V0RXJyb3JXaXRoU3RhY2soKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbn1cbmRlcml2ZShEZXhpZUVycm9yKS5mcm9tKEVycm9yKS5leHRlbmQoe1xuICAgIHN0YWNrOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWNrIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuX3N0YWNrID0gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlICsgcHJldHR5U3RhY2sodGhpcy5fZSwgMikpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlOyB9XG59KTtcbmZ1bmN0aW9uIGdldE11bHRpRXJyb3JNZXNzYWdlKG1zZywgZmFpbHVyZXMpIHtcbiAgICByZXR1cm4gbXNnICsgXCIuIEVycm9yczogXCIgKyBPYmplY3Qua2V5cyhmYWlsdXJlcylcbiAgICAgICAgLm1hcChrZXkgPT4gZmFpbHVyZXNba2V5XS50b1N0cmluZygpKVxuICAgICAgICAuZmlsdGVyKCh2LCBpLCBzKSA9PiBzLmluZGV4T2YodikgPT09IGkpXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbn1cbmZ1bmN0aW9uIE1vZGlmeUVycm9yKG1zZywgZmFpbHVyZXMsIHN1Y2Nlc3NDb3VudCwgZmFpbGVkS2V5cykge1xuICAgIHRoaXMuX2UgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgIHRoaXMuZmFpbHVyZXMgPSBmYWlsdXJlcztcbiAgICB0aGlzLmZhaWxlZEtleXMgPSBmYWlsZWRLZXlzO1xuICAgIHRoaXMuc3VjY2Vzc0NvdW50ID0gc3VjY2Vzc0NvdW50O1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE11bHRpRXJyb3JNZXNzYWdlKG1zZywgZmFpbHVyZXMpO1xufVxuZGVyaXZlKE1vZGlmeUVycm9yKS5mcm9tKERleGllRXJyb3IpO1xuZnVuY3Rpb24gQnVsa0Vycm9yKG1zZywgZmFpbHVyZXMpIHtcbiAgICB0aGlzLl9lID0gZ2V0RXJyb3JXaXRoU3RhY2soKTtcbiAgICB0aGlzLm5hbWUgPSBcIkJ1bGtFcnJvclwiO1xuICAgIHRoaXMuZmFpbHVyZXMgPSBPYmplY3Qua2V5cyhmYWlsdXJlcykubWFwKHBvcyA9PiBmYWlsdXJlc1twb3NdKTtcbiAgICB0aGlzLmZhaWx1cmVzQnlQb3MgPSBmYWlsdXJlcztcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNdWx0aUVycm9yTWVzc2FnZShtc2csIGZhaWx1cmVzKTtcbn1cbmRlcml2ZShCdWxrRXJyb3IpLmZyb20oRGV4aWVFcnJvcik7XG52YXIgZXJybmFtZXMgPSBlcnJvckxpc3QucmVkdWNlKChvYmosIG5hbWUpID0+IChvYmpbbmFtZV0gPSBuYW1lICsgXCJFcnJvclwiLCBvYmopLCB7fSk7XG5jb25zdCBCYXNlRXhjZXB0aW9uID0gRGV4aWVFcnJvcjtcbnZhciBleGNlcHRpb25zID0gZXJyb3JMaXN0LnJlZHVjZSgob2JqLCBuYW1lKSA9PiB7XG4gICAgdmFyIGZ1bGxOYW1lID0gbmFtZSArIFwiRXJyb3JcIjtcbiAgICBmdW5jdGlvbiBEZXhpZUVycm9yKG1zZ09ySW5uZXIsIGlubmVyKSB7XG4gICAgICAgIHRoaXMuX2UgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgICAgICB0aGlzLm5hbWUgPSBmdWxsTmFtZTtcbiAgICAgICAgaWYgKCFtc2dPcklubmVyKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBkZWZhdWx0VGV4dHNbbmFtZV0gfHwgZnVsbE5hbWU7XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbXNnT3JJbm5lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGAke21zZ09ySW5uZXJ9JHshaW5uZXIgPyAnJyA6ICdcXG4gJyArIGlubmVyfWA7XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gaW5uZXIgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbXNnT3JJbm5lciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGAke21zZ09ySW5uZXIubmFtZX0gJHttc2dPcklubmVyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBtc2dPcklubmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlcml2ZShEZXhpZUVycm9yKS5mcm9tKEJhc2VFeGNlcHRpb24pO1xuICAgIG9ialtuYW1lXSA9IERleGllRXJyb3I7XG4gICAgcmV0dXJuIG9iajtcbn0sIHt9KTtcbmV4Y2VwdGlvbnMuU3ludGF4ID0gU3ludGF4RXJyb3I7XG5leGNlcHRpb25zLlR5cGUgPSBUeXBlRXJyb3I7XG5leGNlcHRpb25zLlJhbmdlID0gUmFuZ2VFcnJvcjtcbnZhciBleGNlcHRpb25NYXAgPSBpZGJEb21FcnJvck5hbWVzLnJlZHVjZSgob2JqLCBuYW1lKSA9PiB7XG4gICAgb2JqW25hbWUgKyBcIkVycm9yXCJdID0gZXhjZXB0aW9uc1tuYW1lXTtcbiAgICByZXR1cm4gb2JqO1xufSwge30pO1xuZnVuY3Rpb24gbWFwRXJyb3IoZG9tRXJyb3IsIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWRvbUVycm9yIHx8IGRvbUVycm9yIGluc3RhbmNlb2YgRGV4aWVFcnJvciB8fCBkb21FcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciB8fCBkb21FcnJvciBpbnN0YW5jZW9mIFN5bnRheEVycm9yIHx8ICFkb21FcnJvci5uYW1lIHx8ICFleGNlcHRpb25NYXBbZG9tRXJyb3IubmFtZV0pXG4gICAgICAgIHJldHVybiBkb21FcnJvcjtcbiAgICB2YXIgcnYgPSBuZXcgZXhjZXB0aW9uTWFwW2RvbUVycm9yLm5hbWVdKG1lc3NhZ2UgfHwgZG9tRXJyb3IubWVzc2FnZSwgZG9tRXJyb3IpO1xuICAgIGlmIChcInN0YWNrXCIgaW4gZG9tRXJyb3IpIHtcbiAgICAgICAgc2V0UHJvcChydiwgXCJzdGFja1wiLCB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlubmVyLnN0YWNrO1xuICAgICAgICAgICAgfSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xufVxudmFyIGZ1bGxOYW1lRXhjZXB0aW9ucyA9IGVycm9yTGlzdC5yZWR1Y2UoKG9iaiwgbmFtZSkgPT4ge1xuICAgIGlmIChbXCJTeW50YXhcIiwgXCJUeXBlXCIsIFwiUmFuZ2VcIl0uaW5kZXhPZihuYW1lKSA9PT0gLTEpXG4gICAgICAgIG9ialtuYW1lICsgXCJFcnJvclwiXSA9IGV4Y2VwdGlvbnNbbmFtZV07XG4gICAgcmV0dXJuIG9iajtcbn0sIHt9KTtcbmZ1bGxOYW1lRXhjZXB0aW9ucy5Nb2RpZnlFcnJvciA9IE1vZGlmeUVycm9yO1xuZnVsbE5hbWVFeGNlcHRpb25zLkRleGllRXJyb3IgPSBEZXhpZUVycm9yO1xuZnVsbE5hbWVFeGNlcHRpb25zLkJ1bGtFcnJvciA9IEJ1bGtFcnJvcjtcblxuZnVuY3Rpb24gbm9wKCkgeyB9XG5mdW5jdGlvbiBtaXJyb3IodmFsKSB7IHJldHVybiB2YWw7IH1cbmZ1bmN0aW9uIHB1cmVGdW5jdGlvbkNoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PSBudWxsIHx8IGYxID09PSBtaXJyb3IpXG4gICAgICAgIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gZjIoZjEodmFsKSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNhbGxCb3RoKG9uMSwgb24yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb24xLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIG9uMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5mdW5jdGlvbiBob29rQ3JlYXRpbmdDaGFpbihmMSwgZjIpIHtcbiAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0gPSByZXM7XG4gICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyxcbiAgICAgICAgb25lcnJvciA9IHRoaXMub25lcnJvcjtcbiAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSBudWxsO1xuICAgICAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICB2YXIgcmVzMiA9IGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChvbnN1Y2Nlc3MpXG4gICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzID8gY2FsbEJvdGgob25zdWNjZXNzLCB0aGlzLm9uc3VjY2VzcykgOiBvbnN1Y2Nlc3M7XG4gICAgICAgIGlmIChvbmVycm9yKVxuICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG4gICAgICAgIHJldHVybiByZXMyICE9PSB1bmRlZmluZWQgPyByZXMyIDogcmVzO1xuICAgIH07XG59XG5mdW5jdGlvbiBob29rRGVsZXRpbmdDaGFpbihmMSwgZjIpIHtcbiAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyxcbiAgICAgICAgb25lcnJvciA9IHRoaXMub25lcnJvcjtcbiAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAob25zdWNjZXNzKVxuICAgICAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyA/IGNhbGxCb3RoKG9uc3VjY2VzcywgdGhpcy5vbnN1Y2Nlc3MpIDogb25zdWNjZXNzO1xuICAgICAgICBpZiAob25lcnJvcilcbiAgICAgICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvciA/IGNhbGxCb3RoKG9uZXJyb3IsIHRoaXMub25lcnJvcikgOiBvbmVycm9yO1xuICAgIH07XG59XG5mdW5jdGlvbiBob29rVXBkYXRpbmdDaGFpbihmMSwgZjIpIHtcbiAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kaWZpY2F0aW9ucykge1xuICAgICAgICB2YXIgcmVzID0gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgZXh0ZW5kKG1vZGlmaWNhdGlvbnMsIHJlcyk7XG4gICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyxcbiAgICAgICAgb25lcnJvciA9IHRoaXMub25lcnJvcjtcbiAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSBudWxsO1xuICAgICAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICB2YXIgcmVzMiA9IGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChvbnN1Y2Nlc3MpXG4gICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzID8gY2FsbEJvdGgob25zdWNjZXNzLCB0aGlzLm9uc3VjY2VzcykgOiBvbnN1Y2Nlc3M7XG4gICAgICAgIGlmIChvbmVycm9yKVxuICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG4gICAgICAgIHJldHVybiByZXMgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAocmVzMiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVzMikgOlxuICAgICAgICAgICAgKGV4dGVuZChyZXMsIHJlczIpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcmV2ZXJzZVN0b3BwYWJsZUV2ZW50Q2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09PSBub3ApXG4gICAgICAgIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5mdW5jdGlvbiBwcm9taXNhYmxlQ2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09PSBub3ApXG4gICAgICAgIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzID0gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciB0aGl6ID0gdGhpcywgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICByZXR1cm4gcmVzLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmMi5hcHBseSh0aGl6LCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbnZhciBJTlRFUk5BTCA9IHt9O1xuY29uc3QgTE9OR19TVEFDS1NfQ0xJUF9MSU1JVCA9IDEwMCxcbk1BWF9MT05HX1NUQUNLUyA9IDIwLCBaT05FX0VDSE9fTElNSVQgPSAxMDAsIFtyZXNvbHZlZE5hdGl2ZVByb21pc2UsIG5hdGl2ZVByb21pc2VQcm90bywgcmVzb2x2ZWRHbG9iYWxQcm9taXNlXSA9IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/XG4gICAgW10gOlxuICAgICgoKSA9PiB7XG4gICAgICAgIGxldCBnbG9iYWxQID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJyB8fCAhY3J5cHRvLnN1YnRsZSlcbiAgICAgICAgICAgIHJldHVybiBbZ2xvYmFsUCwgZ2V0UHJvdG8oZ2xvYmFsUCksIGdsb2JhbFBdO1xuICAgICAgICBjb25zdCBuYXRpdmVQID0gY3J5cHRvLnN1YnRsZS5kaWdlc3QoXCJTSEEtNTEyXCIsIG5ldyBVaW50OEFycmF5KFswXSkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmF0aXZlUCxcbiAgICAgICAgICAgIGdldFByb3RvKG5hdGl2ZVApLFxuICAgICAgICAgICAgZ2xvYmFsUFxuICAgICAgICBdO1xuICAgIH0pKCksIG5hdGl2ZVByb21pc2VUaGVuID0gbmF0aXZlUHJvbWlzZVByb3RvICYmIG5hdGl2ZVByb21pc2VQcm90by50aGVuO1xuY29uc3QgTmF0aXZlUHJvbWlzZSA9IHJlc29sdmVkTmF0aXZlUHJvbWlzZSAmJiByZXNvbHZlZE5hdGl2ZVByb21pc2UuY29uc3RydWN0b3I7XG5jb25zdCBwYXRjaEdsb2JhbFByb21pc2UgPSAhIXJlc29sdmVkR2xvYmFsUHJvbWlzZTtcbnZhciBzdGFja19iZWluZ19nZW5lcmF0ZWQgPSBmYWxzZTtcbnZhciBzY2hlZHVsZVBoeXNpY2FsVGljayA9IHJlc29sdmVkR2xvYmFsUHJvbWlzZSA/XG4gICAgKCkgPT4geyByZXNvbHZlZEdsb2JhbFByb21pc2UudGhlbihwaHlzaWNhbFRpY2spOyB9XG4gICAgOlxuICAgICAgICBfZ2xvYmFsLnNldEltbWVkaWF0ZSA/XG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUuYmluZChudWxsLCBwaHlzaWNhbFRpY2spIDpcbiAgICAgICAgICAgIF9nbG9iYWwuTXV0YXRpb25PYnNlcnZlciA/XG4gICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGlkZGVuRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgKG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBoeXNpY2FsVGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuRGl2ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSkpLm9ic2VydmUoaGlkZGVuRGl2LCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbkRpdi5zZXRBdHRyaWJ1dGUoJ2knLCAnMScpO1xuICAgICAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgICAgICgpID0+IHsgc2V0VGltZW91dChwaHlzaWNhbFRpY2ssIDApOyB9O1xudmFyIGFzYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICBtaWNyb3RpY2tRdWV1ZS5wdXNoKFtjYWxsYmFjaywgYXJnc10pO1xuICAgIGlmIChuZWVkc05ld1BoeXNpY2FsVGljaykge1xuICAgICAgICBzY2hlZHVsZVBoeXNpY2FsVGljaygpO1xuICAgICAgICBuZWVkc05ld1BoeXNpY2FsVGljayA9IGZhbHNlO1xuICAgIH1cbn07XG52YXIgaXNPdXRzaWRlTWljcm9UaWNrID0gdHJ1ZSxcbm5lZWRzTmV3UGh5c2ljYWxUaWNrID0gdHJ1ZSxcbnVuaGFuZGxlZEVycm9ycyA9IFtdLFxucmVqZWN0aW5nRXJyb3JzID0gW10sXG5jdXJyZW50RnVsZmlsbGVyID0gbnVsbCwgcmVqZWN0aW9uTWFwcGVyID0gbWlycm9yO1xudmFyIGdsb2JhbFBTRCA9IHtcbiAgICBpZDogJ2dsb2JhbCcsXG4gICAgZ2xvYmFsOiB0cnVlLFxuICAgIHJlZjogMCxcbiAgICB1bmhhbmRsZWRzOiBbXSxcbiAgICBvbnVuaGFuZGxlZDogZ2xvYmFsRXJyb3IsXG4gICAgcGdwOiBmYWxzZSxcbiAgICBlbnY6IHt9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5oYW5kbGVkcy5mb3JFYWNoKHVoID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsRXJyb3IodWhbMF0sIHVoWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbnZhciBQU0QgPSBnbG9iYWxQU0Q7XG52YXIgbWljcm90aWNrUXVldWUgPSBbXTtcbnZhciBudW1TY2hlZHVsZWRDYWxscyA9IDA7XG52YXIgdGlja0ZpbmFsaXplcnMgPSBbXTtcbmZ1bmN0aW9uIERleGllUHJvbWlzZShmbikge1xuICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMub251bmNhdGNoZWQgPSBub3A7XG4gICAgdGhpcy5fbGliID0gZmFsc2U7XG4gICAgdmFyIHBzZCA9ICh0aGlzLl9QU0QgPSBQU0QpO1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICB0aGlzLl9zdGFja0hvbGRlciA9IGdldEVycm9yV2l0aFN0YWNrKCk7XG4gICAgICAgIHRoaXMuX3ByZXYgPSBudWxsO1xuICAgICAgICB0aGlzLl9udW1QcmV2ID0gMDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoZm4gIT09IElOVEVSTkFMKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gYXJndW1lbnRzWzJdO1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgaGFuZGxlUmVqZWN0aW9uKHRoaXMsIHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgICsrcHNkLnJlZjtcbiAgICBleGVjdXRlUHJvbWlzZVRhc2sodGhpcywgZm4pO1xufVxuY29uc3QgdGhlblByb3AgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwc2QgPSBQU0QsIG1pY3JvVGFza0lkID0gdG90YWxFY2hvZXM7XG4gICAgICAgIGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgIHZhciBwb3NzaWJsZUF3YWl0ID0gIXBzZC5nbG9iYWwgJiYgKHBzZCAhPT0gUFNEIHx8IG1pY3JvVGFza0lkICE9PSB0b3RhbEVjaG9lcyk7XG4gICAgICAgICAgICBjb25zdCBjbGVhbnVwID0gcG9zc2libGVBd2FpdCAmJiAhZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgIHZhciBydiA9IG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIodGhpcywgbmV3IExpc3RlbmVyKG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25GdWxmaWxsZWQsIHBzZCwgcG9zc2libGVBd2FpdCwgY2xlYW51cCksIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25SZWplY3RlZCwgcHNkLCBwb3NzaWJsZUF3YWl0LCBjbGVhbnVwKSwgcmVzb2x2ZSwgcmVqZWN0LCBwc2QpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVidWcgJiYgbGlua1RvUHJldmlvdXNQcm9taXNlKHJ2LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgICAgICB0aGVuLnByb3RvdHlwZSA9IElOVEVSTkFMO1xuICAgICAgICByZXR1cm4gdGhlbjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHNldFByb3AodGhpcywgJ3RoZW4nLCB2YWx1ZSAmJiB2YWx1ZS5wcm90b3R5cGUgPT09IElOVEVSTkFMID9cbiAgICAgICAgICAgIHRoZW5Qcm9wIDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiB0aGVuUHJvcC5zZXRcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5wcm9wcyhEZXhpZVByb21pc2UucHJvdG90eXBlLCB7XG4gICAgdGhlbjogdGhlblByb3AsXG4gICAgX3RoZW46IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICBwcm9wYWdhdGVUb0xpc3RlbmVyKHRoaXMsIG5ldyBMaXN0ZW5lcihudWxsLCBudWxsLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgUFNEKSk7XG4gICAgfSxcbiAgICBjYXRjaDogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xuICAgICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXSwgaGFuZGxlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdGhpcy50aGVuKG51bGwsIGVyciA9PlxuICAgICAgICBlcnIgaW5zdGFuY2VvZiB0eXBlID8gaGFuZGxlcihlcnIpIDogUHJvbWlzZVJlamVjdChlcnIpKVxuICAgICAgICAgICAgOiB0aGlzLnRoZW4obnVsbCwgZXJyID0+XG4gICAgICAgICAgICBlcnIgJiYgZXJyLm5hbWUgPT09IHR5cGUgPyBoYW5kbGVyKGVycikgOiBQcm9taXNlUmVqZWN0KGVycikpO1xuICAgIH0sXG4gICAgZmluYWxseTogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIG9uRmluYWxseSgpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgb25GaW5hbGx5KCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHN0YWNrOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YWNrKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFjaztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tzID0gZ2V0U3RhY2sodGhpcywgW10sIE1BWF9MT05HX1NUQUNLUyk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrID0gc3RhY2tzLmpvaW4oXCJcXG5Gcm9tIHByZXZpb3VzOiBcIik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFjayA9IHN0YWNrO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHN0YWNrX2JlaW5nX2dlbmVyYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICB0aW1lb3V0OiBmdW5jdGlvbiAobXMsIG1zZykge1xuICAgICAgICByZXR1cm4gbXMgPCBJbmZpbml0eSA/XG4gICAgICAgICAgICBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IGV4Y2VwdGlvbnMuVGltZW91dChtc2cpKSwgbXMpO1xuICAgICAgICAgICAgICAgIHRoaXMudGhlbihyZXNvbHZlLCByZWplY3QpLmZpbmFsbHkoY2xlYXJUaW1lb3V0LmJpbmQobnVsbCwgaGFuZGxlKSk7XG4gICAgICAgICAgICB9KSA6IHRoaXM7XG4gICAgfVxufSk7XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKVxuICAgIHNldFByb3AoRGV4aWVQcm9taXNlLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCAnRGV4aWUuUHJvbWlzZScpO1xuZ2xvYmFsUFNELmVudiA9IHNuYXBTaG90KCk7XG5mdW5jdGlvbiBMaXN0ZW5lcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzb2x2ZSwgcmVqZWN0LCB6b25lKSB7XG4gICAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbDtcbiAgICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgdGhpcy5wc2QgPSB6b25lO1xufVxucHJvcHMoRGV4aWVQcm9taXNlLCB7XG4gICAgYWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIC5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKChhLCBpKSA9PiBEZXhpZVByb21pc2UucmVzb2x2ZShhKS50aGVuKHggPT4ge1xuICAgICAgICAgICAgICAgIHZhbHVlc1tpXSA9IHg7XG4gICAgICAgICAgICAgICAgaWYgKCEtLXJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICAgICAgfSwgcmVqZWN0KSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgcmVzb2x2ZTogdmFsdWUgPT4ge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEZXhpZVByb21pc2UpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJ2ID0gbmV3IERleGllUHJvbWlzZShJTlRFUk5BTCwgdHJ1ZSwgdmFsdWUpO1xuICAgICAgICBsaW5rVG9QcmV2aW91c1Byb21pc2UocnYsIGN1cnJlbnRGdWxmaWxsZXIpO1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgfSxcbiAgICByZWplY3Q6IFByb21pc2VSZWplY3QsXG4gICAgcmFjZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB2YWx1ZXMubWFwKHZhbHVlID0+IERleGllUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKHJlc29sdmUsIHJlamVjdCkpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFBTRDoge1xuICAgICAgICBnZXQ6ICgpID0+IFBTRCxcbiAgICAgICAgc2V0OiB2YWx1ZSA9PiBQU0QgPSB2YWx1ZVxuICAgIH0sXG4gICAgdG90YWxFY2hvZXM6IHsgZ2V0OiAoKSA9PiB0b3RhbEVjaG9lcyB9LFxuICAgIG5ld1BTRDogbmV3U2NvcGUsXG4gICAgdXNlUFNEOiB1c2VQU0QsXG4gICAgc2NoZWR1bGVyOiB7XG4gICAgICAgIGdldDogKCkgPT4gYXNhcCxcbiAgICAgICAgc2V0OiB2YWx1ZSA9PiB7IGFzYXAgPSB2YWx1ZTsgfVxuICAgIH0sXG4gICAgcmVqZWN0aW9uTWFwcGVyOiB7XG4gICAgICAgIGdldDogKCkgPT4gcmVqZWN0aW9uTWFwcGVyLFxuICAgICAgICBzZXQ6IHZhbHVlID0+IHsgcmVqZWN0aW9uTWFwcGVyID0gdmFsdWU7IH1cbiAgICB9LFxuICAgIGZvbGxvdzogKGZuLCB6b25lUHJvcHMpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgcHNkID0gUFNEO1xuICAgICAgICAgICAgICAgIHBzZC51bmhhbmRsZWRzID0gW107XG4gICAgICAgICAgICAgICAgcHNkLm9udW5oYW5kbGVkID0gcmVqZWN0O1xuICAgICAgICAgICAgICAgIHBzZC5maW5hbGl6ZSA9IGNhbGxCb3RoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVuX2F0X2VuZF9vZl90aGlzX29yX25leHRfcGh5c2ljYWxfdGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVuaGFuZGxlZHMubGVuZ3RoID09PSAwID8gcmVzb2x2ZSgpIDogcmVqZWN0KHRoaXMudW5oYW5kbGVkc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIHBzZC5maW5hbGl6ZSk7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH0sIHpvbmVQcm9wcywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5pZiAoTmF0aXZlUHJvbWlzZSkge1xuICAgIGlmIChOYXRpdmVQcm9taXNlLmFsbFNldHRsZWQpXG4gICAgICAgIHNldFByb3AoRGV4aWVQcm9taXNlLCBcImFsbFNldHRsZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgcG9zc2libGVQcm9taXNlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZVByb21pc2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICAgICAgbGV0IHJlbWFpbmluZyA9IHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkocmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICBwb3NzaWJsZVByb21pc2VzLmZvckVhY2goKHAsIGkpID0+IERleGllUHJvbWlzZS5yZXNvbHZlKHApLnRoZW4odmFsdWUgPT4gcmVzdWx0c1tpXSA9IHsgc3RhdHVzOiBcImZ1bGZpbGxlZFwiLCB2YWx1ZSB9LCByZWFzb24gPT4gcmVzdWx0c1tpXSA9IHsgc3RhdHVzOiBcInJlamVjdGVkXCIsIHJlYXNvbiB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHJlc3VsdHMpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgaWYgKE5hdGl2ZVByb21pc2UuYW55ICYmIHR5cGVvZiBBZ2dyZWdhdGVFcnJvciAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHNldFByb3AoRGV4aWVQcm9taXNlLCBcImFueVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwb3NzaWJsZVByb21pc2VzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZVByb21pc2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBBZ2dyZWdhdGVFcnJvcihbXSkpO1xuICAgICAgICAgICAgICAgIGxldCByZW1haW5pbmcgPSBwb3NzaWJsZVByb21pc2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG5ldyBBcnJheShyZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgIHBvc3NpYmxlUHJvbWlzZXMuZm9yRWFjaCgocCwgaSkgPT4gRGV4aWVQcm9taXNlLnJlc29sdmUocCkudGhlbih2YWx1ZSA9PiByZXNvbHZlKHZhbHVlKSwgZmFpbHVyZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmVzW2ldID0gZmFpbHVyZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEtLXJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQWdncmVnYXRlRXJyb3IoZmFpbHVyZXMpKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG59XG5mdW5jdGlvbiBleGVjdXRlUHJvbWlzZVRhc2socHJvbWlzZSwgZm4pIHtcbiAgICB0cnkge1xuICAgICAgICBmbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBwcm9taXNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuJyk7XG4gICAgICAgICAgICB2YXIgc2hvdWxkRXhlY3V0ZVRpY2sgPSBwcm9taXNlLl9saWIgJiYgYmVnaW5NaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZXhlY3V0ZVByb21pc2VUYXNrKHByb21pc2UsIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBEZXhpZVByb21pc2UgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuX3RoZW4ocmVzb2x2ZSwgcmVqZWN0KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9zdGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBwcm9wYWdhdGVBbGxMaXN0ZW5lcnMocHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkRXhlY3V0ZVRpY2spXG4gICAgICAgICAgICAgICAgZW5kTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgfSwgaGFuZGxlUmVqZWN0aW9uLmJpbmQobnVsbCwgcHJvbWlzZSkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgaGFuZGxlUmVqZWN0aW9uKHByb21pc2UsIGV4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVSZWplY3Rpb24ocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgcmVqZWN0aW5nRXJyb3JzLnB1c2gocmVhc29uKTtcbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgc2hvdWxkRXhlY3V0ZVRpY2sgPSBwcm9taXNlLl9saWIgJiYgYmVnaW5NaWNyb1RpY2tTY29wZSgpO1xuICAgIHJlYXNvbiA9IHJlamVjdGlvbk1hcHBlcihyZWFzb24pO1xuICAgIHByb21pc2UuX3N0YXRlID0gZmFsc2U7XG4gICAgcHJvbWlzZS5fdmFsdWUgPSByZWFzb247XG4gICAgZGVidWcgJiYgcmVhc29uICE9PSBudWxsICYmIHR5cGVvZiByZWFzb24gPT09ICdvYmplY3QnICYmICFyZWFzb24uX3Byb21pc2UgJiYgdHJ5Q2F0Y2goKCkgPT4ge1xuICAgICAgICB2YXIgb3JpZ1Byb3AgPSBnZXRQcm9wZXJ0eURlc2NyaXB0b3IocmVhc29uLCBcInN0YWNrXCIpO1xuICAgICAgICByZWFzb24uX3Byb21pc2UgPSBwcm9taXNlO1xuICAgICAgICBzZXRQcm9wKHJlYXNvbiwgXCJzdGFja1wiLCB7XG4gICAgICAgICAgICBnZXQ6ICgpID0+IHN0YWNrX2JlaW5nX2dlbmVyYXRlZCA/XG4gICAgICAgICAgICAgICAgb3JpZ1Byb3AgJiYgKG9yaWdQcm9wLmdldCA/XG4gICAgICAgICAgICAgICAgICAgIG9yaWdQcm9wLmdldC5hcHBseShyZWFzb24pIDpcbiAgICAgICAgICAgICAgICAgICAgb3JpZ1Byb3AudmFsdWUpIDpcbiAgICAgICAgICAgICAgICBwcm9taXNlLnN0YWNrXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGFkZFBvc3NpYmx5VW5oYW5kbGVkRXJyb3IocHJvbWlzZSk7XG4gICAgcHJvcGFnYXRlQWxsTGlzdGVuZXJzKHByb21pc2UpO1xuICAgIGlmIChzaG91bGRFeGVjdXRlVGljaylcbiAgICAgICAgZW5kTWljcm9UaWNrU2NvcGUoKTtcbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZUFsbExpc3RlbmVycyhwcm9taXNlKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9IHByb21pc2UuX2xpc3RlbmVycztcbiAgICBwcm9taXNlLl9saXN0ZW5lcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIocHJvbWlzZSwgbGlzdGVuZXJzW2ldKTtcbiAgICB9XG4gICAgdmFyIHBzZCA9IHByb21pc2UuX1BTRDtcbiAgICAtLXBzZC5yZWYgfHwgcHNkLmZpbmFsaXplKCk7XG4gICAgaWYgKG51bVNjaGVkdWxlZENhbGxzID09PSAwKSB7XG4gICAgICAgICsrbnVtU2NoZWR1bGVkQ2FsbHM7XG4gICAgICAgIGFzYXAoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKC0tbnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApXG4gICAgICAgICAgICAgICAgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZVRvTGlzdGVuZXIocHJvbWlzZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcHJvbWlzZS5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjYiA9IHByb21pc2UuX3N0YXRlID8gbGlzdGVuZXIub25GdWxmaWxsZWQgOiBsaXN0ZW5lci5vblJlamVjdGVkO1xuICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gKHByb21pc2UuX3N0YXRlID8gbGlzdGVuZXIucmVzb2x2ZSA6IGxpc3RlbmVyLnJlamVjdCkocHJvbWlzZS5fdmFsdWUpO1xuICAgIH1cbiAgICArK2xpc3RlbmVyLnBzZC5yZWY7XG4gICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICBhc2FwKGNhbGxMaXN0ZW5lciwgW2NiLCBwcm9taXNlLCBsaXN0ZW5lcl0pO1xufVxuZnVuY3Rpb24gY2FsbExpc3RlbmVyKGNiLCBwcm9taXNlLCBsaXN0ZW5lcikge1xuICAgIHRyeSB7XG4gICAgICAgIGN1cnJlbnRGdWxmaWxsZXIgPSBwcm9taXNlO1xuICAgICAgICB2YXIgcmV0LCB2YWx1ZSA9IHByb21pc2UuX3ZhbHVlO1xuICAgICAgICBpZiAocHJvbWlzZS5fc3RhdGUpIHtcbiAgICAgICAgICAgIHJldCA9IGNiKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZWplY3RpbmdFcnJvcnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJlamVjdGluZ0Vycm9ycyA9IFtdO1xuICAgICAgICAgICAgcmV0ID0gY2IodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJlamVjdGluZ0Vycm9ycy5pbmRleE9mKHZhbHVlKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgbWFya0Vycm9yQXNIYW5kbGVkKHByb21pc2UpO1xuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVyLnJlc29sdmUocmV0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgbGlzdGVuZXIucmVqZWN0KGUpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudEZ1bGZpbGxlciA9IG51bGw7XG4gICAgICAgIGlmICgtLW51bVNjaGVkdWxlZENhbGxzID09PSAwKVxuICAgICAgICAgICAgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcbiAgICAgICAgLS1saXN0ZW5lci5wc2QucmVmIHx8IGxpc3RlbmVyLnBzZC5maW5hbGl6ZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFN0YWNrKHByb21pc2UsIHN0YWNrcywgbGltaXQpIHtcbiAgICBpZiAoc3RhY2tzLmxlbmd0aCA9PT0gbGltaXQpXG4gICAgICAgIHJldHVybiBzdGFja3M7XG4gICAgdmFyIHN0YWNrID0gXCJcIjtcbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBmYWlsdXJlID0gcHJvbWlzZS5fdmFsdWUsIGVycm9yTmFtZSwgbWVzc2FnZTtcbiAgICAgICAgaWYgKGZhaWx1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXJyb3JOYW1lID0gZmFpbHVyZS5uYW1lIHx8IFwiRXJyb3JcIjtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBmYWlsdXJlLm1lc3NhZ2UgfHwgZmFpbHVyZTtcbiAgICAgICAgICAgIHN0YWNrID0gcHJldHR5U3RhY2soZmFpbHVyZSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvck5hbWUgPSBmYWlsdXJlO1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tzLnB1c2goZXJyb3JOYW1lICsgKG1lc3NhZ2UgPyBcIjogXCIgKyBtZXNzYWdlIDogXCJcIikgKyBzdGFjayk7XG4gICAgfVxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBzdGFjayA9IHByZXR0eVN0YWNrKHByb21pc2UuX3N0YWNrSG9sZGVyLCAyKTtcbiAgICAgICAgaWYgKHN0YWNrICYmIHN0YWNrcy5pbmRleE9mKHN0YWNrKSA9PT0gLTEpXG4gICAgICAgICAgICBzdGFja3MucHVzaChzdGFjayk7XG4gICAgICAgIGlmIChwcm9taXNlLl9wcmV2KVxuICAgICAgICAgICAgZ2V0U3RhY2socHJvbWlzZS5fcHJldiwgc3RhY2tzLCBsaW1pdCk7XG4gICAgfVxuICAgIHJldHVybiBzdGFja3M7XG59XG5mdW5jdGlvbiBsaW5rVG9QcmV2aW91c1Byb21pc2UocHJvbWlzZSwgcHJldikge1xuICAgIHZhciBudW1QcmV2ID0gcHJldiA/IHByZXYuX251bVByZXYgKyAxIDogMDtcbiAgICBpZiAobnVtUHJldiA8IExPTkdfU1RBQ0tTX0NMSVBfTElNSVQpIHtcbiAgICAgICAgcHJvbWlzZS5fcHJldiA9IHByZXY7XG4gICAgICAgIHByb21pc2UuX251bVByZXYgPSBudW1QcmV2O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBoeXNpY2FsVGljaygpIHtcbiAgICBiZWdpbk1pY3JvVGlja1Njb3BlKCkgJiYgZW5kTWljcm9UaWNrU2NvcGUoKTtcbn1cbmZ1bmN0aW9uIGJlZ2luTWljcm9UaWNrU2NvcGUoKSB7XG4gICAgdmFyIHdhc1Jvb3RFeGVjID0gaXNPdXRzaWRlTWljcm9UaWNrO1xuICAgIGlzT3V0c2lkZU1pY3JvVGljayA9IGZhbHNlO1xuICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gZmFsc2U7XG4gICAgcmV0dXJuIHdhc1Jvb3RFeGVjO1xufVxuZnVuY3Rpb24gZW5kTWljcm9UaWNrU2NvcGUoKSB7XG4gICAgdmFyIGNhbGxiYWNrcywgaSwgbDtcbiAgICBkbyB7XG4gICAgICAgIHdoaWxlIChtaWNyb3RpY2tRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjYWxsYmFja3MgPSBtaWNyb3RpY2tRdWV1ZTtcbiAgICAgICAgICAgIG1pY3JvdGlja1F1ZXVlID0gW107XG4gICAgICAgICAgICBsID0gY2FsbGJhY2tzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGNhbGxiYWNrc1tpXTtcbiAgICAgICAgICAgICAgICBpdGVtWzBdLmFwcGx5KG51bGwsIGl0ZW1bMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSB3aGlsZSAobWljcm90aWNrUXVldWUubGVuZ3RoID4gMCk7XG4gICAgaXNPdXRzaWRlTWljcm9UaWNrID0gdHJ1ZTtcbiAgICBuZWVkc05ld1BoeXNpY2FsVGljayA9IHRydWU7XG59XG5mdW5jdGlvbiBmaW5hbGl6ZVBoeXNpY2FsVGljaygpIHtcbiAgICB2YXIgdW5oYW5kbGVkRXJycyA9IHVuaGFuZGxlZEVycm9ycztcbiAgICB1bmhhbmRsZWRFcnJvcnMgPSBbXTtcbiAgICB1bmhhbmRsZWRFcnJzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIHAuX1BTRC5vbnVuaGFuZGxlZC5jYWxsKG51bGwsIHAuX3ZhbHVlLCBwKTtcbiAgICB9KTtcbiAgICB2YXIgZmluYWxpemVycyA9IHRpY2tGaW5hbGl6ZXJzLnNsaWNlKDApO1xuICAgIHZhciBpID0gZmluYWxpemVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGkpXG4gICAgICAgIGZpbmFsaXplcnNbLS1pXSgpO1xufVxuZnVuY3Rpb24gcnVuX2F0X2VuZF9vZl90aGlzX29yX25leHRfcGh5c2ljYWxfdGljayhmbikge1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplcigpIHtcbiAgICAgICAgZm4oKTtcbiAgICAgICAgdGlja0ZpbmFsaXplcnMuc3BsaWNlKHRpY2tGaW5hbGl6ZXJzLmluZGV4T2YoZmluYWxpemVyKSwgMSk7XG4gICAgfVxuICAgIHRpY2tGaW5hbGl6ZXJzLnB1c2goZmluYWxpemVyKTtcbiAgICArK251bVNjaGVkdWxlZENhbGxzO1xuICAgIGFzYXAoKCkgPT4ge1xuICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMClcbiAgICAgICAgICAgIGZpbmFsaXplUGh5c2ljYWxUaWNrKCk7XG4gICAgfSwgW10pO1xufVxuZnVuY3Rpb24gYWRkUG9zc2libHlVbmhhbmRsZWRFcnJvcihwcm9taXNlKSB7XG4gICAgaWYgKCF1bmhhbmRsZWRFcnJvcnMuc29tZShwID0+IHAuX3ZhbHVlID09PSBwcm9taXNlLl92YWx1ZSkpXG4gICAgICAgIHVuaGFuZGxlZEVycm9ycy5wdXNoKHByb21pc2UpO1xufVxuZnVuY3Rpb24gbWFya0Vycm9yQXNIYW5kbGVkKHByb21pc2UpIHtcbiAgICB2YXIgaSA9IHVuaGFuZGxlZEVycm9ycy5sZW5ndGg7XG4gICAgd2hpbGUgKGkpXG4gICAgICAgIGlmICh1bmhhbmRsZWRFcnJvcnNbLS1pXS5fdmFsdWUgPT09IHByb21pc2UuX3ZhbHVlKSB7XG4gICAgICAgICAgICB1bmhhbmRsZWRFcnJvcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG59XG5mdW5jdGlvbiBQcm9taXNlUmVqZWN0KHJlYXNvbikge1xuICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKElOVEVSTkFMLCBmYWxzZSwgcmVhc29uKTtcbn1cbmZ1bmN0aW9uIHdyYXAoZm4sIGVycm9yQ2F0Y2hlcikge1xuICAgIHZhciBwc2QgPSBQU0Q7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdhc1Jvb3RFeGVjID0gYmVnaW5NaWNyb1RpY2tTY29wZSgpLCBvdXRlclNjb3BlID0gUFNEO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3dpdGNoVG9ab25lKHBzZCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JDYXRjaGVyICYmIGVycm9yQ2F0Y2hlcihlKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclNjb3BlLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAod2FzUm9vdEV4ZWMpXG4gICAgICAgICAgICAgICAgZW5kTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCB0YXNrID0geyBhd2FpdHM6IDAsIGVjaG9lczogMCwgaWQ6IDAgfTtcbnZhciB0YXNrQ291bnRlciA9IDA7XG52YXIgem9uZVN0YWNrID0gW107XG52YXIgem9uZUVjaG9lcyA9IDA7XG52YXIgdG90YWxFY2hvZXMgPSAwO1xudmFyIHpvbmVfaWRfY291bnRlciA9IDA7XG5mdW5jdGlvbiBuZXdTY29wZShmbiwgcHJvcHMsIGExLCBhMikge1xuICAgIHZhciBwYXJlbnQgPSBQU0QsIHBzZCA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICBwc2QucGFyZW50ID0gcGFyZW50O1xuICAgIHBzZC5yZWYgPSAwO1xuICAgIHBzZC5nbG9iYWwgPSBmYWxzZTtcbiAgICBwc2QuaWQgPSArK3pvbmVfaWRfY291bnRlcjtcbiAgICB2YXIgZ2xvYmFsRW52ID0gZ2xvYmFsUFNELmVudjtcbiAgICBwc2QuZW52ID0gcGF0Y2hHbG9iYWxQcm9taXNlID8ge1xuICAgICAgICBQcm9taXNlOiBEZXhpZVByb21pc2UsXG4gICAgICAgIFByb21pc2VQcm9wOiB7IHZhbHVlOiBEZXhpZVByb21pc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcbiAgICAgICAgYWxsOiBEZXhpZVByb21pc2UuYWxsLFxuICAgICAgICByYWNlOiBEZXhpZVByb21pc2UucmFjZSxcbiAgICAgICAgYWxsU2V0dGxlZDogRGV4aWVQcm9taXNlLmFsbFNldHRsZWQsXG4gICAgICAgIGFueTogRGV4aWVQcm9taXNlLmFueSxcbiAgICAgICAgcmVzb2x2ZTogRGV4aWVQcm9taXNlLnJlc29sdmUsXG4gICAgICAgIHJlamVjdDogRGV4aWVQcm9taXNlLnJlamVjdCxcbiAgICAgICAgbnRoZW46IGdldFBhdGNoZWRQcm9taXNlVGhlbihnbG9iYWxFbnYubnRoZW4sIHBzZCksXG4gICAgICAgIGd0aGVuOiBnZXRQYXRjaGVkUHJvbWlzZVRoZW4oZ2xvYmFsRW52Lmd0aGVuLCBwc2QpXG4gICAgfSA6IHt9O1xuICAgIGlmIChwcm9wcylcbiAgICAgICAgZXh0ZW5kKHBzZCwgcHJvcHMpO1xuICAgICsrcGFyZW50LnJlZjtcbiAgICBwc2QuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC0tdGhpcy5wYXJlbnQucmVmIHx8IHRoaXMucGFyZW50LmZpbmFsaXplKCk7XG4gICAgfTtcbiAgICB2YXIgcnYgPSB1c2VQU0QocHNkLCBmbiwgYTEsIGEyKTtcbiAgICBpZiAocHNkLnJlZiA9PT0gMClcbiAgICAgICAgcHNkLmZpbmFsaXplKCk7XG4gICAgcmV0dXJuIHJ2O1xufVxuZnVuY3Rpb24gaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKSB7XG4gICAgaWYgKCF0YXNrLmlkKVxuICAgICAgICB0YXNrLmlkID0gKyt0YXNrQ291bnRlcjtcbiAgICArK3Rhc2suYXdhaXRzO1xuICAgIHRhc2suZWNob2VzICs9IFpPTkVfRUNIT19MSU1JVDtcbiAgICByZXR1cm4gdGFzay5pZDtcbn1cbmZ1bmN0aW9uIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCkge1xuICAgIGlmICghdGFzay5hd2FpdHMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoLS10YXNrLmF3YWl0cyA9PT0gMClcbiAgICAgICAgdGFzay5pZCA9IDA7XG4gICAgdGFzay5lY2hvZXMgPSB0YXNrLmF3YWl0cyAqIFpPTkVfRUNIT19MSU1JVDtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmlmICgoJycgKyBuYXRpdmVQcm9taXNlVGhlbikuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpID09PSAtMSkge1xuICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzID0gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMgPSBub3A7XG59XG5mdW5jdGlvbiBvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMocG9zc2libGVQcm9taXNlKSB7XG4gICAgaWYgKHRhc2suZWNob2VzICYmIHBvc3NpYmxlUHJvbWlzZSAmJiBwb3NzaWJsZVByb21pc2UuY29uc3RydWN0b3IgPT09IE5hdGl2ZVByb21pc2UpIHtcbiAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgcmV0dXJuIHBvc3NpYmxlUHJvbWlzZS50aGVuKHggPT4ge1xuICAgICAgICAgICAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9LCBlID0+IHtcbiAgICAgICAgICAgIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc3NpYmxlUHJvbWlzZTtcbn1cbmZ1bmN0aW9uIHpvbmVFbnRlckVjaG8odGFyZ2V0Wm9uZSkge1xuICAgICsrdG90YWxFY2hvZXM7XG4gICAgaWYgKCF0YXNrLmVjaG9lcyB8fCAtLXRhc2suZWNob2VzID09PSAwKSB7XG4gICAgICAgIHRhc2suZWNob2VzID0gdGFzay5pZCA9IDA7XG4gICAgfVxuICAgIHpvbmVTdGFjay5wdXNoKFBTRCk7XG4gICAgc3dpdGNoVG9ab25lKHRhcmdldFpvbmUsIHRydWUpO1xufVxuZnVuY3Rpb24gem9uZUxlYXZlRWNobygpIHtcbiAgICB2YXIgem9uZSA9IHpvbmVTdGFja1t6b25lU3RhY2subGVuZ3RoIC0gMV07XG4gICAgem9uZVN0YWNrLnBvcCgpO1xuICAgIHN3aXRjaFRvWm9uZSh6b25lLCBmYWxzZSk7XG59XG5mdW5jdGlvbiBzd2l0Y2hUb1pvbmUodGFyZ2V0Wm9uZSwgYkVudGVyaW5nWm9uZSkge1xuICAgIHZhciBjdXJyZW50Wm9uZSA9IFBTRDtcbiAgICBpZiAoYkVudGVyaW5nWm9uZSA/IHRhc2suZWNob2VzICYmICghem9uZUVjaG9lcysrIHx8IHRhcmdldFpvbmUgIT09IFBTRCkgOiB6b25lRWNob2VzICYmICghLS16b25lRWNob2VzIHx8IHRhcmdldFpvbmUgIT09IFBTRCkpIHtcbiAgICAgICAgZW5xdWV1ZU5hdGl2ZU1pY3JvVGFzayhiRW50ZXJpbmdab25lID8gem9uZUVudGVyRWNoby5iaW5kKG51bGwsIHRhcmdldFpvbmUpIDogem9uZUxlYXZlRWNobyk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRab25lID09PSBQU0QpXG4gICAgICAgIHJldHVybjtcbiAgICBQU0QgPSB0YXJnZXRab25lO1xuICAgIGlmIChjdXJyZW50Wm9uZSA9PT0gZ2xvYmFsUFNEKVxuICAgICAgICBnbG9iYWxQU0QuZW52ID0gc25hcFNob3QoKTtcbiAgICBpZiAocGF0Y2hHbG9iYWxQcm9taXNlKSB7XG4gICAgICAgIHZhciBHbG9iYWxQcm9taXNlID0gZ2xvYmFsUFNELmVudi5Qcm9taXNlO1xuICAgICAgICB2YXIgdGFyZ2V0RW52ID0gdGFyZ2V0Wm9uZS5lbnY7XG4gICAgICAgIG5hdGl2ZVByb21pc2VQcm90by50aGVuID0gdGFyZ2V0RW52Lm50aGVuO1xuICAgICAgICBHbG9iYWxQcm9taXNlLnByb3RvdHlwZS50aGVuID0gdGFyZ2V0RW52Lmd0aGVuO1xuICAgICAgICBpZiAoY3VycmVudFpvbmUuZ2xvYmFsIHx8IHRhcmdldFpvbmUuZ2xvYmFsKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2dsb2JhbCwgJ1Byb21pc2UnLCB0YXJnZXRFbnYuUHJvbWlzZVByb3ApO1xuICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5hbGwgPSB0YXJnZXRFbnYuYWxsO1xuICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yYWNlID0gdGFyZ2V0RW52LnJhY2U7XG4gICAgICAgICAgICBHbG9iYWxQcm9taXNlLnJlc29sdmUgPSB0YXJnZXRFbnYucmVzb2x2ZTtcbiAgICAgICAgICAgIEdsb2JhbFByb21pc2UucmVqZWN0ID0gdGFyZ2V0RW52LnJlamVjdDtcbiAgICAgICAgICAgIGlmICh0YXJnZXRFbnYuYWxsU2V0dGxlZClcbiAgICAgICAgICAgICAgICBHbG9iYWxQcm9taXNlLmFsbFNldHRsZWQgPSB0YXJnZXRFbnYuYWxsU2V0dGxlZDtcbiAgICAgICAgICAgIGlmICh0YXJnZXRFbnYuYW55KVxuICAgICAgICAgICAgICAgIEdsb2JhbFByb21pc2UuYW55ID0gdGFyZ2V0RW52LmFueTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNuYXBTaG90KCkge1xuICAgIHZhciBHbG9iYWxQcm9taXNlID0gX2dsb2JhbC5Qcm9taXNlO1xuICAgIHJldHVybiBwYXRjaEdsb2JhbFByb21pc2UgPyB7XG4gICAgICAgIFByb21pc2U6IEdsb2JhbFByb21pc2UsXG4gICAgICAgIFByb21pc2VQcm9wOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF9nbG9iYWwsIFwiUHJvbWlzZVwiKSxcbiAgICAgICAgYWxsOiBHbG9iYWxQcm9taXNlLmFsbCxcbiAgICAgICAgcmFjZTogR2xvYmFsUHJvbWlzZS5yYWNlLFxuICAgICAgICBhbGxTZXR0bGVkOiBHbG9iYWxQcm9taXNlLmFsbFNldHRsZWQsXG4gICAgICAgIGFueTogR2xvYmFsUHJvbWlzZS5hbnksXG4gICAgICAgIHJlc29sdmU6IEdsb2JhbFByb21pc2UucmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0OiBHbG9iYWxQcm9taXNlLnJlamVjdCxcbiAgICAgICAgbnRoZW46IG5hdGl2ZVByb21pc2VQcm90by50aGVuLFxuICAgICAgICBndGhlbjogR2xvYmFsUHJvbWlzZS5wcm90b3R5cGUudGhlblxuICAgIH0gOiB7fTtcbn1cbmZ1bmN0aW9uIHVzZVBTRChwc2QsIGZuLCBhMSwgYTIsIGEzKSB7XG4gICAgdmFyIG91dGVyU2NvcGUgPSBQU0Q7XG4gICAgdHJ5IHtcbiAgICAgICAgc3dpdGNoVG9ab25lKHBzZCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBmbihhMSwgYTIsIGEzKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclNjb3BlLCBmYWxzZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZW5xdWV1ZU5hdGl2ZU1pY3JvVGFzayhqb2IpIHtcbiAgICBuYXRpdmVQcm9taXNlVGhlbi5jYWxsKHJlc29sdmVkTmF0aXZlUHJvbWlzZSwgam9iKTtcbn1cbmZ1bmN0aW9uIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAoZm4sIHpvbmUsIHBvc3NpYmxlQXdhaXQsIGNsZWFudXApIHtcbiAgICByZXR1cm4gdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nID8gZm4gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXRlclpvbmUgPSBQU0Q7XG4gICAgICAgIGlmIChwb3NzaWJsZUF3YWl0KVxuICAgICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgc3dpdGNoVG9ab25lKHpvbmUsIHRydWUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBzd2l0Y2hUb1pvbmUob3V0ZXJab25lLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoY2xlYW51cClcbiAgICAgICAgICAgICAgICBlbnF1ZXVlTmF0aXZlTWljcm9UYXNrKGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRQYXRjaGVkUHJvbWlzZVRoZW4ob3JpZ1RoZW4sIHpvbmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdUaGVuLmNhbGwodGhpcywgbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChvblJlc29sdmVkLCB6b25lKSwgbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChvblJlamVjdGVkLCB6b25lKSk7XG4gICAgfTtcbn1cbmNvbnN0IFVOSEFORExFRFJFSkVDVElPTiA9IFwidW5oYW5kbGVkcmVqZWN0aW9uXCI7XG5mdW5jdGlvbiBnbG9iYWxFcnJvcihlcnIsIHByb21pc2UpIHtcbiAgICB2YXIgcnY7XG4gICAgdHJ5IHtcbiAgICAgICAgcnYgPSBwcm9taXNlLm9udW5jYXRjaGVkKGVycik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICBpZiAocnYgIT09IGZhbHNlKVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGV2ZW50LCBldmVudERhdGEgPSB7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogZXJyIH07XG4gICAgICAgICAgICBpZiAoX2dsb2JhbC5kb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KFVOSEFORExFRFJFSkVDVElPTiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZXh0ZW5kKGV2ZW50LCBldmVudERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX2dsb2JhbC5DdXN0b21FdmVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFVOSEFORExFRFJFSkVDVElPTiwgeyBkZXRhaWw6IGV2ZW50RGF0YSB9KTtcbiAgICAgICAgICAgICAgICBleHRlbmQoZXZlbnQsIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZlbnQgJiYgX2dsb2JhbC5kaXNwYXRjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKCFfZ2xvYmFsLlByb21pc2VSZWplY3Rpb25FdmVudCAmJiBfZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2dsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlYnVnICYmIGV2ZW50ICYmICFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmhhbmRsZWQgcmVqZWN0aW9uOiAke2Vyci5zdGFjayB8fCBlcnJ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxufVxudmFyIHJlamVjdGlvbiA9IERleGllUHJvbWlzZS5yZWplY3Q7XG5cbmZ1bmN0aW9uIHRlbXBUcmFuc2FjdGlvbihkYiwgbW9kZSwgc3RvcmVOYW1lcywgZm4pIHtcbiAgICBpZiAoIWRiLmlkYmRiIHx8ICghZGIuX3N0YXRlLm9wZW5Db21wbGV0ZSAmJiAoIVBTRC5sZXRUaHJvdWdoICYmICFkYi5fdmlwKSkpIHtcbiAgICAgICAgaWYgKGRiLl9zdGF0ZS5vcGVuQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoZGIuX3N0YXRlLmRiT3BlbkVycm9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYi5fc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuICAgICAgICAgICAgaWYgKCFkYi5fb3B0aW9ucy5hdXRvT3BlbilcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCkpO1xuICAgICAgICAgICAgZGIub3BlbigpLmNhdGNoKG5vcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRiLl9zdGF0ZS5kYlJlYWR5UHJvbWlzZS50aGVuKCgpID0+IHRlbXBUcmFuc2FjdGlvbihkYiwgbW9kZSwgc3RvcmVOYW1lcywgZm4pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYi5fZGJTY2hlbWEpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdHJhbnMuY3JlYXRlKCk7XG4gICAgICAgICAgICBkYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPSAzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgaWYgKGV4Lm5hbWUgPT09IGVycm5hbWVzLkludmFsaWRTdGF0ZSAmJiBkYi5pc09wZW4oKSAmJiAtLWRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RleGllOiBOZWVkIHRvIHJlb3BlbiBkYicpO1xuICAgICAgICAgICAgICAgIGRiLl9jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYi5vcGVuKCkudGhlbigoKSA9PiB0ZW1wVHJhbnNhY3Rpb24oZGIsIG1vZGUsIHN0b3JlTmFtZXMsIGZuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnMuX3Byb21pc2UobW9kZSwgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBQU0QudHJhbnMgPSB0cmFucztcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4ocmVzb2x2ZSwgcmVqZWN0LCB0cmFucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zLl9jb21wbGV0aW9uLnRoZW4oKCkgPT4gcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBERVhJRV9WRVJTSU9OID0gJzMuMi43JztcbmNvbnN0IG1heFN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoNjU1MzUpO1xuY29uc3QgbWluS2V5ID0gLUluZmluaXR5O1xuY29uc3QgSU5WQUxJRF9LRVlfQVJHVU1FTlQgPSBcIkludmFsaWQga2V5IHByb3ZpZGVkLiBLZXlzIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcsIG51bWJlciwgRGF0ZSBvciBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBEYXRlPi5cIjtcbmNvbnN0IFNUUklOR19FWFBFQ1RFRCA9IFwiU3RyaW5nIGV4cGVjdGVkLlwiO1xuY29uc3QgY29ubmVjdGlvbnMgPSBbXTtcbmNvbnN0IGlzSUVPckVkZ2UgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvKE1TSUV8VHJpZGVudHxFZGdlKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IGhhc0lFRGVsZXRlT2JqZWN0U3RvcmVCdWcgPSBpc0lFT3JFZGdlO1xuY29uc3QgaGFuZ3NPbkRlbGV0ZUxhcmdlS2V5UmFuZ2UgPSBpc0lFT3JFZGdlO1xuY29uc3QgZGV4aWVTdGFja0ZyYW1lRmlsdGVyID0gZnJhbWUgPT4gIS8oZGV4aWVcXC5qc3xkZXhpZVxcLm1pblxcLmpzKS8udGVzdChmcmFtZSk7XG5jb25zdCBEQk5BTUVTX0RCID0gJ19fZGJuYW1lcyc7XG5jb25zdCBSRUFET05MWSA9ICdyZWFkb25seSc7XG5jb25zdCBSRUFEV1JJVEUgPSAncmVhZHdyaXRlJztcblxuZnVuY3Rpb24gY29tYmluZShmaWx0ZXIxLCBmaWx0ZXIyKSB7XG4gICAgcmV0dXJuIGZpbHRlcjEgP1xuICAgICAgICBmaWx0ZXIyID9cbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZpbHRlcjEuYXBwbHkodGhpcywgYXJndW1lbnRzKSAmJiBmaWx0ZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gOlxuICAgICAgICAgICAgZmlsdGVyMSA6XG4gICAgICAgIGZpbHRlcjI7XG59XG5cbmNvbnN0IEFueVJhbmdlID0ge1xuICAgIHR5cGU6IDMgLFxuICAgIGxvd2VyOiAtSW5maW5pdHksXG4gICAgbG93ZXJPcGVuOiBmYWxzZSxcbiAgICB1cHBlcjogW1tdXSxcbiAgICB1cHBlck9wZW46IGZhbHNlXG59O1xuXG5mdW5jdGlvbiB3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBrZXlQYXRoID09PSBcInN0cmluZ1wiICYmICEvXFwuLy50ZXN0KGtleVBhdGgpXG4gICAgICAgID8gKG9iaikgPT4ge1xuICAgICAgICAgICAgaWYgKG9ialtrZXlQYXRoXSA9PT0gdW5kZWZpbmVkICYmIChrZXlQYXRoIGluIG9iaikpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBkZWVwQ2xvbmUob2JqKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleVBhdGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICA6IChvYmopID0+IG9iajtcbn1cblxuY2xhc3MgVGFibGUge1xuICAgIF90cmFucyhtb2RlLCBmbiwgd3JpdGVMb2NrZWQpIHtcbiAgICAgICAgY29uc3QgdHJhbnMgPSB0aGlzLl90eCB8fCBQU0QudHJhbnM7XG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24ocmVzb2x2ZSwgcmVqZWN0LCB0cmFucykge1xuICAgICAgICAgICAgaWYgKCF0cmFucy5zY2hlbWFbdGFibGVOYW1lXSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5Ob3RGb3VuZChcIlRhYmxlIFwiICsgdGFibGVOYW1lICsgXCIgbm90IHBhcnQgb2YgdHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICByZXR1cm4gZm4odHJhbnMuaWRidHJhbnMsIHRyYW5zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YXNSb290RXhlYyA9IGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0cmFucyAmJiB0cmFucy5kYiA9PT0gdGhpcy5kYiA/XG4gICAgICAgICAgICAgICAgdHJhbnMgPT09IFBTRC50cmFucyA/XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zLl9wcm9taXNlKG1vZGUsIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uLCB3cml0ZUxvY2tlZCkgOlxuICAgICAgICAgICAgICAgICAgICBuZXdTY29wZSgoKSA9PiB0cmFucy5fcHJvbWlzZShtb2RlLCBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbiwgd3JpdGVMb2NrZWQpLCB7IHRyYW5zOiB0cmFucywgdHJhbnNsZXNzOiBQU0QudHJhbnNsZXNzIHx8IFBTRCB9KSA6XG4gICAgICAgICAgICAgICAgdGVtcFRyYW5zYWN0aW9uKHRoaXMuZGIsIG1vZGUsIFt0aGlzLm5hbWVdLCBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAod2FzUm9vdEV4ZWMpXG4gICAgICAgICAgICAgICAgZW5kTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQoa2V5T3JDcml0LCBjYikge1xuICAgICAgICBpZiAoa2V5T3JDcml0ICYmIGtleU9yQ3JpdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUoa2V5T3JDcml0KS5maXJzdChjYik7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZG9ubHknLCAodHJhbnMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvcmUuZ2V0KHsgdHJhbnMsIGtleToga2V5T3JDcml0IH0pXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzID0+IHRoaXMuaG9vay5yZWFkaW5nLmZpcmUocmVzKSk7XG4gICAgICAgIH0pLnRoZW4oY2IpO1xuICAgIH1cbiAgICB3aGVyZShpbmRleE9yQ3JpdCkge1xuICAgICAgICBpZiAodHlwZW9mIGluZGV4T3JDcml0ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzLCBpbmRleE9yQ3JpdCk7XG4gICAgICAgIGlmIChpc0FycmF5KGluZGV4T3JDcml0KSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzLCBgWyR7aW5kZXhPckNyaXQuam9pbignKycpfV1gKTtcbiAgICAgICAgY29uc3Qga2V5UGF0aHMgPSBrZXlzKGluZGV4T3JDcml0KTtcbiAgICAgICAgaWYgKGtleVBhdGhzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAgICAgLndoZXJlKGtleVBhdGhzWzBdKVxuICAgICAgICAgICAgICAgIC5lcXVhbHMoaW5kZXhPckNyaXRba2V5UGF0aHNbMF1dKTtcbiAgICAgICAgY29uc3QgY29tcG91bmRJbmRleCA9IHRoaXMuc2NoZW1hLmluZGV4ZXMuY29uY2F0KHRoaXMuc2NoZW1hLnByaW1LZXkpLmZpbHRlcihpeCA9PiB7XG4gICAgICAgICAgICBpZiAoaXguY29tcG91bmQgJiZcbiAgICAgICAgICAgICAgICBrZXlQYXRocy5ldmVyeShrZXlQYXRoID0+IGl4LmtleVBhdGguaW5kZXhPZihrZXlQYXRoKSA+PSAwKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5UGF0aHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleVBhdGhzLmluZGV4T2YoaXgua2V5UGF0aFtpXSkgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSkuc29ydCgoYSwgYikgPT4gYS5rZXlQYXRoLmxlbmd0aCAtIGIua2V5UGF0aC5sZW5ndGgpWzBdO1xuICAgICAgICBpZiAoY29tcG91bmRJbmRleCAmJiB0aGlzLmRiLl9tYXhLZXkgIT09IG1heFN0cmluZykge1xuICAgICAgICAgICAgY29uc3Qga2V5UGF0aHNJblZhbGlkT3JkZXIgPSBjb21wb3VuZEluZGV4LmtleVBhdGguc2xpY2UoMCwga2V5UGF0aHMubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAgICAgLndoZXJlKGtleVBhdGhzSW5WYWxpZE9yZGVyKVxuICAgICAgICAgICAgICAgIC5lcXVhbHMoa2V5UGF0aHNJblZhbGlkT3JkZXIubWFwKGtwID0+IGluZGV4T3JDcml0W2twXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29tcG91bmRJbmRleCAmJiBkZWJ1ZylcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGhlIHF1ZXJ5ICR7SlNPTi5zdHJpbmdpZnkoaW5kZXhPckNyaXQpfSBvbiAke3RoaXMubmFtZX0gd291bGQgYmVuZWZpdCBvZiBhIGAgK1xuICAgICAgICAgICAgICAgIGBjb21wb3VuZCBpbmRleCBbJHtrZXlQYXRocy5qb2luKCcrJyl9XWApO1xuICAgICAgICBjb25zdCB7IGlkeEJ5TmFtZSB9ID0gdGhpcy5zY2hlbWE7XG4gICAgICAgIGNvbnN0IGlkYiA9IHRoaXMuZGIuX2RlcHMuaW5kZXhlZERCO1xuICAgICAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWRiLmNtcChhLCBiKSA9PT0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtpZHgsIGZpbHRlckZ1bmN0aW9uXSA9IGtleVBhdGhzLnJlZHVjZSgoW3ByZXZJbmRleCwgcHJldkZpbHRlckZuXSwga2V5UGF0aCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpZHhCeU5hbWVba2V5UGF0aF07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGluZGV4T3JDcml0W2tleVBhdGhdO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBwcmV2SW5kZXggfHwgaW5kZXgsXG4gICAgICAgICAgICAgICAgcHJldkluZGV4IHx8ICFpbmRleCA/XG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmUocHJldkZpbHRlckZuLCBpbmRleCAmJiBpbmRleC5tdWx0aSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gZ2V0QnlLZXlQYXRoKHgsIGtleVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHByb3ApICYmIHByb3Auc29tZShpdGVtID0+IGVxdWFscyh2YWx1ZSwgaXRlbSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSA6IHggPT4gZXF1YWxzKHZhbHVlLCBnZXRCeUtleVBhdGgoeCwga2V5UGF0aCkpKVxuICAgICAgICAgICAgICAgICAgICA6IHByZXZGaWx0ZXJGblxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSwgW251bGwsIG51bGxdKTtcbiAgICAgICAgcmV0dXJuIGlkeCA/XG4gICAgICAgICAgICB0aGlzLndoZXJlKGlkeC5uYW1lKS5lcXVhbHMoaW5kZXhPckNyaXRbaWR4LmtleVBhdGhdKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZmlsdGVyRnVuY3Rpb24pIDpcbiAgICAgICAgICAgIGNvbXBvdW5kSW5kZXggP1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyKGZpbHRlckZ1bmN0aW9uKSA6XG4gICAgICAgICAgICAgICAgdGhpcy53aGVyZShrZXlQYXRocykuZXF1YWxzKCcnKTtcbiAgICB9XG4gICAgZmlsdGVyKGZpbHRlckZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmFuZChmaWx0ZXJGdW5jdGlvbik7XG4gICAgfVxuICAgIGNvdW50KHRoZW5TaG9ydGN1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5jb3VudCh0aGVuU2hvcnRjdXQpO1xuICAgIH1cbiAgICBvZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLm9mZnNldChvZmZzZXQpO1xuICAgIH1cbiAgICBsaW1pdChudW1Sb3dzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmxpbWl0KG51bVJvd3MpO1xuICAgIH1cbiAgICBlYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmVhY2goY2FsbGJhY2spO1xuICAgIH1cbiAgICB0b0FycmF5KHRoZW5TaG9ydGN1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS50b0FycmF5KHRoZW5TaG9ydGN1dCk7XG4gICAgfVxuICAgIHRvQ29sbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLkNvbGxlY3Rpb24obmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcykpO1xuICAgIH1cbiAgICBvcmRlckJ5KGluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5Db2xsZWN0aW9uKG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIGlzQXJyYXkoaW5kZXgpID9cbiAgICAgICAgICAgIGBbJHtpbmRleC5qb2luKCcrJyl9XWAgOlxuICAgICAgICAgICAgaW5kZXgpKTtcbiAgICB9XG4gICAgcmV2ZXJzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBtYXBUb0NsYXNzKGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hLm1hcHBlZENsYXNzID0gY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IHJlYWRIb29rID0gb2JqID0+IHtcbiAgICAgICAgICAgIGlmICghb2JqKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBPYmplY3QuY3JlYXRlKGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBtIGluIG9iailcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duKG9iaiwgbSkpXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNbbV0gPSBvYmpbbV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1hLnJlYWRIb29rKSB7XG4gICAgICAgICAgICB0aGlzLmhvb2sucmVhZGluZy51bnN1YnNjcmliZSh0aGlzLnNjaGVtYS5yZWFkSG9vayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlbWEucmVhZEhvb2sgPSByZWFkSG9vaztcbiAgICAgICAgdGhpcy5ob29rKFwicmVhZGluZ1wiLCByZWFkSG9vayk7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgZGVmaW5lQ2xhc3MoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENsYXNzKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGV4dGVuZCh0aGlzLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXBUb0NsYXNzKENsYXNzKTtcbiAgICB9XG4gICAgYWRkKG9iaiwga2V5KSB7XG4gICAgICAgIGNvbnN0IHsgYXV0bywga2V5UGF0aCB9ID0gdGhpcy5zY2hlbWEucHJpbUtleTtcbiAgICAgICAgbGV0IG9ialRvQWRkID0gb2JqO1xuICAgICAgICBpZiAoa2V5UGF0aCAmJiBhdXRvKSB7XG4gICAgICAgICAgICBvYmpUb0FkZCA9IHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCB0cmFucyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zLCB0eXBlOiAnYWRkJywga2V5czoga2V5ICE9IG51bGwgPyBba2V5XSA6IG51bGwsIHZhbHVlczogW29ialRvQWRkXSB9KTtcbiAgICAgICAgfSkudGhlbihyZXMgPT4gcmVzLm51bUZhaWx1cmVzID8gRGV4aWVQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogcmVzLmxhc3RSZXN1bHQpXG4gICAgICAgICAgICAudGhlbihsYXN0UmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGlmIChrZXlQYXRoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgbGFzdFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlKGtleU9yT2JqZWN0LCBtb2RpZmljYXRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5T3JPYmplY3QgPT09ICdvYmplY3QnICYmICFpc0FycmF5KGtleU9yT2JqZWN0KSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZ2V0QnlLZXlQYXRoKGtleU9yT2JqZWN0LCB0aGlzLnNjaGVtYS5wcmltS2V5LmtleVBhdGgpO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiR2l2ZW4gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gaXRzIHByaW1hcnkga2V5XCIpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmljYXRpb25zICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cyhtb2RpZmljYXRpb25zKS5mb3JFYWNoKGtleVBhdGggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGtleU9yT2JqZWN0LCBrZXlQYXRoLCBtb2RpZmljYXRpb25zW2tleVBhdGhdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmljYXRpb25zKGtleU9yT2JqZWN0LCB7IHZhbHVlOiBrZXlPck9iamVjdCwgcHJpbUtleToga2V5IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUoXCI6aWRcIikuZXF1YWxzKGtleSkubW9kaWZ5KG1vZGlmaWNhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUoXCI6aWRcIikuZXF1YWxzKGtleU9yT2JqZWN0KS5tb2RpZnkobW9kaWZpY2F0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHV0KG9iaiwga2V5KSB7XG4gICAgICAgIGNvbnN0IHsgYXV0bywga2V5UGF0aCB9ID0gdGhpcy5zY2hlbWEucHJpbUtleTtcbiAgICAgICAgbGV0IG9ialRvQWRkID0gb2JqO1xuICAgICAgICBpZiAoa2V5UGF0aCAmJiBhdXRvKSB7XG4gICAgICAgICAgICBvYmpUb0FkZCA9IHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCB0cmFucyA9PiB0aGlzLmNvcmUubXV0YXRlKHsgdHJhbnMsIHR5cGU6ICdwdXQnLCB2YWx1ZXM6IFtvYmpUb0FkZF0sIGtleXM6IGtleSAhPSBudWxsID8gW2tleV0gOiBudWxsIH0pKVxuICAgICAgICAgICAgLnRoZW4ocmVzID0+IHJlcy5udW1GYWlsdXJlcyA/IERleGllUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6IHJlcy5sYXN0UmVzdWx0KVxuICAgICAgICAgICAgLnRoZW4obGFzdFJlc3VsdCA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5UGF0aCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIGxhc3RSZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCB0cmFucyA9PiB0aGlzLmNvcmUubXV0YXRlKHsgdHJhbnMsIHR5cGU6ICdkZWxldGUnLCBrZXlzOiBba2V5XSB9KSlcbiAgICAgICAgICAgIC50aGVuKHJlcyA9PiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCB0cmFucyA9PiB0aGlzLmNvcmUubXV0YXRlKHsgdHJhbnMsIHR5cGU6ICdkZWxldGVSYW5nZScsIHJhbmdlOiBBbnlSYW5nZSB9KSlcbiAgICAgICAgICAgIC50aGVuKHJlcyA9PiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBidWxrR2V0KGtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkb25seScsIHRyYW5zID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvcmUuZ2V0TWFueSh7XG4gICAgICAgICAgICAgICAga2V5cyxcbiAgICAgICAgICAgICAgICB0cmFuc1xuICAgICAgICAgICAgfSkudGhlbihyZXN1bHQgPT4gcmVzdWx0Lm1hcChyZXMgPT4gdGhpcy5ob29rLnJlYWRpbmcuZmlyZShyZXMpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBidWxrQWRkKG9iamVjdHMsIGtleXNPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoa2V5c09yT3B0aW9ucykgPyBrZXlzT3JPcHRpb25zIDogdW5kZWZpbmVkO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCAoa2V5cyA/IHVuZGVmaW5lZCA6IGtleXNPck9wdGlvbnMpO1xuICAgICAgICBjb25zdCB3YW50UmVzdWx0cyA9IG9wdGlvbnMgPyBvcHRpb25zLmFsbEtleXMgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgdHJhbnMgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBhdXRvLCBrZXlQYXRoIH0gPSB0aGlzLnNjaGVtYS5wcmltS2V5O1xuICAgICAgICAgICAgaWYgKGtleVBhdGggJiYga2V5cylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJidWxrQWRkKCk6IGtleXMgYXJndW1lbnQgaW52YWxpZCBvbiB0YWJsZXMgd2l0aCBpbmJvdW5kIGtleXNcIik7XG4gICAgICAgICAgICBpZiAoa2V5cyAmJiBrZXlzLmxlbmd0aCAhPT0gb2JqZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiQXJndW1lbnRzIG9iamVjdHMgYW5kIGtleXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIGNvbnN0IG51bU9iamVjdHMgPSBvYmplY3RzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBvYmplY3RzVG9BZGQgPSBrZXlQYXRoICYmIGF1dG8gP1xuICAgICAgICAgICAgICAgIG9iamVjdHMubWFwKHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKSA6XG4gICAgICAgICAgICAgICAgb2JqZWN0cztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvcmUubXV0YXRlKHsgdHJhbnMsIHR5cGU6ICdhZGQnLCBrZXlzOiBrZXlzLCB2YWx1ZXM6IG9iamVjdHNUb0FkZCwgd2FudFJlc3VsdHMgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoeyBudW1GYWlsdXJlcywgcmVzdWx0cywgbGFzdFJlc3VsdCwgZmFpbHVyZXMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHdhbnRSZXN1bHRzID8gcmVzdWx0cyA6IGxhc3RSZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoYCR7dGhpcy5uYW1lfS5idWxrQWRkKCk6ICR7bnVtRmFpbHVyZXN9IG9mICR7bnVtT2JqZWN0c30gb3BlcmF0aW9ucyBmYWlsZWRgLCBmYWlsdXJlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJ1bGtQdXQob2JqZWN0cywga2V5c09yT3B0aW9ucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShrZXlzT3JPcHRpb25zKSA/IGtleXNPck9wdGlvbnMgOiB1bmRlZmluZWQ7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IChrZXlzID8gdW5kZWZpbmVkIDoga2V5c09yT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHdhbnRSZXN1bHRzID0gb3B0aW9ucyA/IG9wdGlvbnMuYWxsS2V5cyA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCB0cmFucyA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGF1dG8sIGtleVBhdGggfSA9IHRoaXMuc2NoZW1hLnByaW1LZXk7XG4gICAgICAgICAgICBpZiAoa2V5UGF0aCAmJiBrZXlzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtQdXQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcbiAgICAgICAgICAgIGlmIChrZXlzICYmIGtleXMubGVuZ3RoICE9PSBvYmplY3RzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJBcmd1bWVudHMgb2JqZWN0cyBhbmQga2V5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgY29uc3QgbnVtT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG9iamVjdHNUb1B1dCA9IGtleVBhdGggJiYgYXV0byA/XG4gICAgICAgICAgICAgICAgb2JqZWN0cy5tYXAod29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkpIDpcbiAgICAgICAgICAgICAgICBvYmplY3RzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29yZS5tdXRhdGUoeyB0cmFucywgdHlwZTogJ3B1dCcsIGtleXM6IGtleXMsIHZhbHVlczogb2JqZWN0c1RvUHV0LCB3YW50UmVzdWx0cyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKCh7IG51bUZhaWx1cmVzLCByZXN1bHRzLCBsYXN0UmVzdWx0LCBmYWlsdXJlcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gd2FudFJlc3VsdHMgPyByZXN1bHRzIDogbGFzdFJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihgJHt0aGlzLm5hbWV9LmJ1bGtQdXQoKTogJHtudW1GYWlsdXJlc30gb2YgJHtudW1PYmplY3RzfSBvcGVyYXRpb25zIGZhaWxlZGAsIGZhaWx1cmVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnVsa0RlbGV0ZShrZXlzKSB7XG4gICAgICAgIGNvbnN0IG51bUtleXMgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCB0cmFucyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zLCB0eXBlOiAnZGVsZXRlJywga2V5czoga2V5cyB9KTtcbiAgICAgICAgfSkudGhlbigoeyBudW1GYWlsdXJlcywgbGFzdFJlc3VsdCwgZmFpbHVyZXMgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihgJHt0aGlzLm5hbWV9LmJ1bGtEZWxldGUoKTogJHtudW1GYWlsdXJlc30gb2YgJHtudW1LZXlzfSBvcGVyYXRpb25zIGZhaWxlZGAsIGZhaWx1cmVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBFdmVudHMoY3R4KSB7XG4gICAgdmFyIGV2cyA9IHt9O1xuICAgIHZhciBydiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShpIC0gMSk7XG4gICAgICAgICAgICB3aGlsZSAoLS1pKVxuICAgICAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZXZzW2V2ZW50TmFtZV0uc3Vic2NyaWJlLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGV2ZW50TmFtZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZzW2V2ZW50TmFtZV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJ2LmFkZEV2ZW50VHlwZSA9IGFkZDtcbiAgICBmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgYWRkKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBydjtcbiAgICBmdW5jdGlvbiBhZGQoZXZlbnROYW1lLCBjaGFpbkZ1bmN0aW9uLCBkZWZhdWx0RnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIGFkZENvbmZpZ3VyZWRFdmVudHMoZXZlbnROYW1lKTtcbiAgICAgICAgaWYgKCFjaGFpbkZ1bmN0aW9uKVxuICAgICAgICAgICAgY2hhaW5GdW5jdGlvbiA9IHJldmVyc2VTdG9wcGFibGVFdmVudENoYWluO1xuICAgICAgICBpZiAoIWRlZmF1bHRGdW5jdGlvbilcbiAgICAgICAgICAgIGRlZmF1bHRGdW5jdGlvbiA9IG5vcDtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyczogW10sXG4gICAgICAgICAgICBmaXJlOiBkZWZhdWx0RnVuY3Rpb24sXG4gICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnN1YnNjcmliZXJzLmluZGV4T2YoY2IpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzLnB1c2goY2IpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpcmUgPSBjaGFpbkZ1bmN0aW9uKGNvbnRleHQuZmlyZSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpYmVycyA9IGNvbnRleHQuc3Vic2NyaWJlcnMuZmlsdGVyKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4gIT09IGNiOyB9KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpcmUgPSBjb250ZXh0LnN1YnNjcmliZXJzLnJlZHVjZShjaGFpbkZ1bmN0aW9uLCBkZWZhdWx0RnVuY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBldnNbZXZlbnROYW1lXSA9IHJ2W2V2ZW50TmFtZV0gPSBjb250ZXh0O1xuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkQ29uZmlndXJlZEV2ZW50cyhjZmcpIHtcbiAgICAgICAga2V5cyhjZmcpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBjZmdbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgYWRkKGV2ZW50TmFtZSwgY2ZnW2V2ZW50TmFtZV1bMF0sIGNmZ1tldmVudE5hbWVdWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3MgPT09ICdhc2FwJykge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gYWRkKGV2ZW50TmFtZSwgbWlycm9yLCBmdW5jdGlvbiBmaXJlKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc2FwJDEoZnVuY3Rpb24gZmlyZUV2ZW50KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgZXZlbnQgY29uZmlnXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VDbGFzc0NvbnN0cnVjdG9yKHByb3RvdHlwZSwgY29uc3RydWN0b3IpIHtcbiAgICBkZXJpdmUoY29uc3RydWN0b3IpLmZyb20oeyBwcm90b3R5cGUgfSk7XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUYWJsZUNvbnN0cnVjdG9yKGRiKSB7XG4gICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKFRhYmxlLnByb3RvdHlwZSwgZnVuY3Rpb24gVGFibGUobmFtZSwgdGFibGVTY2hlbWEsIHRyYW5zKSB7XG4gICAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgICAgdGhpcy5fdHggPSB0cmFucztcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSB0YWJsZVNjaGVtYTtcbiAgICAgICAgdGhpcy5ob29rID0gZGIuX2FsbFRhYmxlc1tuYW1lXSA/IGRiLl9hbGxUYWJsZXNbbmFtZV0uaG9vayA6IEV2ZW50cyhudWxsLCB7XG4gICAgICAgICAgICBcImNyZWF0aW5nXCI6IFtob29rQ3JlYXRpbmdDaGFpbiwgbm9wXSxcbiAgICAgICAgICAgIFwicmVhZGluZ1wiOiBbcHVyZUZ1bmN0aW9uQ2hhaW4sIG1pcnJvcl0sXG4gICAgICAgICAgICBcInVwZGF0aW5nXCI6IFtob29rVXBkYXRpbmdDaGFpbiwgbm9wXSxcbiAgICAgICAgICAgIFwiZGVsZXRpbmdcIjogW2hvb2tEZWxldGluZ0NoYWluLCBub3BdXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpc1BsYWluS2V5UmFuZ2UoY3R4LCBpZ25vcmVMaW1pdEZpbHRlcikge1xuICAgIHJldHVybiAhKGN0eC5maWx0ZXIgfHwgY3R4LmFsZ29yaXRobSB8fCBjdHgub3IpICYmXG4gICAgICAgIChpZ25vcmVMaW1pdEZpbHRlciA/IGN0eC5qdXN0TGltaXQgOiAhY3R4LnJlcGxheUZpbHRlcik7XG59XG5mdW5jdGlvbiBhZGRGaWx0ZXIoY3R4LCBmbikge1xuICAgIGN0eC5maWx0ZXIgPSBjb21iaW5lKGN0eC5maWx0ZXIsIGZuKTtcbn1cbmZ1bmN0aW9uIGFkZFJlcGxheUZpbHRlcihjdHgsIGZhY3RvcnksIGlzTGltaXRGaWx0ZXIpIHtcbiAgICB2YXIgY3VyciA9IGN0eC5yZXBsYXlGaWx0ZXI7XG4gICAgY3R4LnJlcGxheUZpbHRlciA9IGN1cnIgPyAoKSA9PiBjb21iaW5lKGN1cnIoKSwgZmFjdG9yeSgpKSA6IGZhY3Rvcnk7XG4gICAgY3R4Lmp1c3RMaW1pdCA9IGlzTGltaXRGaWx0ZXIgJiYgIWN1cnI7XG59XG5mdW5jdGlvbiBhZGRNYXRjaEZpbHRlcihjdHgsIGZuKSB7XG4gICAgY3R4LmlzTWF0Y2ggPSBjb21iaW5lKGN0eC5pc01hdGNoLCBmbik7XG59XG5mdW5jdGlvbiBnZXRJbmRleE9yU3RvcmUoY3R4LCBjb3JlU2NoZW1hKSB7XG4gICAgaWYgKGN0eC5pc1ByaW1LZXkpXG4gICAgICAgIHJldHVybiBjb3JlU2NoZW1hLnByaW1hcnlLZXk7XG4gICAgY29uc3QgaW5kZXggPSBjb3JlU2NoZW1hLmdldEluZGV4QnlLZXlQYXRoKGN0eC5pbmRleCk7XG4gICAgaWYgKCFpbmRleClcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiS2V5UGF0aCBcIiArIGN0eC5pbmRleCArIFwiIG9uIG9iamVjdCBzdG9yZSBcIiArIGNvcmVTY2hlbWEubmFtZSArIFwiIGlzIG5vdCBpbmRleGVkXCIpO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIG9wZW5DdXJzb3IoY3R4LCBjb3JlVGFibGUsIHRyYW5zKSB7XG4gICAgY29uc3QgaW5kZXggPSBnZXRJbmRleE9yU3RvcmUoY3R4LCBjb3JlVGFibGUuc2NoZW1hKTtcbiAgICByZXR1cm4gY29yZVRhYmxlLm9wZW5DdXJzb3Ioe1xuICAgICAgICB0cmFucyxcbiAgICAgICAgdmFsdWVzOiAhY3R4LmtleXNPbmx5LFxuICAgICAgICByZXZlcnNlOiBjdHguZGlyID09PSAncHJldicsXG4gICAgICAgIHVuaXF1ZTogISFjdHgudW5pcXVlLFxuICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGl0ZXIoY3R4LCBmbiwgY29yZVRyYW5zLCBjb3JlVGFibGUpIHtcbiAgICBjb25zdCBmaWx0ZXIgPSBjdHgucmVwbGF5RmlsdGVyID8gY29tYmluZShjdHguZmlsdGVyLCBjdHgucmVwbGF5RmlsdGVyKCkpIDogY3R4LmZpbHRlcjtcbiAgICBpZiAoIWN0eC5vcikge1xuICAgICAgICByZXR1cm4gaXRlcmF0ZShvcGVuQ3Vyc29yKGN0eCwgY29yZVRhYmxlLCBjb3JlVHJhbnMpLCBjb21iaW5lKGN0eC5hbGdvcml0aG0sIGZpbHRlciksIGZuLCAhY3R4LmtleXNPbmx5ICYmIGN0eC52YWx1ZU1hcHBlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzZXQgPSB7fTtcbiAgICAgICAgY29uc3QgdW5pb24gPSAoaXRlbSwgY3Vyc29yLCBhZHZhbmNlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoY3Vyc29yLCBhZHZhbmNlLCByZXN1bHQgPT4gY3Vyc29yLnN0b3AocmVzdWx0KSwgZXJyID0+IGN1cnNvci5mYWlsKGVycikpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByaW1hcnlLZXkgPSBjdXJzb3IucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gJycgKyBwcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpXG4gICAgICAgICAgICAgICAgICAgIGtleSA9ICcnICsgbmV3IFVpbnQ4QXJyYXkocHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNPd24oc2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZm4oaXRlbSwgY3Vyc29yLCBhZHZhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBjdHgub3IuX2l0ZXJhdGUodW5pb24sIGNvcmVUcmFucyksXG4gICAgICAgICAgICBpdGVyYXRlKG9wZW5DdXJzb3IoY3R4LCBjb3JlVGFibGUsIGNvcmVUcmFucyksIGN0eC5hbGdvcml0aG0sIHVuaW9uLCAhY3R4LmtleXNPbmx5ICYmIGN0eC52YWx1ZU1hcHBlcilcbiAgICAgICAgXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXRlcmF0ZShjdXJzb3JQcm9taXNlLCBmaWx0ZXIsIGZuLCB2YWx1ZU1hcHBlcikge1xuICAgIHZhciBtYXBwZWRGbiA9IHZhbHVlTWFwcGVyID8gKHgsIGMsIGEpID0+IGZuKHZhbHVlTWFwcGVyKHgpLCBjLCBhKSA6IGZuO1xuICAgIHZhciB3cmFwcGVkRm4gPSB3cmFwKG1hcHBlZEZuKTtcbiAgICByZXR1cm4gY3Vyc29yUHJvbWlzZS50aGVuKGN1cnNvciA9PiB7XG4gICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJzb3Iuc3RhcnQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBjID0gKCkgPT4gY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGN1cnNvciwgYWR2YW5jZXIgPT4gYyA9IGFkdmFuY2VyLCB2YWwgPT4geyBjdXJzb3Iuc3RvcCh2YWwpOyBjID0gbm9wOyB9LCBlID0+IHsgY3Vyc29yLmZhaWwoZSk7IGMgPSBub3A7IH0pKVxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVkRm4oY3Vyc29yLnZhbHVlLCBjdXJzb3IsIGFkdmFuY2VyID0+IGMgPSBhZHZhbmNlcik7XG4gICAgICAgICAgICAgICAgYygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY21wKGEsIGIpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB0YSA9IHR5cGUoYSk7XG4gICAgICAgIGNvbnN0IHRiID0gdHlwZShiKTtcbiAgICAgICAgaWYgKHRhICE9PSB0Yikge1xuICAgICAgICAgICAgaWYgKHRhID09PSAnQXJyYXknKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgaWYgKHRiID09PSAnQXJyYXknKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmICh0YSA9PT0gJ2JpbmFyeScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAodGIgPT09ICdiaW5hcnknKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmICh0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAodGIgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmICh0YSA9PT0gJ0RhdGUnKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgaWYgKHRiICE9PSAnRGF0ZScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRhKSB7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgY2FzZSAnRGF0ZSc6XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbiAgICAgICAgICAgIGNhc2UgJ2JpbmFyeSc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZVVpbnQ4QXJyYXlzKGdldFVpbnQ4QXJyYXkoYSksIGdldFVpbnQ4QXJyYXkoYikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlQXJyYXlzKGEsIGIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChfYSkgeyB9XG4gICAgcmV0dXJuIE5hTjtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYSwgYikge1xuICAgIGNvbnN0IGFsID0gYS5sZW5ndGg7XG4gICAgY29uc3QgYmwgPSBiLmxlbmd0aDtcbiAgICBjb25zdCBsID0gYWwgPCBibCA/IGFsIDogYmw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgY29uc3QgcmVzID0gY21wKGFbaV0sIGJbaV0pO1xuICAgICAgICBpZiAocmVzICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgcmV0dXJuIGFsID09PSBibCA/IDAgOiBhbCA8IGJsID8gLTEgOiAxO1xufVxuZnVuY3Rpb24gY29tcGFyZVVpbnQ4QXJyYXlzKGEsIGIpIHtcbiAgICBjb25zdCBhbCA9IGEubGVuZ3RoO1xuICAgIGNvbnN0IGJsID0gYi5sZW5ndGg7XG4gICAgY29uc3QgbCA9IGFsIDwgYmwgPyBhbCA6IGJsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKVxuICAgICAgICAgICAgcmV0dXJuIGFbaV0gPCBiW2ldID8gLTEgOiAxO1xuICAgIH1cbiAgICByZXR1cm4gYWwgPT09IGJsID8gMCA6IGFsIDwgYmwgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiB0eXBlKHgpIHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIHg7XG4gICAgaWYgKHQgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gdDtcbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHgpKVxuICAgICAgICByZXR1cm4gJ2JpbmFyeSc7XG4gICAgY29uc3QgdHNUYWcgPSB0b1N0cmluZ1RhZyh4KTtcbiAgICByZXR1cm4gdHNUYWcgPT09ICdBcnJheUJ1ZmZlcicgPyAnYmluYXJ5JyA6IHRzVGFnO1xufVxuZnVuY3Rpb24gZ2V0VWludDhBcnJheShhKSB7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gYTtcbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpKVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCwgYS5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYSk7XG59XG5cbmNsYXNzIENvbGxlY3Rpb24ge1xuICAgIF9yZWFkKGZuLCBjYikge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICByZXR1cm4gY3R4LmVycm9yID9cbiAgICAgICAgICAgIGN0eC50YWJsZS5fdHJhbnMobnVsbCwgcmVqZWN0aW9uLmJpbmQobnVsbCwgY3R4LmVycm9yKSkgOlxuICAgICAgICAgICAgY3R4LnRhYmxlLl90cmFucygncmVhZG9ubHknLCBmbikudGhlbihjYik7XG4gICAgfVxuICAgIF93cml0ZShmbikge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICByZXR1cm4gY3R4LmVycm9yID9cbiAgICAgICAgICAgIGN0eC50YWJsZS5fdHJhbnMobnVsbCwgcmVqZWN0aW9uLmJpbmQobnVsbCwgY3R4LmVycm9yKSkgOlxuICAgICAgICAgICAgY3R4LnRhYmxlLl90cmFucygncmVhZHdyaXRlJywgZm4sIFwibG9ja2VkXCIpO1xuICAgIH1cbiAgICBfYWRkQWxnb3JpdGhtKGZuKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIGN0eC5hbGdvcml0aG0gPSBjb21iaW5lKGN0eC5hbGdvcml0aG0sIGZuKTtcbiAgICB9XG4gICAgX2l0ZXJhdGUoZm4sIGNvcmVUcmFucykge1xuICAgICAgICByZXR1cm4gaXRlcih0aGlzLl9jdHgsIGZuLCBjb3JlVHJhbnMsIHRoaXMuX2N0eC50YWJsZS5jb3JlKTtcbiAgICB9XG4gICAgY2xvbmUocHJvcHMpIHtcbiAgICAgICAgdmFyIHJ2ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSksIGN0eCA9IE9iamVjdC5jcmVhdGUodGhpcy5fY3R4KTtcbiAgICAgICAgaWYgKHByb3BzKVxuICAgICAgICAgICAgZXh0ZW5kKGN0eCwgcHJvcHMpO1xuICAgICAgICBydi5fY3R4ID0gY3R4O1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIHJhdygpIHtcbiAgICAgICAgdGhpcy5fY3R4LnZhbHVlTWFwcGVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGVhY2goZm4pIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQodHJhbnMgPT4gaXRlcihjdHgsIGZuLCB0cmFucywgY3R4LnRhYmxlLmNvcmUpKTtcbiAgICB9XG4gICAgY291bnQoY2IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQodHJhbnMgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgY29uc3QgY29yZVRhYmxlID0gY3R4LnRhYmxlLmNvcmU7XG4gICAgICAgICAgICBpZiAoaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZVRhYmxlLmNvdW50KHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogZ2V0SW5kZXhPclN0b3JlKGN0eCwgY29yZVRhYmxlLnNjaGVtYSksXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS50aGVuKGNvdW50ID0+IE1hdGgubWluKGNvdW50LCBjdHgubGltaXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXIoY3R4LCAoKSA9PiB7ICsrY291bnQ7IHJldHVybiBmYWxzZTsgfSwgdHJhbnMsIGNvcmVUYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gY291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKGNiKTtcbiAgICB9XG4gICAgc29ydEJ5KGtleVBhdGgsIGNiKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0ga2V5UGF0aC5zcGxpdCgnLicpLnJldmVyc2UoKSwgbGFzdFBhcnQgPSBwYXJ0c1swXSwgbGFzdEluZGV4ID0gcGFydHMubGVuZ3RoIC0gMTtcbiAgICAgICAgZnVuY3Rpb24gZ2V0dmFsKG9iaiwgaSkge1xuICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldHZhbChvYmpbcGFydHNbaV1dLCBpIC0gMSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqW2xhc3RQYXJ0XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3JkZXIgPSB0aGlzLl9jdHguZGlyID09PSBcIm5leHRcIiA/IDEgOiAtMTtcbiAgICAgICAgZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBhVmFsID0gZ2V0dmFsKGEsIGxhc3RJbmRleCksIGJWYWwgPSBnZXR2YWwoYiwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBhVmFsIDwgYlZhbCA/IC1vcmRlciA6IGFWYWwgPiBiVmFsID8gb3JkZXIgOiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnNvcnQoc29ydGVyKTtcbiAgICAgICAgfSkudGhlbihjYik7XG4gICAgfVxuICAgIHRvQXJyYXkoY2IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQodHJhbnMgPT4ge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICAgIGlmIChjdHguZGlyID09PSAnbmV4dCcgJiYgaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkgJiYgY3R4LmxpbWl0ID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWVNYXBwZXIgfSA9IGN0eDtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4T3JTdG9yZShjdHgsIGN0eC50YWJsZS5jb3JlLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0OiBjdHgubGltaXQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkudGhlbigoeyByZXN1bHQgfSkgPT4gdmFsdWVNYXBwZXIgPyByZXN1bHQubWFwKHZhbHVlTWFwcGVyKSA6IHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXIoY3R4LCBpdGVtID0+IGEucHVzaChpdGVtKSwgdHJhbnMsIGN0eC50YWJsZS5jb3JlKS50aGVuKCgpID0+IGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBjYik7XG4gICAgfVxuICAgIG9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgaWYgKG9mZnNldCA8PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGN0eC5vZmZzZXQgKz0gb2Zmc2V0O1xuICAgICAgICBpZiAoaXNQbGFpbktleVJhbmdlKGN0eCkpIHtcbiAgICAgICAgICAgIGFkZFJlcGxheUZpbHRlcihjdHgsICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGN1cnNvciwgYWR2YW5jZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0TGVmdCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0TGVmdCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLS1vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmFkdmFuY2Uob2Zmc2V0TGVmdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZGRSZXBsYXlGaWx0ZXIoY3R4LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldExlZnQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+ICgtLW9mZnNldExlZnQgPCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBsaW1pdChudW1Sb3dzKSB7XG4gICAgICAgIHRoaXMuX2N0eC5saW1pdCA9IE1hdGgubWluKHRoaXMuX2N0eC5saW1pdCwgbnVtUm93cyk7XG4gICAgICAgIGFkZFJlcGxheUZpbHRlcih0aGlzLl9jdHgsICgpID0+IHtcbiAgICAgICAgICAgIHZhciByb3dzTGVmdCA9IG51bVJvd3M7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGlmICgtLXJvd3NMZWZ0IDw9IDApXG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvd3NMZWZ0ID49IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVudGlsKGZpbHRlckZ1bmN0aW9uLCBiSW5jbHVkZVN0b3BFbnRyeSkge1xuICAgICAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyRnVuY3Rpb24oY3Vyc29yLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJJbmNsdWRlU3RvcEVudHJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmlyc3QoY2IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGltaXQoMSkudG9BcnJheShmdW5jdGlvbiAoYSkgeyByZXR1cm4gYVswXTsgfSkudGhlbihjYik7XG4gICAgfVxuICAgIGxhc3QoY2IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpcnN0KGNiKTtcbiAgICB9XG4gICAgZmlsdGVyKGZpbHRlckZ1bmN0aW9uKSB7XG4gICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJGdW5jdGlvbihjdXJzb3IudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgYWRkTWF0Y2hGaWx0ZXIodGhpcy5fY3R4LCBmaWx0ZXJGdW5jdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhbmQoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmaWx0ZXIpO1xuICAgIH1cbiAgICBvcihpbmRleE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMuX2N0eC50YWJsZSwgaW5kZXhOYW1lLCB0aGlzKTtcbiAgICB9XG4gICAgcmV2ZXJzZSgpIHtcbiAgICAgICAgdGhpcy5fY3R4LmRpciA9ICh0aGlzLl9jdHguZGlyID09PSBcInByZXZcIiA/IFwibmV4dFwiIDogXCJwcmV2XCIpO1xuICAgICAgICBpZiAodGhpcy5fb25kaXJlY3Rpb25jaGFuZ2UpXG4gICAgICAgICAgICB0aGlzLl9vbmRpcmVjdGlvbmNoYW5nZSh0aGlzLl9jdHguZGlyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlc2MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgZWFjaEtleShjYikge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHZhbCwgY3Vyc29yKSB7IGNiKGN1cnNvci5rZXksIGN1cnNvcik7IH0pO1xuICAgIH1cbiAgICBlYWNoVW5pcXVlS2V5KGNiKSB7XG4gICAgICAgIHRoaXMuX2N0eC51bmlxdWUgPSBcInVuaXF1ZVwiO1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoS2V5KGNiKTtcbiAgICB9XG4gICAgZWFjaFByaW1hcnlLZXkoY2IpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2YWwsIGN1cnNvcikgeyBjYihjdXJzb3IucHJpbWFyeUtleSwgY3Vyc29yKTsgfSk7XG4gICAgfVxuICAgIGtleXMoY2IpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpdGVtLCBjdXJzb3IpIHtcbiAgICAgICAgICAgIGEucHVzaChjdXJzb3Iua2V5KTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSkudGhlbihjYik7XG4gICAgfVxuICAgIHByaW1hcnlLZXlzKGNiKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIGlmIChjdHguZGlyID09PSAnbmV4dCcgJiYgaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkgJiYgY3R4LmxpbWl0ID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQodHJhbnMgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4T3JTdG9yZShjdHgsIGN0eC50YWJsZS5jb3JlLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0OiBjdHgubGltaXQsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkudGhlbigoeyByZXN1bHQgfSkgPT4gcmVzdWx0KS50aGVuKGNiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgICAgIHZhciBhID0gW107XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGl0ZW0sIGN1cnNvcikge1xuICAgICAgICAgICAgYS5wdXNoKGN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSkudGhlbihjYik7XG4gICAgfVxuICAgIHVuaXF1ZUtleXMoY2IpIHtcbiAgICAgICAgdGhpcy5fY3R4LnVuaXF1ZSA9IFwidW5pcXVlXCI7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMoY2IpO1xuICAgIH1cbiAgICBmaXJzdEtleShjYikge1xuICAgICAgICByZXR1cm4gdGhpcy5saW1pdCgxKS5rZXlzKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWzBdOyB9KS50aGVuKGNiKTtcbiAgICB9XG4gICAgbGFzdEtleShjYikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmlyc3RLZXkoY2IpO1xuICAgIH1cbiAgICBkaXN0aW5jdCgpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eCwgaWR4ID0gY3R4LmluZGV4ICYmIGN0eC50YWJsZS5zY2hlbWEuaWR4QnlOYW1lW2N0eC5pbmRleF07XG4gICAgICAgIGlmICghaWR4IHx8ICFpZHgubXVsdGkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdmFyIHNldCA9IHt9O1xuICAgICAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yKSB7XG4gICAgICAgICAgICB2YXIgc3RyS2V5ID0gY3Vyc29yLnByaW1hcnlLZXkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IGhhc093bihzZXQsIHN0cktleSk7XG4gICAgICAgICAgICBzZXRbc3RyS2V5XSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gIWZvdW5kO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG1vZGlmeShjaGFuZ2VzKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZSh0cmFucyA9PiB7XG4gICAgICAgICAgICB2YXIgbW9kaWZ5ZXI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoYW5nZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBtb2RpZnllciA9IGNoYW5nZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5UGF0aHMgPSBrZXlzKGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIHZhciBudW1LZXlzID0ga2V5UGF0aHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG1vZGlmeWVyID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFueXRoaW5nTW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1LZXlzOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoID0ga2V5UGF0aHNbaV0sIHZhbCA9IGNoYW5nZXNba2V5UGF0aF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0QnlLZXlQYXRoKGl0ZW0sIGtleVBhdGgpICE9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgoaXRlbSwga2V5UGF0aCwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnl0aGluZ01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW55dGhpbmdNb2RpZmllZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29yZVRhYmxlID0gY3R4LnRhYmxlLmNvcmU7XG4gICAgICAgICAgICBjb25zdCB7IG91dGJvdW5kLCBleHRyYWN0S2V5IH0gPSBjb3JlVGFibGUuc2NoZW1hLnByaW1hcnlLZXk7XG4gICAgICAgICAgICBjb25zdCBsaW1pdCA9IHRoaXMuZGIuX29wdGlvbnMubW9kaWZ5Q2h1bmtTaXplIHx8IDIwMDtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsRmFpbHVyZXMgPSBbXTtcbiAgICAgICAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgICAgICAgY29uc3QgZmFpbGVkS2V5cyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYXBwbHlNdXRhdGVSZXN1bHQgPSAoZXhwZWN0ZWRDb3VudCwgcmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBmYWlsdXJlcywgbnVtRmFpbHVyZXMgfSA9IHJlcztcbiAgICAgICAgICAgICAgICBzdWNjZXNzQ291bnQgKz0gZXhwZWN0ZWRDb3VudCAtIG51bUZhaWx1cmVzO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBrZXlzKGZhaWx1cmVzKSkge1xuICAgICAgICAgICAgICAgICAgICB0b3RhbEZhaWx1cmVzLnB1c2goZmFpbHVyZXNbcG9zXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkucHJpbWFyeUtleXMoKS50aGVuKGtleXMgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaHVuayA9IChvZmZzZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBNYXRoLm1pbihsaW1pdCwga2V5cy5sZW5ndGggLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZVRhYmxlLmdldE1hbnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBrZXlzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY291bnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IFwiaW1tdXRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbih2YWx1ZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkVmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwdXRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHB1dEtleXMgPSBvdXRib3VuZCA/IFtdIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGV0ZUtleXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdWYWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkZWVwQ2xvbmUob3JpZ1ZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbUtleToga2V5c1tvZmZzZXQgKyBpXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmeWVyLmNhbGwoY3R4LCBjdHgudmFsdWUsIGN0eCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHgudmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlS2V5cy5wdXNoKGtleXNbb2Zmc2V0ICsgaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFvdXRib3VuZCAmJiBjbXAoZXh0cmFjdEtleShvcmlnVmFsdWUpLCBleHRyYWN0S2V5KGN0eC52YWx1ZSkpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVLZXlzLnB1c2goa2V5c1tvZmZzZXQgKyBpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRWYWx1ZXMucHVzaChjdHgudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0VmFsdWVzLnB1c2goY3R4LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRib3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXRLZXlzLnB1c2goa2V5c1tvZmZzZXQgKyBpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjcml0ZXJpYSA9IGlzUGxhaW5LZXlSYW5nZShjdHgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbWl0ID09PSBJbmZpbml0eSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgY2hhbmdlcyAhPT0gJ2Z1bmN0aW9uJyB8fCBjaGFuZ2VzID09PSBkZWxldGVDYWxsYmFjaykgJiYge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBjdHguaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYWRkVmFsdWVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlVGFibGUubXV0YXRlKHsgdHJhbnMsIHR5cGU6ICdhZGQnLCB2YWx1ZXM6IGFkZFZhbHVlcyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgaW4gcmVzLmZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVLZXlzLnNwbGljZShwYXJzZUludChwb3MpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseU11dGF0ZVJlc3VsdChhZGRWYWx1ZXMubGVuZ3RoLCByZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKCgpID0+IChwdXRWYWx1ZXMubGVuZ3RoID4gMCB8fCAoY3JpdGVyaWEgJiYgdHlwZW9mIGNoYW5nZXMgPT09ICdvYmplY3QnKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlVGFibGUubXV0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBwdXRLZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHB1dFZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JpdGVyaWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVNwZWM6IHR5cGVvZiBjaGFuZ2VzICE9PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihyZXMgPT4gYXBwbHlNdXRhdGVSZXN1bHQocHV0VmFsdWVzLmxlbmd0aCwgcmVzKSkpLnRoZW4oKCkgPT4gKGRlbGV0ZUtleXMubGVuZ3RoID4gMCB8fCAoY3JpdGVyaWEgJiYgY2hhbmdlcyA9PT0gZGVsZXRlQ2FsbGJhY2spKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVUYWJsZS5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RlbGV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IGRlbGV0ZUtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyaXRlcmlhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihyZXMgPT4gYXBwbHlNdXRhdGVSZXN1bHQoZGVsZXRlS2V5cy5sZW5ndGgsIHJlcykpKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5sZW5ndGggPiBvZmZzZXQgKyBjb3VudCAmJiBuZXh0Q2h1bmsob2Zmc2V0ICsgbGltaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRDaHVuaygwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsRmFpbHVyZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNb2RpZnlFcnJvcihcIkVycm9yIG1vZGlmeWluZyBvbmUgb3IgbW9yZSBvYmplY3RzXCIsIHRvdGFsRmFpbHVyZXMsIHN1Y2Nlc3NDb3VudCwgZmFpbGVkS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVsZXRlKCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LCByYW5nZSA9IGN0eC5yYW5nZTtcbiAgICAgICAgaWYgKGlzUGxhaW5LZXlSYW5nZShjdHgpICYmXG4gICAgICAgICAgICAoKGN0eC5pc1ByaW1LZXkgJiYgIWhhbmdzT25EZWxldGVMYXJnZUtleVJhbmdlKSB8fCByYW5nZS50eXBlID09PSAzICkpXG4gICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGUodHJhbnMgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJpbWFyeUtleSB9ID0gY3R4LnRhYmxlLmNvcmUuc2NoZW1hO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvcmVSYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5jb3VudCh7IHRyYW5zLCBxdWVyeTogeyBpbmRleDogcHJpbWFyeUtleSwgcmFuZ2U6IGNvcmVSYW5nZSB9IH0pLnRoZW4oY291bnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUubXV0YXRlKHsgdHJhbnMsIHR5cGU6ICdkZWxldGVSYW5nZScsIHJhbmdlOiBjb3JlUmFuZ2UgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCh7IGZhaWx1cmVzLCBsYXN0UmVzdWx0LCByZXN1bHRzLCBudW1GYWlsdXJlcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1vZGlmeUVycm9yKFwiQ291bGQgbm90IGRlbGV0ZSBzb21lIHZhbHVlc1wiLCBPYmplY3Qua2V5cyhmYWlsdXJlcykubWFwKHBvcyA9PiBmYWlsdXJlc1twb3NdKSwgY291bnQgLSBudW1GYWlsdXJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY291bnQgLSBudW1GYWlsdXJlcztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tb2RpZnkoZGVsZXRlQ2FsbGJhY2spO1xuICAgIH1cbn1cbmNvbnN0IGRlbGV0ZUNhbGxiYWNrID0gKHZhbHVlLCBjdHgpID0+IGN0eC52YWx1ZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbGxlY3Rpb25Db25zdHJ1Y3RvcihkYikge1xuICAgIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcihDb2xsZWN0aW9uLnByb3RvdHlwZSwgZnVuY3Rpb24gQ29sbGVjdGlvbih3aGVyZUNsYXVzZSwga2V5UmFuZ2VHZW5lcmF0b3IpIHtcbiAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICBsZXQga2V5UmFuZ2UgPSBBbnlSYW5nZSwgZXJyb3IgPSBudWxsO1xuICAgICAgICBpZiAoa2V5UmFuZ2VHZW5lcmF0b3IpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGtleVJhbmdlID0ga2V5UmFuZ2VHZW5lcmF0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdoZXJlQ3R4ID0gd2hlcmVDbGF1c2UuX2N0eDtcbiAgICAgICAgY29uc3QgdGFibGUgPSB3aGVyZUN0eC50YWJsZTtcbiAgICAgICAgY29uc3QgcmVhZGluZ0hvb2sgPSB0YWJsZS5ob29rLnJlYWRpbmcuZmlyZTtcbiAgICAgICAgdGhpcy5fY3R4ID0ge1xuICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICAgICAgaW5kZXg6IHdoZXJlQ3R4LmluZGV4LFxuICAgICAgICAgICAgaXNQcmltS2V5OiAoIXdoZXJlQ3R4LmluZGV4IHx8ICh0YWJsZS5zY2hlbWEucHJpbUtleS5rZXlQYXRoICYmIHdoZXJlQ3R4LmluZGV4ID09PSB0YWJsZS5zY2hlbWEucHJpbUtleS5uYW1lKSksXG4gICAgICAgICAgICByYW5nZToga2V5UmFuZ2UsXG4gICAgICAgICAgICBrZXlzT25seTogZmFsc2UsXG4gICAgICAgICAgICBkaXI6IFwibmV4dFwiLFxuICAgICAgICAgICAgdW5pcXVlOiBcIlwiLFxuICAgICAgICAgICAgYWxnb3JpdGhtOiBudWxsLFxuICAgICAgICAgICAgZmlsdGVyOiBudWxsLFxuICAgICAgICAgICAgcmVwbGF5RmlsdGVyOiBudWxsLFxuICAgICAgICAgICAganVzdExpbWl0OiB0cnVlLFxuICAgICAgICAgICAgaXNNYXRjaDogbnVsbCxcbiAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICAgIGxpbWl0OiBJbmZpbml0eSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIG9yOiB3aGVyZUN0eC5vcixcbiAgICAgICAgICAgIHZhbHVlTWFwcGVyOiByZWFkaW5nSG9vayAhPT0gbWlycm9yID8gcmVhZGluZ0hvb2sgOiBudWxsXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUNvbXBhcmUoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA9PT0gYiA/IDAgOiAxO1xufVxuZnVuY3Rpb24gc2ltcGxlQ29tcGFyZVJldmVyc2UoYSwgYikge1xuICAgIHJldHVybiBhID4gYiA/IC0xIDogYSA9PT0gYiA/IDAgOiAxO1xufVxuXG5mdW5jdGlvbiBmYWlsKGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlLCBlcnIsIFQpIHtcbiAgICB2YXIgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlIGluc3RhbmNlb2YgV2hlcmVDbGF1c2UgP1xuICAgICAgICBuZXcgY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UuQ29sbGVjdGlvbihjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZSkgOlxuICAgICAgICBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZTtcbiAgICBjb2xsZWN0aW9uLl9jdHguZXJyb3IgPSBUID8gbmV3IFQoZXJyKSA6IG5ldyBUeXBlRXJyb3IoZXJyKTtcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbn1cbmZ1bmN0aW9uIGVtcHR5Q29sbGVjdGlvbih3aGVyZUNsYXVzZSkge1xuICAgIHJldHVybiBuZXcgd2hlcmVDbGF1c2UuQ29sbGVjdGlvbih3aGVyZUNsYXVzZSwgKCkgPT4gcmFuZ2VFcXVhbChcIlwiKSkubGltaXQoMCk7XG59XG5mdW5jdGlvbiB1cHBlckZhY3RvcnkoZGlyKSB7XG4gICAgcmV0dXJuIGRpciA9PT0gXCJuZXh0XCIgP1xuICAgICAgICAocykgPT4gcy50b1VwcGVyQ2FzZSgpIDpcbiAgICAgICAgKHMpID0+IHMudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGxvd2VyRmFjdG9yeShkaXIpIHtcbiAgICByZXR1cm4gZGlyID09PSBcIm5leHRcIiA/XG4gICAgICAgIChzKSA9PiBzLnRvTG93ZXJDYXNlKCkgOlxuICAgICAgICAocykgPT4gcy50b1VwcGVyQ2FzZSgpO1xufVxuZnVuY3Rpb24gbmV4dENhc2luZyhrZXksIGxvd2VyS2V5LCB1cHBlck5lZWRsZSwgbG93ZXJOZWVkbGUsIGNtcCwgZGlyKSB7XG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGtleS5sZW5ndGgsIGxvd2VyTmVlZGxlLmxlbmd0aCk7XG4gICAgdmFyIGxscCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGx3cktleUNoYXIgPSBsb3dlcktleVtpXTtcbiAgICAgICAgaWYgKGx3cktleUNoYXIgIT09IGxvd2VyTmVlZGxlW2ldKSB7XG4gICAgICAgICAgICBpZiAoY21wKGtleVtpXSwgdXBwZXJOZWVkbGVbaV0pIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCBpKSArIHVwcGVyTmVlZGxlW2ldICsgdXBwZXJOZWVkbGUuc3Vic3RyKGkgKyAxKTtcbiAgICAgICAgICAgIGlmIChjbXAoa2V5W2ldLCBsb3dlck5lZWRsZVtpXSkgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIGkpICsgbG93ZXJOZWVkbGVbaV0gKyB1cHBlck5lZWRsZS5zdWJzdHIoaSArIDEpO1xuICAgICAgICAgICAgaWYgKGxscCA+PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIGxscCkgKyBsb3dlcktleVtsbHBdICsgdXBwZXJOZWVkbGUuc3Vic3RyKGxscCArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNtcChrZXlbaV0sIGx3cktleUNoYXIpIDwgMClcbiAgICAgICAgICAgIGxscCA9IGk7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCBsb3dlck5lZWRsZS5sZW5ndGggJiYgZGlyID09PSBcIm5leHRcIilcbiAgICAgICAgcmV0dXJuIGtleSArIHVwcGVyTmVlZGxlLnN1YnN0cihrZXkubGVuZ3RoKTtcbiAgICBpZiAobGVuZ3RoIDwga2V5Lmxlbmd0aCAmJiBkaXIgPT09IFwicHJldlwiKVxuICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCB1cHBlck5lZWRsZS5sZW5ndGgpO1xuICAgIHJldHVybiAobGxwIDwgMCA/IG51bGwgOiBrZXkuc3Vic3RyKDAsIGxscCkgKyBsb3dlck5lZWRsZVtsbHBdICsgdXBwZXJOZWVkbGUuc3Vic3RyKGxscCArIDEpKTtcbn1cbmZ1bmN0aW9uIGFkZElnbm9yZUNhc2VBbGdvcml0aG0od2hlcmVDbGF1c2UsIG1hdGNoLCBuZWVkbGVzLCBzdWZmaXgpIHtcbiAgICB2YXIgdXBwZXIsIGxvd2VyLCBjb21wYXJlLCB1cHBlck5lZWRsZXMsIGxvd2VyTmVlZGxlcywgZGlyZWN0aW9uLCBuZXh0S2V5U3VmZml4LCBuZWVkbGVzTGVuID0gbmVlZGxlcy5sZW5ndGg7XG4gICAgaWYgKCFuZWVkbGVzLmV2ZXJ5KHMgPT4gdHlwZW9mIHMgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICByZXR1cm4gZmFpbCh3aGVyZUNsYXVzZSwgU1RSSU5HX0VYUEVDVEVEKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdERpcmVjdGlvbihkaXIpIHtcbiAgICAgICAgdXBwZXIgPSB1cHBlckZhY3RvcnkoZGlyKTtcbiAgICAgICAgbG93ZXIgPSBsb3dlckZhY3RvcnkoZGlyKTtcbiAgICAgICAgY29tcGFyZSA9IChkaXIgPT09IFwibmV4dFwiID8gc2ltcGxlQ29tcGFyZSA6IHNpbXBsZUNvbXBhcmVSZXZlcnNlKTtcbiAgICAgICAgdmFyIG5lZWRsZUJvdW5kcyA9IG5lZWRsZXMubWFwKGZ1bmN0aW9uIChuZWVkbGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxvd2VyOiBsb3dlcihuZWVkbGUpLCB1cHBlcjogdXBwZXIobmVlZGxlKSB9O1xuICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZShhLmxvd2VyLCBiLmxvd2VyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHVwcGVyTmVlZGxlcyA9IG5lZWRsZUJvdW5kcy5tYXAoZnVuY3Rpb24gKG5iKSB7IHJldHVybiBuYi51cHBlcjsgfSk7XG4gICAgICAgIGxvd2VyTmVlZGxlcyA9IG5lZWRsZUJvdW5kcy5tYXAoZnVuY3Rpb24gKG5iKSB7IHJldHVybiBuYi5sb3dlcjsgfSk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGRpcjtcbiAgICAgICAgbmV4dEtleVN1ZmZpeCA9IChkaXIgPT09IFwibmV4dFwiID8gXCJcIiA6IHN1ZmZpeCk7XG4gICAgfVxuICAgIGluaXREaXJlY3Rpb24oXCJuZXh0XCIpO1xuICAgIHZhciBjID0gbmV3IHdoZXJlQ2xhdXNlLkNvbGxlY3Rpb24od2hlcmVDbGF1c2UsICgpID0+IGNyZWF0ZVJhbmdlKHVwcGVyTmVlZGxlc1swXSwgbG93ZXJOZWVkbGVzW25lZWRsZXNMZW4gLSAxXSArIHN1ZmZpeCkpO1xuICAgIGMuX29uZGlyZWN0aW9uY2hhbmdlID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICBpbml0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgfTtcbiAgICB2YXIgZmlyc3RQb3NzaWJsZU5lZWRsZSA9IDA7XG4gICAgYy5fYWRkQWxnb3JpdGhtKGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgICAgdmFyIGtleSA9IGN1cnNvci5rZXk7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGxvd2VyS2V5ID0gbG93ZXIoa2V5KTtcbiAgICAgICAgaWYgKG1hdGNoKGxvd2VyS2V5LCBsb3dlck5lZWRsZXMsIGZpcnN0UG9zc2libGVOZWVkbGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsb3dlc3RQb3NzaWJsZUNhc2luZyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZmlyc3RQb3NzaWJsZU5lZWRsZTsgaSA8IG5lZWRsZXNMZW47ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBjYXNpbmcgPSBuZXh0Q2FzaW5nKGtleSwgbG93ZXJLZXksIHVwcGVyTmVlZGxlc1tpXSwgbG93ZXJOZWVkbGVzW2ldLCBjb21wYXJlLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmIChjYXNpbmcgPT09IG51bGwgJiYgbG93ZXN0UG9zc2libGVDYXNpbmcgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UG9zc2libGVOZWVkbGUgPSBpICsgMTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb3dlc3RQb3NzaWJsZUNhc2luZyA9PT0gbnVsbCB8fCBjb21wYXJlKGxvd2VzdFBvc3NpYmxlQ2FzaW5nLCBjYXNpbmcpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsb3dlc3RQb3NzaWJsZUNhc2luZyA9IGNhc2luZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG93ZXN0UG9zc2libGVDYXNpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlKGZ1bmN0aW9uICgpIHsgY3Vyc29yLmNvbnRpbnVlKGxvd2VzdFBvc3NpYmxlQ2FzaW5nICsgbmV4dEtleVN1ZmZpeCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjO1xufVxuZnVuY3Rpb24gY3JlYXRlUmFuZ2UobG93ZXIsIHVwcGVyLCBsb3dlck9wZW4sIHVwcGVyT3Blbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDIgLFxuICAgICAgICBsb3dlcixcbiAgICAgICAgdXBwZXIsXG4gICAgICAgIGxvd2VyT3BlbixcbiAgICAgICAgdXBwZXJPcGVuXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJhbmdlRXF1YWwodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAxICxcbiAgICAgICAgbG93ZXI6IHZhbHVlLFxuICAgICAgICB1cHBlcjogdmFsdWVcbiAgICB9O1xufVxuXG5jbGFzcyBXaGVyZUNsYXVzZSB7XG4gICAgZ2V0IENvbGxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdHgudGFibGUuZGIuQ29sbGVjdGlvbjtcbiAgICB9XG4gICAgYmV0d2Vlbihsb3dlciwgdXBwZXIsIGluY2x1ZGVMb3dlciwgaW5jbHVkZVVwcGVyKSB7XG4gICAgICAgIGluY2x1ZGVMb3dlciA9IGluY2x1ZGVMb3dlciAhPT0gZmFsc2U7XG4gICAgICAgIGluY2x1ZGVVcHBlciA9IGluY2x1ZGVVcHBlciA9PT0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICgodGhpcy5fY21wKGxvd2VyLCB1cHBlcikgPiAwKSB8fFxuICAgICAgICAgICAgICAgICh0aGlzLl9jbXAobG93ZXIsIHVwcGVyKSA9PT0gMCAmJiAoaW5jbHVkZUxvd2VyIHx8IGluY2x1ZGVVcHBlcikgJiYgIShpbmNsdWRlTG93ZXIgJiYgaW5jbHVkZVVwcGVyKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IGNyZWF0ZVJhbmdlKGxvd2VyLCB1cHBlciwgIWluY2x1ZGVMb3dlciwgIWluY2x1ZGVVcHBlcikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXF1YWxzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiByYW5nZUVxdWFsKHZhbHVlKSk7XG4gICAgfVxuICAgIGFib3ZlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZSh2YWx1ZSwgdW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuICAgIGFib3ZlT3JFcXVhbCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gY3JlYXRlUmFuZ2UodmFsdWUsIHVuZGVmaW5lZCwgZmFsc2UpKTtcbiAgICB9XG4gICAgYmVsb3codmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IGNyZWF0ZVJhbmdlKHVuZGVmaW5lZCwgdmFsdWUsIGZhbHNlLCB0cnVlKSk7XG4gICAgfVxuICAgIGJlbG93T3JFcXVhbCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gY3JlYXRlUmFuZ2UodW5kZWZpbmVkLCB2YWx1ZSkpO1xuICAgIH1cbiAgICBzdGFydHNXaXRoKHN0cikge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBTVFJJTkdfRVhQRUNURUQpO1xuICAgICAgICByZXR1cm4gdGhpcy5iZXR3ZWVuKHN0ciwgc3RyICsgbWF4U3RyaW5nLCB0cnVlLCB0cnVlKTtcbiAgICB9XG4gICAgc3RhcnRzV2l0aElnbm9yZUNhc2Uoc3RyKSB7XG4gICAgICAgIGlmIChzdHIgPT09IFwiXCIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydHNXaXRoKHN0cik7XG4gICAgICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsICh4LCBhKSA9PiB4LmluZGV4T2YoYVswXSkgPT09IDAsIFtzdHJdLCBtYXhTdHJpbmcpO1xuICAgIH1cbiAgICBlcXVhbHNJZ25vcmVDYXNlKHN0cikge1xuICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCAoeCwgYSkgPT4geCA9PT0gYVswXSwgW3N0cl0sIFwiXCIpO1xuICAgIH1cbiAgICBhbnlPZklnbm9yZUNhc2UoKSB7XG4gICAgICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgKHgsIGEpID0+IGEuaW5kZXhPZih4KSAhPT0gLTEsIHNldCwgXCJcIik7XG4gICAgfVxuICAgIHN0YXJ0c1dpdGhBbnlPZklnbm9yZUNhc2UoKSB7XG4gICAgICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgKHgsIGEpID0+IGEuc29tZShuID0+IHguaW5kZXhPZihuKSA9PT0gMCksIHNldCwgbWF4U3RyaW5nKTtcbiAgICB9XG4gICAgYW55T2YoKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgbGV0IGNvbXBhcmUgPSB0aGlzLl9jbXA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXQuc29ydChjb21wYXJlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgY29uc3QgYyA9IG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gY3JlYXRlUmFuZ2Uoc2V0WzBdLCBzZXRbc2V0Lmxlbmd0aCAtIDFdKSk7XG4gICAgICAgIGMuX29uZGlyZWN0aW9uY2hhbmdlID0gZGlyZWN0aW9uID0+IHtcbiAgICAgICAgICAgIGNvbXBhcmUgPSAoZGlyZWN0aW9uID09PSBcIm5leHRcIiA/XG4gICAgICAgICAgICAgICAgdGhpcy5fYXNjZW5kaW5nIDpcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXNjZW5kaW5nKTtcbiAgICAgICAgICAgIHNldC5zb3J0KGNvbXBhcmUpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGMuX2FkZEFsZ29yaXRobSgoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBjdXJzb3Iua2V5O1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoa2V5LCBzZXRbaV0pID4gMCkge1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gc2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbXBhcmUoa2V5LCBzZXRbaV0pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlKCgpID0+IHsgY3Vyc29yLmNvbnRpbnVlKHNldFtpXSk7IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBub3RFcXVhbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbkFueVJhbmdlKFtbbWluS2V5LCB2YWx1ZV0sIFt2YWx1ZSwgdGhpcy5kYi5fbWF4S2V5XV0sIHsgaW5jbHVkZUxvd2VyczogZmFsc2UsIGluY2x1ZGVVcHBlcnM6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBub25lT2YoKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldC5zb3J0KHRoaXMuX2FzY2VuZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYW5nZXMgPSBzZXQucmVkdWNlKChyZXMsIHZhbCkgPT4gcmVzID9cbiAgICAgICAgICAgIHJlcy5jb25jYXQoW1tyZXNbcmVzLmxlbmd0aCAtIDFdWzFdLCB2YWxdXSkgOlxuICAgICAgICAgICAgW1ttaW5LZXksIHZhbF1dLCBudWxsKTtcbiAgICAgICAgcmFuZ2VzLnB1c2goW3NldFtzZXQubGVuZ3RoIC0gMV0sIHRoaXMuZGIuX21heEtleV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5pbkFueVJhbmdlKHJhbmdlcywgeyBpbmNsdWRlTG93ZXJzOiBmYWxzZSwgaW5jbHVkZVVwcGVyczogZmFsc2UgfSk7XG4gICAgfVxuICAgIGluQW55UmFuZ2UocmFuZ2VzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNtcCA9IHRoaXMuX2NtcCwgYXNjZW5kaW5nID0gdGhpcy5fYXNjZW5kaW5nLCBkZXNjZW5kaW5nID0gdGhpcy5fZGVzY2VuZGluZywgbWluID0gdGhpcy5fbWluLCBtYXggPSB0aGlzLl9tYXg7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgaWYgKCFyYW5nZXMuZXZlcnkocmFuZ2UgPT4gcmFuZ2VbMF0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgcmFuZ2VbMV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgYXNjZW5kaW5nKHJhbmdlWzBdLCByYW5nZVsxXSkgPD0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFwiRmlyc3QgYXJndW1lbnQgdG8gaW5BbnlSYW5nZSgpIG11c3QgYmUgYW4gQXJyYXkgb2YgdHdvLXZhbHVlIEFycmF5cyBbbG93ZXIsdXBwZXJdIHdoZXJlIHVwcGVyIG11c3Qgbm90IGJlIGxvd2VyIHRoYW4gbG93ZXJcIiwgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluY2x1ZGVMb3dlcnMgPSAhb3B0aW9ucyB8fCBvcHRpb25zLmluY2x1ZGVMb3dlcnMgIT09IGZhbHNlO1xuICAgICAgICBjb25zdCBpbmNsdWRlVXBwZXJzID0gb3B0aW9ucyAmJiBvcHRpb25zLmluY2x1ZGVVcHBlcnMgPT09IHRydWU7XG4gICAgICAgIGZ1bmN0aW9uIGFkZFJhbmdlKHJhbmdlcywgbmV3UmFuZ2UpIHtcbiAgICAgICAgICAgIGxldCBpID0gMCwgbCA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjbXAobmV3UmFuZ2VbMF0sIHJhbmdlWzFdKSA8IDAgJiYgY21wKG5ld1JhbmdlWzFdLCByYW5nZVswXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlWzBdID0gbWluKHJhbmdlWzBdLCBuZXdSYW5nZVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlWzFdID0gbWF4KHJhbmdlWzFdLCBuZXdSYW5nZVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSBsKVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKG5ld1JhbmdlKTtcbiAgICAgICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNvcnREaXJlY3Rpb24gPSBhc2NlbmRpbmc7XG4gICAgICAgIGZ1bmN0aW9uIHJhbmdlU29ydGVyKGEsIGIpIHsgcmV0dXJuIHNvcnREaXJlY3Rpb24oYVswXSwgYlswXSk7IH1cbiAgICAgICAgbGV0IHNldDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldCA9IHJhbmdlcy5yZWR1Y2UoYWRkUmFuZ2UsIFtdKTtcbiAgICAgICAgICAgIHNldC5zb3J0KHJhbmdlU29ydGVyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmFuZ2VQb3MgPSAwO1xuICAgICAgICBjb25zdCBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeSA9IGluY2x1ZGVVcHBlcnMgP1xuICAgICAgICAgICAga2V5ID0+IGFzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMV0pID4gMCA6XG4gICAgICAgICAgICBrZXkgPT4gYXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVsxXSkgPj0gMDtcbiAgICAgICAgY29uc3Qga2V5SXNCZWZvcmVDdXJyZW50RW50cnkgPSBpbmNsdWRlTG93ZXJzID9cbiAgICAgICAgICAgIGtleSA9PiBkZXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVswXSkgPiAwIDpcbiAgICAgICAgICAgIGtleSA9PiBkZXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVswXSkgPj0gMDtcbiAgICAgICAgZnVuY3Rpb24ga2V5V2l0aGluQ3VycmVudFJhbmdlKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuICFrZXlJc0JleW9uZEN1cnJlbnRFbnRyeShrZXkpICYmICFrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGVja0tleSA9IGtleUlzQmV5b25kQ3VycmVudEVudHJ5O1xuICAgICAgICBjb25zdCBjID0gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZShzZXRbMF1bMF0sIHNldFtzZXQubGVuZ3RoIC0gMV1bMV0sICFpbmNsdWRlTG93ZXJzLCAhaW5jbHVkZVVwcGVycykpO1xuICAgICAgICBjLl9vbmRpcmVjdGlvbmNoYW5nZSA9IGRpcmVjdGlvbiA9PiB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAgIGNoZWNrS2V5ID0ga2V5SXNCZXlvbmRDdXJyZW50RW50cnk7XG4gICAgICAgICAgICAgICAgc29ydERpcmVjdGlvbiA9IGFzY2VuZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrS2V5ID0ga2V5SXNCZWZvcmVDdXJyZW50RW50cnk7XG4gICAgICAgICAgICAgICAgc29ydERpcmVjdGlvbiA9IGRlc2NlbmRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXQuc29ydChyYW5nZVNvcnRlcik7XG4gICAgICAgIH07XG4gICAgICAgIGMuX2FkZEFsZ29yaXRobSgoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB2YXIga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgICAgICAgIHdoaWxlIChjaGVja0tleShrZXkpKSB7XG4gICAgICAgICAgICAgICAgKytyYW5nZVBvcztcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VQb3MgPT09IHNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlXaXRoaW5DdXJyZW50UmFuZ2Uoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fY21wKGtleSwgc2V0W3JhbmdlUG9zXVsxXSkgPT09IDAgfHwgdGhpcy5fY21wKGtleSwgc2V0W3JhbmdlUG9zXVswXSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnREaXJlY3Rpb24gPT09IGFzY2VuZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShzZXRbcmFuZ2VQb3NdWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKHNldFtyYW5nZVBvc11bMV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBzdGFydHNXaXRoQW55T2YoKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKCFzZXQuZXZlcnkocyA9PiB0eXBlb2YgcyA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBcInN0YXJ0c1dpdGhBbnlPZigpIG9ubHkgd29ya3Mgd2l0aCBzdHJpbmdzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShzZXQubWFwKChzdHIpID0+IFtzdHIsIHN0ciArIG1heFN0cmluZ10pKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdoZXJlQ2xhdXNlQ29uc3RydWN0b3IoZGIpIHtcbiAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoV2hlcmVDbGF1c2UucHJvdG90eXBlLCBmdW5jdGlvbiBXaGVyZUNsYXVzZSh0YWJsZSwgaW5kZXgsIG9yQ29sbGVjdGlvbikge1xuICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgIHRoaXMuX2N0eCA9IHtcbiAgICAgICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCA9PT0gXCI6aWRcIiA/IG51bGwgOiBpbmRleCxcbiAgICAgICAgICAgIG9yOiBvckNvbGxlY3Rpb25cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaW5kZXhlZERCID0gZGIuX2RlcHMuaW5kZXhlZERCO1xuICAgICAgICBpZiAoIWluZGV4ZWREQilcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKTtcbiAgICAgICAgdGhpcy5fY21wID0gdGhpcy5fYXNjZW5kaW5nID0gaW5kZXhlZERCLmNtcC5iaW5kKGluZGV4ZWREQik7XG4gICAgICAgIHRoaXMuX2Rlc2NlbmRpbmcgPSAoYSwgYikgPT4gaW5kZXhlZERCLmNtcChiLCBhKTtcbiAgICAgICAgdGhpcy5fbWF4ID0gKGEsIGIpID0+IGluZGV4ZWREQi5jbXAoYSwgYikgPiAwID8gYSA6IGI7XG4gICAgICAgIHRoaXMuX21pbiA9IChhLCBiKSA9PiBpbmRleGVkREIuY21wKGEsIGIpIDwgMCA/IGEgOiBiO1xuICAgICAgICB0aGlzLl9JREJLZXlSYW5nZSA9IGRiLl9kZXBzLklEQktleVJhbmdlO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KSB7XG4gICAgcmV0dXJuIHdyYXAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgcmVqZWN0KGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5jb25zdCBERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSA9ICdzdG9yYWdlbXV0YXRlZCc7XG5jb25zdCBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUgPSAneC1zdG9yYWdlbXV0YXRlZC0xJztcbmNvbnN0IGdsb2JhbEV2ZW50cyA9IEV2ZW50cyhudWxsLCBERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSk7XG5cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgICBfbG9jaygpIHtcbiAgICAgICAgYXNzZXJ0KCFQU0QuZ2xvYmFsKTtcbiAgICAgICAgKyt0aGlzLl9yZWN1bG9jaztcbiAgICAgICAgaWYgKHRoaXMuX3JlY3Vsb2NrID09PSAxICYmICFQU0QuZ2xvYmFsKVxuICAgICAgICAgICAgUFNELmxvY2tPd25lckZvciA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfdW5sb2NrKCkge1xuICAgICAgICBhc3NlcnQoIVBTRC5nbG9iYWwpO1xuICAgICAgICBpZiAoLS10aGlzLl9yZWN1bG9jayA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKCFQU0QuZ2xvYmFsKVxuICAgICAgICAgICAgICAgIFBTRC5sb2NrT3duZXJGb3IgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2Jsb2NrZWRGdW5jcy5sZW5ndGggPiAwICYmICF0aGlzLl9sb2NrZWQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBmbkFuZFBTRCA9IHRoaXMuX2Jsb2NrZWRGdW5jcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZVBTRChmbkFuZFBTRFsxXSwgZm5BbmRQU0RbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIF9sb2NrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWN1bG9jayAmJiBQU0QubG9ja093bmVyRm9yICE9PSB0aGlzO1xuICAgIH1cbiAgICBjcmVhdGUoaWRidHJhbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vZGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgY29uc3QgaWRiZGIgPSB0aGlzLmRiLmlkYmRiO1xuICAgICAgICBjb25zdCBkYk9wZW5FcnJvciA9IHRoaXMuZGIuX3N0YXRlLmRiT3BlbkVycm9yO1xuICAgICAgICBhc3NlcnQoIXRoaXMuaWRidHJhbnMpO1xuICAgICAgICBpZiAoIWlkYnRyYW5zICYmICFpZGJkYikge1xuICAgICAgICAgICAgc3dpdGNoIChkYk9wZW5FcnJvciAmJiBkYk9wZW5FcnJvci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkRhdGFiYXNlQ2xvc2VkRXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoZGJPcGVuRXJyb3IpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJNaXNzaW5nQVBJRXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSShkYk9wZW5FcnJvci5tZXNzYWdlLCBkYk9wZW5FcnJvcik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuT3BlbkZhaWxlZChkYk9wZW5FcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlRyYW5zYWN0aW9uSW5hY3RpdmUoKTtcbiAgICAgICAgYXNzZXJ0KHRoaXMuX2NvbXBsZXRpb24uX3N0YXRlID09PSBudWxsKTtcbiAgICAgICAgaWRidHJhbnMgPSB0aGlzLmlkYnRyYW5zID0gaWRidHJhbnMgfHxcbiAgICAgICAgICAgICh0aGlzLmRiLmNvcmVcbiAgICAgICAgICAgICAgICA/IHRoaXMuZGIuY29yZS50cmFuc2FjdGlvbih0aGlzLnN0b3JlTmFtZXMsIHRoaXMubW9kZSwgeyBkdXJhYmlsaXR5OiB0aGlzLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSB9KVxuICAgICAgICAgICAgICAgIDogaWRiZGIudHJhbnNhY3Rpb24odGhpcy5zdG9yZU5hbWVzLCB0aGlzLm1vZGUsIHsgZHVyYWJpbGl0eTogdGhpcy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHkgfSkpO1xuICAgICAgICBpZGJ0cmFucy5vbmVycm9yID0gd3JhcChldiA9PiB7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldik7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3QoaWRidHJhbnMuZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWRidHJhbnMub25hYm9ydCA9IHdyYXAoZXYgPT4ge1xuICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZXYpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgJiYgdGhpcy5fcmVqZWN0KG5ldyBleGNlcHRpb25zLkFib3J0KGlkYnRyYW5zLmVycm9yKSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vbihcImFib3J0XCIpLmZpcmUoZXYpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWRidHJhbnMub25jb21wbGV0ZSA9IHdyYXAoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUoKTtcbiAgICAgICAgICAgIGlmICgnbXV0YXRlZFBhcnRzJyBpbiBpZGJ0cmFucykge1xuICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC5maXJlKGlkYnRyYW5zW1wibXV0YXRlZFBhcnRzXCJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfcHJvbWlzZShtb2RlLCBmbiwgYldyaXRlTG9jaykge1xuICAgICAgICBpZiAobW9kZSA9PT0gJ3JlYWR3cml0ZScgJiYgdGhpcy5tb2RlICE9PSAncmVhZHdyaXRlJylcbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuUmVhZE9ubHkoXCJUcmFuc2FjdGlvbiBpcyByZWFkb25seVwiKSk7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLlRyYW5zYWN0aW9uSW5hY3RpdmUoKSk7XG4gICAgICAgIGlmICh0aGlzLl9sb2NrZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2NrZWRGdW5jcy5wdXNoKFsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlKG1vZGUsIGZuLCBiV3JpdGVMb2NrKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIFBTRF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYldyaXRlTG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ2ID0gZm4ocmVzb2x2ZSwgcmVqZWN0LCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ2ICYmIHJ2LnRoZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBydi50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcC5maW5hbGx5KCgpID0+IHRoaXMuX3VubG9jaygpKTtcbiAgICAgICAgICAgICAgICBwLl9saWIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcCA9IG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBydiA9IGZuKHJlc29sdmUsIHJlamVjdCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJ2ICYmIHJ2LnRoZW4pXG4gICAgICAgICAgICAgICAgICAgIHJ2LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcC5fbGliID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5fcm9vdCgpIDogdGhpcztcbiAgICB9XG4gICAgd2FpdEZvcihwcm9taXNlTGlrZSkge1xuICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3QoKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IERleGllUHJvbWlzZS5yZXNvbHZlKHByb21pc2VMaWtlKTtcbiAgICAgICAgaWYgKHJvb3QuX3dhaXRpbmdGb3IpIHtcbiAgICAgICAgICAgIHJvb3QuX3dhaXRpbmdGb3IgPSByb290Ll93YWl0aW5nRm9yLnRoZW4oKCkgPT4gcHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb290Ll93YWl0aW5nRm9yID0gcHJvbWlzZTtcbiAgICAgICAgICAgIHJvb3QuX3dhaXRpbmdRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgdmFyIHN0b3JlID0gcm9vdC5pZGJ0cmFucy5vYmplY3RTdG9yZShyb290LnN0b3JlTmFtZXNbMF0pO1xuICAgICAgICAgICAgKGZ1bmN0aW9uIHNwaW4oKSB7XG4gICAgICAgICAgICAgICAgKytyb290Ll9zcGluQ291bnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJvb3QuX3dhaXRpbmdRdWV1ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIChyb290Ll93YWl0aW5nUXVldWUuc2hpZnQoKSkoKTtcbiAgICAgICAgICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0ZvcilcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuZ2V0KC1JbmZpbml0eSkub25zdWNjZXNzID0gc3BpbjtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRXYWl0UHJvbWlzZSA9IHJvb3QuX3dhaXRpbmdGb3I7XG4gICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHByb21pc2UudGhlbihyZXMgPT4gcm9vdC5fd2FpdGluZ1F1ZXVlLnB1c2god3JhcChyZXNvbHZlLmJpbmQobnVsbCwgcmVzKSkpLCBlcnIgPT4gcm9vdC5fd2FpdGluZ1F1ZXVlLnB1c2god3JhcChyZWplY3QuYmluZChudWxsLCBlcnIpKSkpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yID09PSBjdXJyZW50V2FpdFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5fd2FpdGluZ0ZvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRidHJhbnMpXG4gICAgICAgICAgICAgICAgdGhpcy5pZGJ0cmFucy5hYm9ydCgpO1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0KG5ldyBleGNlcHRpb25zLkFib3J0KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRhYmxlKHRhYmxlTmFtZSkge1xuICAgICAgICBjb25zdCBtZW1vaXplZFRhYmxlcyA9ICh0aGlzLl9tZW1vaXplZFRhYmxlcyB8fCAodGhpcy5fbWVtb2l6ZWRUYWJsZXMgPSB7fSkpO1xuICAgICAgICBpZiAoaGFzT3duKG1lbW9pemVkVGFibGVzLCB0YWJsZU5hbWUpKVxuICAgICAgICAgICAgcmV0dXJuIG1lbW9pemVkVGFibGVzW3RhYmxlTmFtZV07XG4gICAgICAgIGNvbnN0IHRhYmxlU2NoZW1hID0gdGhpcy5zY2hlbWFbdGFibGVOYW1lXTtcbiAgICAgICAgaWYgKCF0YWJsZVNjaGVtYSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTm90Rm91bmQoXCJUYWJsZSBcIiArIHRhYmxlTmFtZSArIFwiIG5vdCBwYXJ0IG9mIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uQm91bmRUYWJsZSA9IG5ldyB0aGlzLmRiLlRhYmxlKHRhYmxlTmFtZSwgdGFibGVTY2hlbWEsIHRoaXMpO1xuICAgICAgICB0cmFuc2FjdGlvbkJvdW5kVGFibGUuY29yZSA9IHRoaXMuZGIuY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICBtZW1vaXplZFRhYmxlc1t0YWJsZU5hbWVdID0gdHJhbnNhY3Rpb25Cb3VuZFRhYmxlO1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25Cb3VuZFRhYmxlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb25Db25zdHJ1Y3RvcihkYikge1xuICAgIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcihUcmFuc2FjdGlvbi5wcm90b3R5cGUsIGZ1bmN0aW9uIFRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRic2NoZW1hLCBjaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHksIHBhcmVudCkge1xuICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuc3RvcmVOYW1lcyA9IHN0b3JlTmFtZXM7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gZGJzY2hlbWE7XG4gICAgICAgIHRoaXMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5ID0gY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5O1xuICAgICAgICB0aGlzLmlkYnRyYW5zID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbiA9IEV2ZW50cyh0aGlzLCBcImNvbXBsZXRlXCIsIFwiZXJyb3JcIiwgXCJhYm9ydFwiKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZWN1bG9jayA9IDA7XG4gICAgICAgIHRoaXMuX2Jsb2NrZWRGdW5jcyA9IFtdO1xuICAgICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVqZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd2FpdGluZ0ZvciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dhaXRpbmdRdWV1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NwaW5Db3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRpb24gPSBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY29tcGxldGlvbi50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm9uLmNvbXBsZXRlLmZpcmUoKTtcbiAgICAgICAgfSwgZSA9PiB7XG4gICAgICAgICAgICB2YXIgd2FzQWN0aXZlID0gdGhpcy5hY3RpdmU7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vbi5lcnJvci5maXJlKGUpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgP1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Ll9yZWplY3QoZSkgOlxuICAgICAgICAgICAgICAgIHdhc0FjdGl2ZSAmJiB0aGlzLmlkYnRyYW5zICYmIHRoaXMuaWRidHJhbnMuYWJvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbmRleFNwZWMobmFtZSwga2V5UGF0aCwgdW5pcXVlLCBtdWx0aSwgYXV0bywgY29tcG91bmQsIGlzUHJpbUtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGtleVBhdGgsXG4gICAgICAgIHVuaXF1ZSxcbiAgICAgICAgbXVsdGksXG4gICAgICAgIGF1dG8sXG4gICAgICAgIGNvbXBvdW5kLFxuICAgICAgICBzcmM6ICh1bmlxdWUgJiYgIWlzUHJpbUtleSA/ICcmJyA6ICcnKSArIChtdWx0aSA/ICcqJyA6ICcnKSArIChhdXRvID8gXCIrK1wiIDogXCJcIikgKyBuYW1lRnJvbUtleVBhdGgoa2V5UGF0aClcbiAgICB9O1xufVxuZnVuY3Rpb24gbmFtZUZyb21LZXlQYXRoKGtleVBhdGgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID9cbiAgICAgICAga2V5UGF0aCA6XG4gICAgICAgIGtleVBhdGggPyAoJ1snICsgW10uam9pbi5jYWxsKGtleVBhdGgsICcrJykgKyAnXScpIDogXCJcIjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGFibGVTY2hlbWEobmFtZSwgcHJpbUtleSwgaW5kZXhlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHByaW1LZXksXG4gICAgICAgIGluZGV4ZXMsXG4gICAgICAgIG1hcHBlZENsYXNzOiBudWxsLFxuICAgICAgICBpZHhCeU5hbWU6IGFycmF5VG9PYmplY3QoaW5kZXhlcywgaW5kZXggPT4gW2luZGV4Lm5hbWUsIGluZGV4XSlcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBzYWZhcmlNdWx0aVN0b3JlRml4KHN0b3JlTmFtZXMpIHtcbiAgICByZXR1cm4gc3RvcmVOYW1lcy5sZW5ndGggPT09IDEgPyBzdG9yZU5hbWVzWzBdIDogc3RvcmVOYW1lcztcbn1cbmxldCBnZXRNYXhLZXkgPSAoSWRiS2V5UmFuZ2UpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBJZGJLZXlSYW5nZS5vbmx5KFtbXV0pO1xuICAgICAgICBnZXRNYXhLZXkgPSAoKSA9PiBbW11dO1xuICAgICAgICByZXR1cm4gW1tdXTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZ2V0TWF4S2V5ID0gKCkgPT4gbWF4U3RyaW5nO1xuICAgICAgICByZXR1cm4gbWF4U3RyaW5nO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGdldEtleUV4dHJhY3RvcihrZXlQYXRoKSB7XG4gICAgaWYgKGtleVBhdGggPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGdldFNpbmdsZVBhdGhLZXlFeHRyYWN0b3Ioa2V5UGF0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JqID0+IGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNpbmdsZVBhdGhLZXlFeHRyYWN0b3Ioa2V5UGF0aCkge1xuICAgIGNvbnN0IHNwbGl0ID0ga2V5UGF0aC5zcGxpdCgnLicpO1xuICAgIGlmIChzcGxpdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PiBvYmpba2V5UGF0aF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JqID0+IGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXJyYXlpZnkoYXJyYXlMaWtlKSB7XG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcbn1cbmxldCBfaWRfY291bnRlciA9IDA7XG5mdW5jdGlvbiBnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCkge1xuICAgIHJldHVybiBrZXlQYXRoID09IG51bGwgP1xuICAgICAgICBcIjppZFwiIDpcbiAgICAgICAgdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgIGtleVBhdGggOlxuICAgICAgICAgICAgYFske2tleVBhdGguam9pbignKycpfV1gO1xufVxuZnVuY3Rpb24gY3JlYXRlREJDb3JlKGRiLCBJZGJLZXlSYW5nZSwgdG1wVHJhbnMpIHtcbiAgICBmdW5jdGlvbiBleHRyYWN0U2NoZW1hKGRiLCB0cmFucykge1xuICAgICAgICBjb25zdCB0YWJsZXMgPSBhcnJheWlmeShkYi5vYmplY3RTdG9yZU5hbWVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgICAgIG5hbWU6IGRiLm5hbWUsXG4gICAgICAgICAgICAgICAgdGFibGVzOiB0YWJsZXMubWFwKHRhYmxlID0+IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlKSkubWFwKHN0b3JlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBrZXlQYXRoLCBhdXRvSW5jcmVtZW50IH0gPSBzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcG91bmQgPSBpc0FycmF5KGtleVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRib3VuZCA9IGtleVBhdGggPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXhCeUtleVBhdGggPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc3RvcmUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJpbWFyeUtleTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRib3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9JbmNyZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3RLZXk6IGdldEtleUV4dHJhY3RvcihrZXlQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXM6IGFycmF5aWZ5KHN0b3JlLmluZGV4TmFtZXMpLm1hcChpbmRleE5hbWUgPT4gc3RvcmUuaW5kZXgoaW5kZXhOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGluZGV4ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG5hbWUsIHVuaXF1ZSwgbXVsdGlFbnRyeSwga2V5UGF0aCB9ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcG91bmQgPSBpc0FycmF5KGtleVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlFbnRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEluZGV4QnlLZXlQYXRoOiAoa2V5UGF0aCkgPT4gaW5kZXhCeUtleVBhdGhbZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpbmRleEJ5S2V5UGF0aFtcIjppZFwiXSA9IHJlc3VsdC5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldID0gcmVzdWx0LnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhc0dldEFsbDogdGFibGVzLmxlbmd0aCA+IDAgJiYgKCdnZXRBbGwnIGluIHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlc1swXSkpICYmXG4gICAgICAgICAgICAgICAgISh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICAgICAgICAgICAgICEvKENocm9tZVxcL3xFZGdlXFwvKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICAgICAgICAgICAgICBbXS5jb25jYXQobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvU2FmYXJpXFwvKFxcZCopLykpWzFdIDwgNjA0KVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlSURCS2V5UmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDMgKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChyYW5nZS50eXBlID09PSA0IClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG5ldmVyIHR5cGUgdG8gSURCS2V5UmFuZ2VcIik7XG4gICAgICAgIGNvbnN0IHsgbG93ZXIsIHVwcGVyLCBsb3dlck9wZW4sIHVwcGVyT3BlbiB9ID0gcmFuZ2U7XG4gICAgICAgIGNvbnN0IGlkYlJhbmdlID0gbG93ZXIgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICB1cHBlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICBudWxsIDpcbiAgICAgICAgICAgICAgICBJZGJLZXlSYW5nZS51cHBlckJvdW5kKHVwcGVyLCAhIXVwcGVyT3BlbikgOlxuICAgICAgICAgICAgdXBwZXIgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgSWRiS2V5UmFuZ2UubG93ZXJCb3VuZChsb3dlciwgISFsb3dlck9wZW4pIDpcbiAgICAgICAgICAgICAgICBJZGJLZXlSYW5nZS5ib3VuZChsb3dlciwgdXBwZXIsICEhbG93ZXJPcGVuLCAhIXVwcGVyT3Blbik7XG4gICAgICAgIHJldHVybiBpZGJSYW5nZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRGJDb3JlVGFibGUodGFibGVTY2hlbWEpIHtcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gdGFibGVTY2hlbWEubmFtZTtcbiAgICAgICAgZnVuY3Rpb24gbXV0YXRlKHsgdHJhbnMsIHR5cGUsIGtleXMsIHZhbHVlcywgcmFuZ2UgfSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0Ym91bmQgPSBzdG9yZS5rZXlQYXRoID09IG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBZGRPclB1dCA9IHR5cGUgPT09IFwicHV0XCIgfHwgdHlwZSA9PT0gXCJhZGRcIjtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWRkT3JQdXQgJiYgdHlwZSAhPT0gJ2RlbGV0ZScgJiYgdHlwZSAhPT0gJ2RlbGV0ZVJhbmdlJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvcGVyYXRpb24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0ga2V5cyB8fCB2YWx1ZXMgfHwgeyBsZW5ndGg6IDEgfTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cyAmJiB2YWx1ZXMgJiYga2V5cy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2l2ZW4ga2V5cyBhcnJheSBtdXN0IGhhdmUgc2FtZSBsZW5ndGggYXMgZ2l2ZW4gdmFsdWVzIGFycmF5LlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBudW1GYWlsdXJlczogMCwgZmFpbHVyZXM6IHt9LCByZXN1bHRzOiBbXSwgbGFzdFJlc3VsdDogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgIGxldCByZXE7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxcyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IG51bUZhaWx1cmVzID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICsrbnVtRmFpbHVyZXM7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZGVsZXRlUmFuZ2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS50eXBlID09PSA0IClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgbnVtRmFpbHVyZXMsIGZhaWx1cmVzLCByZXN1bHRzOiBbXSwgbGFzdFJlc3VsdDogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gMyApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXFzLnB1c2gocmVxID0gc3RvcmUuY2xlYXIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZS5kZWxldGUobWFrZUlEQktleVJhbmdlKHJhbmdlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2FyZ3MxLCBhcmdzMl0gPSBpc0FkZE9yUHV0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGJvdW5kID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVzLCBrZXlzXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlcywgbnVsbF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgW2tleXMsIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBZGRPclB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSAoYXJnczIgJiYgYXJnczJbaV0gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlW3R5cGVdKGFyZ3MxW2ldLCBhcmdzMltpXSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVt0eXBlXShhcmdzMVtpXSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXFzLnB1c2gocmVxID0gc3RvcmVbdHlwZV0oYXJnczFbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkb25lID0gZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0UmVzdWx0ID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgcmVxcy5mb3JFYWNoKChyZXEsIGkpID0+IHJlcS5lcnJvciAhPSBudWxsICYmIChmYWlsdXJlc1tpXSA9IHJlcS5lcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bUZhaWx1cmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzOiB0eXBlID09PSBcImRlbGV0ZVwiID8ga2V5cyA6IHJlcXMubWFwKHJlcSA9PiByZXEucmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZShldmVudCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZG9uZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9wZW5DdXJzb3IoeyB0cmFucywgdmFsdWVzLCBxdWVyeSwgcmV2ZXJzZSwgdW5pcXVlIH0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbmRleCwgcmFuZ2UgfSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBpbmRleC5pc1ByaW1hcnlLZXkgP1xuICAgICAgICAgICAgICAgICAgICBzdG9yZSA6XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmluZGV4KGluZGV4Lm5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHJldmVyc2UgP1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJwcmV2dW5pcXVlXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgXCJwcmV2XCIgOlxuICAgICAgICAgICAgICAgICAgICB1bmlxdWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJuZXh0dW5pcXVlXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuZXh0XCI7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxID0gdmFsdWVzIHx8ICEoJ29wZW5LZXlDdXJzb3InIGluIHNvdXJjZSkgP1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2Uub3BlbkN1cnNvcihtYWtlSURCS2V5UmFuZ2UocmFuZ2UpLCBkaXJlY3Rpb24pIDpcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5LZXlDdXJzb3IobWFrZUlEQktleVJhbmdlKHJhbmdlKSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGV2ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLl9fX2lkID0gKytfaWRfY291bnRlcjtcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgX2N1cnNvckNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlLmJpbmQoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkgPSBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkgPSBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5LmJpbmQoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgX2N1cnNvckFkdmFuY2UgPSBjdXJzb3IuYWR2YW5jZS5iaW5kKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvVGhyb3dDdXJzb3JJc05vdFN0YXJ0ZWQgPSAoKSA9PiB7IHRocm93IG5ldyBFcnJvcihcIkN1cnNvciBub3Qgc3RhcnRlZFwiKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9UaHJvd0N1cnNvcklzU3RvcHBlZCA9ICgpID0+IHsgdGhyb3cgbmV3IEVycm9yKFwiQ3Vyc29yIG5vdCBzdG9wcGVkXCIpOyB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IudHJhbnMgPSB0cmFucztcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AgPSBjdXJzb3IuY29udGludWUgPSBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gY3Vyc29yLmFkdmFuY2UgPSBkb1Rocm93Q3Vyc29ySXNOb3RTdGFydGVkO1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZmFpbCA9IHdyYXAocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZ290T25lID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0KCgpID0+IGdvdE9uZS0tID8gdGhpcy5jb250aW51ZSgpIDogdGhpcy5zdG9wKCkpLnRoZW4oKCkgPT4gdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdGFydCA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlcmF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlSXRlcmF0aW9uLCByZWplY3RJdGVyYXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSXRlcmF0aW9uID0gd3JhcChyZXNvbHZlSXRlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3RJdGVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5mYWlsID0gcmVqZWN0SXRlcmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wID0gdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RvcCA9IGN1cnNvci5jb250aW51ZSA9IGN1cnNvci5jb250aW51ZVByaW1hcnlLZXkgPSBjdXJzb3IuYWR2YW5jZSA9IGRvVGhyb3dDdXJzb3JJc1N0b3BwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJdGVyYXRpb24odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGd1YXJkZWRDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZmFpbChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdGFydCA9ICgpID0+IHsgdGhyb3cgbmV3IEVycm9yKFwiQ3Vyc29yIGJlaGluZCBsYXN0IGVudHJ5XCIpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChldiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGd1YXJkZWRDYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBndWFyZGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlID0gX2N1cnNvckNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuYWR2YW5jZSA9IF9jdXJzb3JBZHZhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3VhcmRlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0aW9uUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBxdWVyeShoYXNHZXRBbGwpIHtcbiAgICAgICAgICAgIHJldHVybiAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRyYW5zLCB2YWx1ZXMsIGxpbWl0LCBxdWVyeSB9ID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9uSW5maW5pdExpbWl0ID0gbGltaXQgPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogbGltaXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaW5kZXgsIHJhbmdlIH0gPSBxdWVyeTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBpbmRleC5pc1ByaW1hcnlLZXkgPyBzdG9yZSA6IHN0b3JlLmluZGV4KGluZGV4Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZGJLZXlSYW5nZSA9IG1ha2VJREJLZXlSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgcmVzdWx0OiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0dldEFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxID0gdmFsdWVzID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UuZ2V0QWxsKGlkYktleVJhbmdlLCBub25JbmZpbml0TGltaXQpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UuZ2V0QWxsS2V5cyhpZGJLZXlSYW5nZSwgbm9uSW5maW5pdExpbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBldmVudCA9PiByZXNvbHZlKHsgcmVzdWx0OiBldmVudC50YXJnZXQucmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXEgPSB2YWx1ZXMgfHwgISgnb3BlbktleUN1cnNvcicgaW4gc291cmNlKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5DdXJzb3IoaWRiS2V5UmFuZ2UpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Uub3BlbktleUN1cnNvcihpZGJLZXlSYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWVzID8gY3Vyc29yLnZhbHVlIDogY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2NvdW50ID09PSBsaW1pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGFibGVOYW1lLFxuICAgICAgICAgICAgc2NoZW1hOiB0YWJsZVNjaGVtYSxcbiAgICAgICAgICAgIG11dGF0ZSxcbiAgICAgICAgICAgIGdldE1hbnkoeyB0cmFucywga2V5cyB9KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQga2V5Q291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2FsbGJhY2tDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZXN1bHRbcmVxLl9wb3NdID0gcmVxLnJlc3VsdCkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytjYWxsYmFja0NvdW50ID09PSBrZXlDb3VudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gc3RvcmUuZ2V0KGtleXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5fcG9zID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gc3VjY2Vzc0hhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytrZXlDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5Q291bnQgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0KHsgdHJhbnMsIGtleSB9KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxID0gc3RvcmUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBldmVudCA9PiByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeShoYXNHZXRBbGwpLFxuICAgICAgICAgICAgb3BlbkN1cnNvcixcbiAgICAgICAgICAgIGNvdW50KHsgcXVlcnksIHRyYW5zIH0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGluZGV4LCByYW5nZSB9ID0gcXVlcnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBpbmRleC5pc1ByaW1hcnlLZXkgPyBzdG9yZSA6IHN0b3JlLmluZGV4KGluZGV4Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZGJLZXlSYW5nZSA9IG1ha2VJREJLZXlSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcSA9IGlkYktleVJhbmdlID8gc291cmNlLmNvdW50KGlkYktleVJhbmdlKSA6IHNvdXJjZS5jb3VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChldiA9PiByZXNvbHZlKGV2LnRhcmdldC5yZXN1bHQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgeyBzY2hlbWEsIGhhc0dldEFsbCB9ID0gZXh0cmFjdFNjaGVtYShkYiwgdG1wVHJhbnMpO1xuICAgIGNvbnN0IHRhYmxlcyA9IHNjaGVtYS50YWJsZXMubWFwKHRhYmxlU2NoZW1hID0+IGNyZWF0ZURiQ29yZVRhYmxlKHRhYmxlU2NoZW1hKSk7XG4gICAgY29uc3QgdGFibGVNYXAgPSB7fTtcbiAgICB0YWJsZXMuZm9yRWFjaCh0YWJsZSA9PiB0YWJsZU1hcFt0YWJsZS5uYW1lXSA9IHRhYmxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICAgICAgdHJhbnNhY3Rpb246IGRiLnRyYW5zYWN0aW9uLmJpbmQoZGIpLFxuICAgICAgICB0YWJsZShuYW1lKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0YWJsZU1hcFtuYW1lXTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGFibGUgJyR7bmFtZX0nIG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgcmV0dXJuIHRhYmxlTWFwW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBNSU5fS0VZOiAtSW5maW5pdHksXG4gICAgICAgIE1BWF9LRVk6IGdldE1heEtleShJZGJLZXlSYW5nZSksXG4gICAgICAgIHNjaGVtYVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVTdGFjayhzdGFja0ltcGwsIG1pZGRsZXdhcmVzKSB7XG4gICAgcmV0dXJuIG1pZGRsZXdhcmVzLnJlZHVjZSgoZG93biwgeyBjcmVhdGUgfSkgPT4gKHsgLi4uZG93biwgLi4uY3JlYXRlKGRvd24pIH0pLCBzdGFja0ltcGwpO1xufVxuZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZVN0YWNrcyhtaWRkbGV3YXJlcywgaWRiZGIsIHsgSURCS2V5UmFuZ2UsIGluZGV4ZWREQiB9LCB0bXBUcmFucykge1xuICAgIGNvbnN0IGRiY29yZSA9IGNyZWF0ZU1pZGRsZXdhcmVTdGFjayhjcmVhdGVEQkNvcmUoaWRiZGIsIElEQktleVJhbmdlLCB0bXBUcmFucyksIG1pZGRsZXdhcmVzLmRiY29yZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGJjb3JlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyh7IF9ub3ZpcDogZGIgfSwgdG1wVHJhbnMpIHtcbiAgICBjb25zdCBpZGJkYiA9IHRtcFRyYW5zLmRiO1xuICAgIGNvbnN0IHN0YWNrcyA9IGNyZWF0ZU1pZGRsZXdhcmVTdGFja3MoZGIuX21pZGRsZXdhcmVzLCBpZGJkYiwgZGIuX2RlcHMsIHRtcFRyYW5zKTtcbiAgICBkYi5jb3JlID0gc3RhY2tzLmRiY29yZTtcbiAgICBkYi50YWJsZXMuZm9yRWFjaCh0YWJsZSA9PiB7XG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLm5hbWU7XG4gICAgICAgIGlmIChkYi5jb3JlLnNjaGVtYS50YWJsZXMuc29tZSh0YmwgPT4gdGJsLm5hbWUgPT09IHRhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgIHRhYmxlLmNvcmUgPSBkYi5jb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICBpZiAoZGJbdGFibGVOYW1lXSBpbnN0YW5jZW9mIGRiLlRhYmxlKSB7XG4gICAgICAgICAgICAgICAgZGJbdGFibGVOYW1lXS5jb3JlID0gdGFibGUuY29yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBzZXRBcGlPblBsYWNlKHsgX25vdmlwOiBkYiB9LCBvYmpzLCB0YWJsZU5hbWVzLCBkYnNjaGVtYSkge1xuICAgIHRhYmxlTmFtZXMuZm9yRWFjaCh0YWJsZU5hbWUgPT4ge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBkYnNjaGVtYVt0YWJsZU5hbWVdO1xuICAgICAgICBvYmpzLmZvckVhY2gob2JqID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BEZXNjID0gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgdGFibGVOYW1lKTtcbiAgICAgICAgICAgIGlmICghcHJvcERlc2MgfHwgKFwidmFsdWVcIiBpbiBwcm9wRGVzYyAmJiBwcm9wRGVzYy52YWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIGlmIChvYmogPT09IGRiLlRyYW5zYWN0aW9uLnByb3RvdHlwZSB8fCBvYmogaW5zdGFuY2VvZiBkYi5UcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKG9iaiwgdGFibGVOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzLnRhYmxlKHRhYmxlTmFtZSk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCB0YWJsZU5hbWUsIHsgdmFsdWUsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW3RhYmxlTmFtZV0gPSBuZXcgZGIuVGFibGUodGFibGVOYW1lLCBzY2hlbWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZW1vdmVUYWJsZXNBcGkoeyBfbm92aXA6IGRiIH0sIG9ianMpIHtcbiAgICBvYmpzLmZvckVhY2gob2JqID0+IHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9ialtrZXldIGluc3RhbmNlb2YgZGIuVGFibGUpXG4gICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBsb3dlclZlcnNpb25GaXJzdChhLCBiKSB7XG4gICAgcmV0dXJuIGEuX2NmZy52ZXJzaW9uIC0gYi5fY2ZnLnZlcnNpb247XG59XG5mdW5jdGlvbiBydW5VcGdyYWRlcnMoZGIsIG9sZFZlcnNpb24sIGlkYlVwZ3JhZGVUcmFucywgcmVqZWN0KSB7XG4gICAgY29uc3QgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hO1xuICAgIGNvbnN0IHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnLCBkYi5fc3RvcmVOYW1lcywgZ2xvYmFsU2NoZW1hKTtcbiAgICB0cmFucy5jcmVhdGUoaWRiVXBncmFkZVRyYW5zKTtcbiAgICB0cmFucy5fY29tcGxldGlvbi5jYXRjaChyZWplY3QpO1xuICAgIGNvbnN0IHJlamVjdFRyYW5zYWN0aW9uID0gdHJhbnMuX3JlamVjdC5iaW5kKHRyYW5zKTtcbiAgICBjb25zdCB0cmFuc2xlc3MgPSBQU0QudHJhbnNsZXNzIHx8IFBTRDtcbiAgICBuZXdTY29wZSgoKSA9PiB7XG4gICAgICAgIFBTRC50cmFucyA9IHRyYW5zO1xuICAgICAgICBQU0QudHJhbnNsZXNzID0gdHJhbnNsZXNzO1xuICAgICAgICBpZiAob2xkVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAga2V5cyhnbG9iYWxTY2hlbWEpLmZvckVhY2godGFibGVOYW1lID0+IHtcbiAgICAgICAgICAgICAgICBjcmVhdGVUYWJsZShpZGJVcGdyYWRlVHJhbnMsIHRhYmxlTmFtZSwgZ2xvYmFsU2NoZW1hW3RhYmxlTmFtZV0ucHJpbUtleSwgZ2xvYmFsU2NoZW1hW3RhYmxlTmFtZV0uaW5kZXhlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyhkYiwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgICAgICAgIERleGllUHJvbWlzZS5mb2xsb3coKCkgPT4gZGIub24ucG9wdWxhdGUuZmlyZSh0cmFucykpLmNhdGNoKHJlamVjdFRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB1cGRhdGVUYWJsZXNBbmRJbmRleGVzKGRiLCBvbGRWZXJzaW9uLCB0cmFucywgaWRiVXBncmFkZVRyYW5zKS5jYXRjaChyZWplY3RUcmFuc2FjdGlvbik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVUYWJsZXNBbmRJbmRleGVzKHsgX25vdmlwOiBkYiB9LCBvbGRWZXJzaW9uLCB0cmFucywgaWRiVXBncmFkZVRyYW5zKSB7XG4gICAgY29uc3QgcXVldWUgPSBbXTtcbiAgICBjb25zdCB2ZXJzaW9ucyA9IGRiLl92ZXJzaW9ucztcbiAgICBsZXQgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hID0gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGRiLmlkYmRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgIGxldCBhbnlDb250ZW50VXBncmFkZXJIYXNSdW4gPSBmYWxzZTtcbiAgICBjb25zdCB2ZXJzVG9SdW4gPSB2ZXJzaW9ucy5maWx0ZXIodiA9PiB2Ll9jZmcudmVyc2lvbiA+PSBvbGRWZXJzaW9uKTtcbiAgICB2ZXJzVG9SdW4uZm9yRWFjaCh2ZXJzaW9uID0+IHtcbiAgICAgICAgcXVldWUucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbGRTY2hlbWEgPSBnbG9iYWxTY2hlbWE7XG4gICAgICAgICAgICBjb25zdCBuZXdTY2hlbWEgPSB2ZXJzaW9uLl9jZmcuZGJzY2hlbWE7XG4gICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgb2xkU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICAgICAgYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGIsIG5ld1NjaGVtYSwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgICAgICAgIGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYSA9IG5ld1NjaGVtYTtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBnZXRTY2hlbWFEaWZmKG9sZFNjaGVtYSwgbmV3U2NoZW1hKTtcbiAgICAgICAgICAgIGRpZmYuYWRkLmZvckVhY2godHVwbGUgPT4ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZVRhYmxlKGlkYlVwZ3JhZGVUcmFucywgdHVwbGVbMF0sIHR1cGxlWzFdLnByaW1LZXksIHR1cGxlWzFdLmluZGV4ZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaWZmLmNoYW5nZS5mb3JFYWNoKGNoYW5nZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5yZWNyZWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5VcGdyYWRlKFwiTm90IHlldCBzdXBwb3J0IGZvciBjaGFuZ2luZyBwcmltYXJ5IGtleVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gaWRiVXBncmFkZVRyYW5zLm9iamVjdFN0b3JlKGNoYW5nZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmFkZC5mb3JFYWNoKGlkeCA9PiBhZGRJbmRleChzdG9yZSwgaWR4KSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZS5jaGFuZ2UuZm9yRWFjaChpZHggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuZGVsZXRlSW5kZXgoaWR4Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSW5kZXgoc3RvcmUsIGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuZGVsLmZvckVhY2goaWR4TmFtZSA9PiBzdG9yZS5kZWxldGVJbmRleChpZHhOYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50VXBncmFkZSA9IHZlcnNpb24uX2NmZy5jb250ZW50VXBncmFkZTtcbiAgICAgICAgICAgIGlmIChjb250ZW50VXBncmFkZSAmJiB2ZXJzaW9uLl9jZmcudmVyc2lvbiA+IG9sZFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgICAgICAgICAgdHJhbnMuX21lbW9pemVkVGFibGVzID0ge307XG4gICAgICAgICAgICAgICAgYW55Q29udGVudFVwZ3JhZGVySGFzUnVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgdXBncmFkZVNjaGVtYSA9IHNoYWxsb3dDbG9uZShuZXdTY2hlbWEpO1xuICAgICAgICAgICAgICAgIGRpZmYuZGVsLmZvckVhY2godGFibGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1cGdyYWRlU2NoZW1hW3RhYmxlXSA9IG9sZFNjaGVtYVt0YWJsZV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlVGFibGVzQXBpKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSk7XG4gICAgICAgICAgICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0sIGtleXModXBncmFkZVNjaGVtYSksIHVwZ3JhZGVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHRyYW5zLnNjaGVtYSA9IHVwZ3JhZGVTY2hlbWE7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudFVwZ3JhZGVJc0FzeW5jID0gaXNBc3luY0Z1bmN0aW9uKGNvbnRlbnRVcGdyYWRlKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFVwZ3JhZGVJc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlRm9sbG93ZWQgPSBEZXhpZVByb21pc2UuZm9sbG93KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBjb250ZW50VXBncmFkZSh0cmFucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRVcGdyYWRlSXNBc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNyZW1lbnRvciA9IGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzLmJpbmQobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUudGhlbihkZWNyZW1lbnRvciwgZGVjcmVtZW50b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChyZXR1cm5WYWx1ZSAmJiB0eXBlb2YgcmV0dXJuVmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgICAgIERleGllUHJvbWlzZS5yZXNvbHZlKHJldHVyblZhbHVlKSA6IHByb21pc2VGb2xsb3dlZC50aGVuKCgpID0+IHJldHVyblZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBxdWV1ZS5wdXNoKGlkYnRyYW5zID0+IHtcbiAgICAgICAgICAgIGlmICghYW55Q29udGVudFVwZ3JhZGVySGFzUnVuIHx8ICFoYXNJRURlbGV0ZU9iamVjdFN0b3JlQnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U2NoZW1hID0gdmVyc2lvbi5fY2ZnLmRic2NoZW1hO1xuICAgICAgICAgICAgICAgIGRlbGV0ZVJlbW92ZWRUYWJsZXMobmV3U2NoZW1hLCBpZGJ0cmFucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVUYWJsZXNBcGkoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdKTtcbiAgICAgICAgICAgIHNldEFwaU9uUGxhY2UoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdLCBkYi5fc3RvcmVOYW1lcywgZGIuX2RiU2NoZW1hKTtcbiAgICAgICAgICAgIHRyYW5zLnNjaGVtYSA9IGRiLl9kYlNjaGVtYTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gcnVuUXVldWUoKSB7XG4gICAgICAgIHJldHVybiBxdWV1ZS5sZW5ndGggPyBEZXhpZVByb21pc2UucmVzb2x2ZShxdWV1ZS5zaGlmdCgpKHRyYW5zLmlkYnRyYW5zKSkudGhlbihydW5RdWV1ZSkgOlxuICAgICAgICAgICAgRGV4aWVQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1blF1ZXVlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGNyZWF0ZU1pc3NpbmdUYWJsZXMoZ2xvYmFsU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2NoZW1hRGlmZihvbGRTY2hlbWEsIG5ld1NjaGVtYSkge1xuICAgIGNvbnN0IGRpZmYgPSB7XG4gICAgICAgIGRlbDogW10sXG4gICAgICAgIGFkZDogW10sXG4gICAgICAgIGNoYW5nZTogW11cbiAgICB9O1xuICAgIGxldCB0YWJsZTtcbiAgICBmb3IgKHRhYmxlIGluIG9sZFNjaGVtYSkge1xuICAgICAgICBpZiAoIW5ld1NjaGVtYVt0YWJsZV0pXG4gICAgICAgICAgICBkaWZmLmRlbC5wdXNoKHRhYmxlKTtcbiAgICB9XG4gICAgZm9yICh0YWJsZSBpbiBuZXdTY2hlbWEpIHtcbiAgICAgICAgY29uc3Qgb2xkRGVmID0gb2xkU2NoZW1hW3RhYmxlXSwgbmV3RGVmID0gbmV3U2NoZW1hW3RhYmxlXTtcbiAgICAgICAgaWYgKCFvbGREZWYpIHtcbiAgICAgICAgICAgIGRpZmYuYWRkLnB1c2goW3RhYmxlLCBuZXdEZWZdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0YWJsZSxcbiAgICAgICAgICAgICAgICBkZWY6IG5ld0RlZixcbiAgICAgICAgICAgICAgICByZWNyZWF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGVsOiBbXSxcbiAgICAgICAgICAgICAgICBhZGQ6IFtdLFxuICAgICAgICAgICAgICAgIGNoYW5nZTogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoKFxuICAgICAgICAgICAgJycgKyAob2xkRGVmLnByaW1LZXkua2V5UGF0aCB8fCAnJykpICE9PSAoJycgKyAobmV3RGVmLnByaW1LZXkua2V5UGF0aCB8fCAnJykpIHx8XG4gICAgICAgICAgICAgICAgKG9sZERlZi5wcmltS2V5LmF1dG8gIT09IG5ld0RlZi5wcmltS2V5LmF1dG8gJiYgIWlzSUVPckVkZ2UpKVxuICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2UucmVjcmVhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRpZmYuY2hhbmdlLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZEluZGV4ZXMgPSBvbGREZWYuaWR4QnlOYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ZXMgPSBuZXdEZWYuaWR4QnlOYW1lO1xuICAgICAgICAgICAgICAgIGxldCBpZHhOYW1lO1xuICAgICAgICAgICAgICAgIGZvciAoaWR4TmFtZSBpbiBvbGRJbmRleGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV3SW5kZXhlc1tpZHhOYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5kZWwucHVzaChpZHhOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpZHhOYW1lIGluIG5ld0luZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkSWR4ID0gb2xkSW5kZXhlc1tpZHhOYW1lXSwgbmV3SWR4ID0gbmV3SW5kZXhlc1tpZHhOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGRJZHgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuYWRkLnB1c2gobmV3SWR4KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkSWR4LnNyYyAhPT0gbmV3SWR4LnNyYylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5jaGFuZ2UucHVzaChuZXdJZHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLmRlbC5sZW5ndGggPiAwIHx8IGNoYW5nZS5hZGQubGVuZ3RoID4gMCB8fCBjaGFuZ2UuY2hhbmdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmZi5jaGFuZ2UucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlmZjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlKGlkYnRyYW5zLCB0YWJsZU5hbWUsIHByaW1LZXksIGluZGV4ZXMpIHtcbiAgICBjb25zdCBzdG9yZSA9IGlkYnRyYW5zLmRiLmNyZWF0ZU9iamVjdFN0b3JlKHRhYmxlTmFtZSwgcHJpbUtleS5rZXlQYXRoID9cbiAgICAgICAgeyBrZXlQYXRoOiBwcmltS2V5LmtleVBhdGgsIGF1dG9JbmNyZW1lbnQ6IHByaW1LZXkuYXV0byB9IDpcbiAgICAgICAgeyBhdXRvSW5jcmVtZW50OiBwcmltS2V5LmF1dG8gfSk7XG4gICAgaW5kZXhlcy5mb3JFYWNoKGlkeCA9PiBhZGRJbmRleChzdG9yZSwgaWR4KSk7XG4gICAgcmV0dXJuIHN0b3JlO1xufVxuZnVuY3Rpb24gY3JlYXRlTWlzc2luZ1RhYmxlcyhuZXdTY2hlbWEsIGlkYnRyYW5zKSB7XG4gICAga2V5cyhuZXdTY2hlbWEpLmZvckVhY2godGFibGVOYW1lID0+IHtcbiAgICAgICAgaWYgKCFpZGJ0cmFucy5kYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKHRhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgIGNyZWF0ZVRhYmxlKGlkYnRyYW5zLCB0YWJsZU5hbWUsIG5ld1NjaGVtYVt0YWJsZU5hbWVdLnByaW1LZXksIG5ld1NjaGVtYVt0YWJsZU5hbWVdLmluZGV4ZXMpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBkZWxldGVSZW1vdmVkVGFibGVzKG5ld1NjaGVtYSwgaWRidHJhbnMpIHtcbiAgICBbXS5zbGljZS5jYWxsKGlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXMpLmZvckVhY2goc3RvcmVOYW1lID0+IG5ld1NjaGVtYVtzdG9yZU5hbWVdID09IG51bGwgJiYgaWRidHJhbnMuZGIuZGVsZXRlT2JqZWN0U3RvcmUoc3RvcmVOYW1lKSk7XG59XG5mdW5jdGlvbiBhZGRJbmRleChzdG9yZSwgaWR4KSB7XG4gICAgc3RvcmUuY3JlYXRlSW5kZXgoaWR4Lm5hbWUsIGlkeC5rZXlQYXRoLCB7IHVuaXF1ZTogaWR4LnVuaXF1ZSwgbXVsdGlFbnRyeTogaWR4Lm11bHRpIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGlkYmRiLCB0bXBUcmFucykge1xuICAgIGNvbnN0IGdsb2JhbFNjaGVtYSA9IHt9O1xuICAgIGNvbnN0IGRiU3RvcmVOYW1lcyA9IHNsaWNlKGlkYmRiLm9iamVjdFN0b3JlTmFtZXMsIDApO1xuICAgIGRiU3RvcmVOYW1lcy5mb3JFYWNoKHN0b3JlTmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gdG1wVHJhbnMub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgICAgbGV0IGtleVBhdGggPSBzdG9yZS5rZXlQYXRoO1xuICAgICAgICBjb25zdCBwcmltS2V5ID0gY3JlYXRlSW5kZXhTcGVjKG5hbWVGcm9tS2V5UGF0aChrZXlQYXRoKSwga2V5UGF0aCB8fCBcIlwiLCBmYWxzZSwgZmFsc2UsICEhc3RvcmUuYXV0b0luY3JlbWVudCwga2V5UGF0aCAmJiB0eXBlb2Yga2V5UGF0aCAhPT0gXCJzdHJpbmdcIiwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdG9yZS5pbmRleE5hbWVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBjb25zdCBpZGJpbmRleCA9IHN0b3JlLmluZGV4KHN0b3JlLmluZGV4TmFtZXNbal0pO1xuICAgICAgICAgICAga2V5UGF0aCA9IGlkYmluZGV4LmtleVBhdGg7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBjcmVhdGVJbmRleFNwZWMoaWRiaW5kZXgubmFtZSwga2V5UGF0aCwgISFpZGJpbmRleC51bmlxdWUsICEhaWRiaW5kZXgubXVsdGlFbnRyeSwgZmFsc2UsIGtleVBhdGggJiYgdHlwZW9mIGtleVBhdGggIT09IFwic3RyaW5nXCIsIGZhbHNlKTtcbiAgICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsU2NoZW1hW3N0b3JlTmFtZV0gPSBjcmVhdGVUYWJsZVNjaGVtYShzdG9yZU5hbWUsIHByaW1LZXksIGluZGV4ZXMpO1xuICAgIH0pO1xuICAgIHJldHVybiBnbG9iYWxTY2hlbWE7XG59XG5mdW5jdGlvbiByZWFkR2xvYmFsU2NoZW1hKHsgX25vdmlwOiBkYiB9LCBpZGJkYiwgdG1wVHJhbnMpIHtcbiAgICBkYi52ZXJubyA9IGlkYmRiLnZlcnNpb24gLyAxMDtcbiAgICBjb25zdCBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgaWRiZGIsIHRtcFRyYW5zKTtcbiAgICBkYi5fc3RvcmVOYW1lcyA9IHNsaWNlKGlkYmRiLm9iamVjdFN0b3JlTmFtZXMsIDApO1xuICAgIHNldEFwaU9uUGxhY2UoZGIsIFtkYi5fYWxsVGFibGVzXSwga2V5cyhnbG9iYWxTY2hlbWEpLCBnbG9iYWxTY2hlbWEpO1xufVxuZnVuY3Rpb24gdmVyaWZ5SW5zdGFsbGVkU2NoZW1hKGRiLCB0bXBUcmFucykge1xuICAgIGNvbnN0IGluc3RhbGxlZFNjaGVtYSA9IGJ1aWxkR2xvYmFsU2NoZW1hKGRiLCBkYi5pZGJkYiwgdG1wVHJhbnMpO1xuICAgIGNvbnN0IGRpZmYgPSBnZXRTY2hlbWFEaWZmKGluc3RhbGxlZFNjaGVtYSwgZGIuX2RiU2NoZW1hKTtcbiAgICByZXR1cm4gIShkaWZmLmFkZC5sZW5ndGggfHwgZGlmZi5jaGFuZ2Uuc29tZShjaCA9PiBjaC5hZGQubGVuZ3RoIHx8IGNoLmNoYW5nZS5sZW5ndGgpKTtcbn1cbmZ1bmN0aW9uIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKHsgX25vdmlwOiBkYiB9LCBzY2hlbWEsIGlkYnRyYW5zKSB7XG4gICAgY29uc3Qgc3RvcmVOYW1lcyA9IGlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdG9yZU5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlTmFtZSA9IHN0b3JlTmFtZXNbaV07XG4gICAgICAgIGNvbnN0IHN0b3JlID0gaWRidHJhbnMub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgICAgZGIuX2hhc0dldEFsbCA9ICdnZXRBbGwnIGluIHN0b3JlO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0b3JlLmluZGV4TmFtZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4TmFtZSA9IHN0b3JlLmluZGV4TmFtZXNbal07XG4gICAgICAgICAgICBjb25zdCBrZXlQYXRoID0gc3RvcmUuaW5kZXgoaW5kZXhOYW1lKS5rZXlQYXRoO1xuICAgICAgICAgICAgY29uc3QgZGV4aWVOYW1lID0gdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID8ga2V5UGF0aCA6IFwiW1wiICsgc2xpY2Uoa2V5UGF0aCkuam9pbignKycpICsgXCJdXCI7XG4gICAgICAgICAgICBpZiAoc2NoZW1hW3N0b3JlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleFNwZWMgPSBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbZGV4aWVOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhTcGVjKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4U3BlYy5uYW1lID0gaW5kZXhOYW1lO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hW3N0b3JlTmFtZV0uaWR4QnlOYW1lW2RleGllTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVtzdG9yZU5hbWVdLmlkeEJ5TmFtZVtpbmRleE5hbWVdID0gaW5kZXhTcGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1NhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICAhLyhDaHJvbWVcXC98RWRnZVxcLykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgX2dsb2JhbC5Xb3JrZXJHbG9iYWxTY29wZSAmJiBfZ2xvYmFsIGluc3RhbmNlb2YgX2dsb2JhbC5Xb3JrZXJHbG9iYWxTY29wZSAmJlxuICAgICAgICBbXS5jb25jYXQobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvU2FmYXJpXFwvKFxcZCopLykpWzFdIDwgNjA0KSB7XG4gICAgICAgIGRiLl9oYXNHZXRBbGwgPSBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUluZGV4U3ludGF4KHByaW1LZXlBbmRJbmRleGVzKSB7XG4gICAgcmV0dXJuIHByaW1LZXlBbmRJbmRleGVzLnNwbGl0KCcsJykubWFwKChpbmRleCwgaW5kZXhOdW0pID0+IHtcbiAgICAgICAgaW5kZXggPSBpbmRleC50cmltKCk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBpbmRleC5yZXBsYWNlKC8oWyYqXXxcXCtcXCspL2csIFwiXCIpO1xuICAgICAgICBjb25zdCBrZXlQYXRoID0gL15cXFsvLnRlc3QobmFtZSkgPyBuYW1lLm1hdGNoKC9eXFxbKC4qKVxcXSQvKVsxXS5zcGxpdCgnKycpIDogbmFtZTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUluZGV4U3BlYyhuYW1lLCBrZXlQYXRoIHx8IG51bGwsIC9cXCYvLnRlc3QoaW5kZXgpLCAvXFwqLy50ZXN0KGluZGV4KSwgL1xcK1xcKy8udGVzdChpbmRleCksIGlzQXJyYXkoa2V5UGF0aCksIGluZGV4TnVtID09PSAwKTtcbiAgICB9KTtcbn1cblxuY2xhc3MgVmVyc2lvbiB7XG4gICAgX3BhcnNlU3RvcmVzU3BlYyhzdG9yZXMsIG91dFNjaGVtYSkge1xuICAgICAgICBrZXlzKHN0b3JlcykuZm9yRWFjaCh0YWJsZU5hbWUgPT4ge1xuICAgICAgICAgICAgaWYgKHN0b3Jlc1t0YWJsZU5hbWVdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBwYXJzZUluZGV4U3ludGF4KHN0b3Jlc1t0YWJsZU5hbWVdKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJpbUtleSA9IGluZGV4ZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZiAocHJpbUtleS5tdWx0aSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiUHJpbWFyeSBrZXkgY2Fubm90IGJlIG11bHRpLXZhbHVlZFwiKTtcbiAgICAgICAgICAgICAgICBpbmRleGVzLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeC5hdXRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiT25seSBwcmltYXJ5IGtleSBjYW4gYmUgbWFya2VkIGFzIGF1dG9JbmNyZW1lbnQgKCsrKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpZHgua2V5UGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIkluZGV4IG11c3QgaGF2ZSBhIG5hbWUgYW5kIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3V0U2NoZW1hW3RhYmxlTmFtZV0gPSBjcmVhdGVUYWJsZVNjaGVtYSh0YWJsZU5hbWUsIHByaW1LZXksIGluZGV4ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RvcmVzKHN0b3Jlcykge1xuICAgICAgICBjb25zdCBkYiA9IHRoaXMuZGI7XG4gICAgICAgIHRoaXMuX2NmZy5zdG9yZXNTb3VyY2UgPSB0aGlzLl9jZmcuc3RvcmVzU291cmNlID9cbiAgICAgICAgICAgIGV4dGVuZCh0aGlzLl9jZmcuc3RvcmVzU291cmNlLCBzdG9yZXMpIDpcbiAgICAgICAgICAgIHN0b3JlcztcbiAgICAgICAgY29uc3QgdmVyc2lvbnMgPSBkYi5fdmVyc2lvbnM7XG4gICAgICAgIGNvbnN0IHN0b3Jlc1NwZWMgPSB7fTtcbiAgICAgICAgbGV0IGRic2NoZW1hID0ge307XG4gICAgICAgIHZlcnNpb25zLmZvckVhY2godmVyc2lvbiA9PiB7XG4gICAgICAgICAgICBleHRlbmQoc3RvcmVzU3BlYywgdmVyc2lvbi5fY2ZnLnN0b3Jlc1NvdXJjZSk7XG4gICAgICAgICAgICBkYnNjaGVtYSA9ICh2ZXJzaW9uLl9jZmcuZGJzY2hlbWEgPSB7fSk7XG4gICAgICAgICAgICB2ZXJzaW9uLl9wYXJzZVN0b3Jlc1NwZWMoc3RvcmVzU3BlYywgZGJzY2hlbWEpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGIuX2RiU2NoZW1hID0gZGJzY2hlbWE7XG4gICAgICAgIHJlbW92ZVRhYmxlc0FwaShkYiwgW2RiLl9hbGxUYWJsZXMsIGRiLCBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdKTtcbiAgICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLl9hbGxUYWJsZXMsIGRiLCBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGUsIHRoaXMuX2NmZy50YWJsZXNdLCBrZXlzKGRic2NoZW1hKSwgZGJzY2hlbWEpO1xuICAgICAgICBkYi5fc3RvcmVOYW1lcyA9IGtleXMoZGJzY2hlbWEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdXBncmFkZSh1cGdyYWRlRnVuY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fY2ZnLmNvbnRlbnRVcGdyYWRlID0gcHJvbWlzYWJsZUNoYWluKHRoaXMuX2NmZy5jb250ZW50VXBncmFkZSB8fCBub3AsIHVwZ3JhZGVGdW5jdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVmVyc2lvbkNvbnN0cnVjdG9yKGRiKSB7XG4gICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKFZlcnNpb24ucHJvdG90eXBlLCBmdW5jdGlvbiBWZXJzaW9uKHZlcnNpb25OdW1iZXIpIHtcbiAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICB0aGlzLl9jZmcgPSB7XG4gICAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uTnVtYmVyLFxuICAgICAgICAgICAgc3RvcmVzU291cmNlOiBudWxsLFxuICAgICAgICAgICAgZGJzY2hlbWE6IHt9LFxuICAgICAgICAgICAgdGFibGVzOiB7fSxcbiAgICAgICAgICAgIGNvbnRlbnRVcGdyYWRlOiBudWxsXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKSB7XG4gICAgbGV0IGRiTmFtZXNEQiA9IGluZGV4ZWREQltcIl9kYk5hbWVzREJcIl07XG4gICAgaWYgKCFkYk5hbWVzREIpIHtcbiAgICAgICAgZGJOYW1lc0RCID0gaW5kZXhlZERCW1wiX2RiTmFtZXNEQlwiXSA9IG5ldyBEZXhpZSQxKERCTkFNRVNfREIsIHtcbiAgICAgICAgICAgIGFkZG9uczogW10sXG4gICAgICAgICAgICBpbmRleGVkREIsXG4gICAgICAgICAgICBJREJLZXlSYW5nZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGRiTmFtZXNEQi52ZXJzaW9uKDEpLnN0b3Jlcyh7IGRibmFtZXM6IFwibmFtZVwiIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGJOYW1lc0RCLnRhYmxlKFwiZGJuYW1lc1wiKTtcbn1cbmZ1bmN0aW9uIGhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpIHtcbiAgICByZXR1cm4gaW5kZXhlZERCICYmIHR5cGVvZiBpbmRleGVkREIuZGF0YWJhc2VzID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBnZXREYXRhYmFzZU5hbWVzKHsgaW5kZXhlZERCLCBJREJLZXlSYW5nZSwgfSkge1xuICAgIHJldHVybiBoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKVxuICAgICAgICA/IFByb21pc2UucmVzb2x2ZShpbmRleGVkREIuZGF0YWJhc2VzKCkpLnRoZW4oKGluZm9zKSA9PiBpbmZvc1xuICAgICAgICAgICAgLm1hcCgoaW5mbykgPT4gaW5mby5uYW1lKVxuICAgICAgICAgICAgLmZpbHRlcigobmFtZSkgPT4gbmFtZSAhPT0gREJOQU1FU19EQikpXG4gICAgICAgIDogZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQiwgSURCS2V5UmFuZ2UpLnRvQ29sbGVjdGlvbigpLnByaW1hcnlLZXlzKCk7XG59XG5mdW5jdGlvbiBfb25EYXRhYmFzZUNyZWF0ZWQoeyBpbmRleGVkREIsIElEQktleVJhbmdlIH0sIG5hbWUpIHtcbiAgICAhaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQikgJiZcbiAgICAgICAgbmFtZSAhPT0gREJOQU1FU19EQiAmJlxuICAgICAgICBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkucHV0KHsgbmFtZSB9KS5jYXRjaChub3ApO1xufVxuZnVuY3Rpb24gX29uRGF0YWJhc2VEZWxldGVkKHsgaW5kZXhlZERCLCBJREJLZXlSYW5nZSB9LCBuYW1lKSB7XG4gICAgIWhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpICYmXG4gICAgICAgIG5hbWUgIT09IERCTkFNRVNfREIgJiZcbiAgICAgICAgZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQiwgSURCS2V5UmFuZ2UpLmRlbGV0ZShuYW1lKS5jYXRjaChub3ApO1xufVxuXG5mdW5jdGlvbiB2aXAoZm4pIHtcbiAgICByZXR1cm4gbmV3U2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBQU0QubGV0VGhyb3VnaCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpZGJSZWFkeSgpIHtcbiAgICB2YXIgaXNTYWZhcmkgPSAhbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEgJiZcbiAgICAgICAgL1NhZmFyaVxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICAhL0Nocm9tKGV8aXVtKVxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICBpZiAoIWlzU2FmYXJpIHx8ICFpbmRleGVkREIuZGF0YWJhc2VzKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdmFyIGludGVydmFsSWQ7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciB0cnlJZGIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleGVkREIuZGF0YWJhc2VzKCkuZmluYWxseShyZXNvbHZlKTsgfTtcbiAgICAgICAgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHRyeUlkYiwgMTAwKTtcbiAgICAgICAgdHJ5SWRiKCk7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7IHJldHVybiBjbGVhckludGVydmFsKGludGVydmFsSWQpOyB9KTtcbn1cblxuZnVuY3Rpb24gZGV4aWVPcGVuKGRiKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBkYi5fc3RhdGU7XG4gICAgY29uc3QgeyBpbmRleGVkREIgfSA9IGRiLl9kZXBzO1xuICAgIGlmIChzdGF0ZS5pc0JlaW5nT3BlbmVkIHx8IGRiLmlkYmRiKVxuICAgICAgICByZXR1cm4gc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbigoKSA9PiBzdGF0ZS5kYk9wZW5FcnJvciA/XG4gICAgICAgICAgICByZWplY3Rpb24oc3RhdGUuZGJPcGVuRXJyb3IpIDpcbiAgICAgICAgICAgIGRiKTtcbiAgICBkZWJ1ZyAmJiAoc3RhdGUub3BlbkNhbmNlbGxlci5fc3RhY2tIb2xkZXIgPSBnZXRFcnJvcldpdGhTdGFjaygpKTtcbiAgICBzdGF0ZS5pc0JlaW5nT3BlbmVkID0gdHJ1ZTtcbiAgICBzdGF0ZS5kYk9wZW5FcnJvciA9IG51bGw7XG4gICAgc3RhdGUub3BlbkNvbXBsZXRlID0gZmFsc2U7XG4gICAgY29uc3Qgb3BlbkNhbmNlbGxlciA9IHN0YXRlLm9wZW5DYW5jZWxsZXI7XG4gICAgZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxlZCgpIHtcbiAgICAgICAgaWYgKHN0YXRlLm9wZW5DYW5jZWxsZXIgIT09IG9wZW5DYW5jZWxsZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgnZGIub3BlbigpIHdhcyBjYW5jZWxsZWQnKTtcbiAgICB9XG4gICAgbGV0IHJlc29sdmVEYlJlYWR5ID0gc3RhdGUuZGJSZWFkeVJlc29sdmUsXG4gICAgdXBncmFkZVRyYW5zYWN0aW9uID0gbnVsbCwgd2FzQ3JlYXRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHRyeU9wZW5EQiA9ICgpID0+IG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKCk7XG4gICAgICAgIGlmICghaW5kZXhlZERCKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpO1xuICAgICAgICBjb25zdCBkYk5hbWUgPSBkYi5uYW1lO1xuICAgICAgICBjb25zdCByZXEgPSBzdGF0ZS5hdXRvU2NoZW1hID9cbiAgICAgICAgICAgIGluZGV4ZWREQi5vcGVuKGRiTmFtZSkgOlxuICAgICAgICAgICAgaW5kZXhlZERCLm9wZW4oZGJOYW1lLCBNYXRoLnJvdW5kKGRiLnZlcm5vICogMTApKTtcbiAgICAgICAgaWYgKCFyZXEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCk7XG4gICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgIHJlcS5vbmJsb2NrZWQgPSB3cmFwKGRiLl9maXJlT25CbG9ja2VkKTtcbiAgICAgICAgcmVxLm9udXBncmFkZW5lZWRlZCA9IHdyYXAoZSA9PiB7XG4gICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSByZXEudHJhbnNhY3Rpb247XG4gICAgICAgICAgICBpZiAoc3RhdGUuYXV0b1NjaGVtYSAmJiAhZGIuX29wdGlvbnMuYWxsb3dFbXB0eURCKSB7XG4gICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBwcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24uYWJvcnQoKTtcbiAgICAgICAgICAgICAgICByZXEucmVzdWx0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVscmVxID0gaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKGRiTmFtZSk7XG4gICAgICAgICAgICAgICAgZGVscmVxLm9uc3VjY2VzcyA9IGRlbHJlcS5vbmVycm9yID0gd3JhcCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXhjZXB0aW9ucy5Ob1N1Y2hEYXRhYmFzZShgRGF0YWJhc2UgJHtkYk5hbWV9IGRvZXNudCBleGlzdGApKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbi5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZlciA9IGUub2xkVmVyc2lvbiA+IE1hdGgucG93KDIsIDYyKSA/IDAgOiBlLm9sZFZlcnNpb247XG4gICAgICAgICAgICAgICAgd2FzQ3JlYXRlZCA9IG9sZFZlciA8IDE7XG4gICAgICAgICAgICAgICAgZGIuX25vdmlwLmlkYmRiID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICBydW5VcGdyYWRlcnMoZGIsIG9sZFZlciAvIDEwLCB1cGdyYWRlVHJhbnNhY3Rpb24sIHJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKCgpID0+IHtcbiAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBpZGJkYiA9IGRiLl9ub3ZpcC5pZGJkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCBvYmplY3RTdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcyk7XG4gICAgICAgICAgICBpZiAob2JqZWN0U3RvcmVOYW1lcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcFRyYW5zID0gaWRiZGIudHJhbnNhY3Rpb24oc2FmYXJpTXVsdGlTdG9yZUZpeChvYmplY3RTdG9yZU5hbWVzKSwgJ3JlYWRvbmx5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5hdXRvU2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEdsb2JhbFNjaGVtYShkYiwgaWRiZGIsIHRtcFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgZGIuX2RiU2NoZW1hLCB0bXBUcmFucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZlcmlmeUluc3RhbGxlZFNjaGVtYShkYiwgdG1wVHJhbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBEZXhpZSBTY2hlbWFEaWZmOiBTY2hlbWEgd2FzIGV4dGVuZGVkIHdpdGhvdXQgaW5jcmVhc2luZyB0aGUgbnVtYmVyIHBhc3NlZCB0byBkYi52ZXJzaW9uKCkuIFNvbWUgcXVlcmllcyBtYXkgZmFpbC5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIHRtcFRyYW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25uZWN0aW9ucy5wdXNoKGRiKTtcbiAgICAgICAgICAgIGlkYmRiLm9udmVyc2lvbmNoYW5nZSA9IHdyYXAoZXYgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZjRmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRiLm9uKFwidmVyc2lvbmNoYW5nZVwiKS5maXJlKGV2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWRiZGIub25jbG9zZSA9IHdyYXAoZXYgPT4ge1xuICAgICAgICAgICAgICAgIGRiLm9uKFwiY2xvc2VcIikuZmlyZShldik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh3YXNDcmVhdGVkKVxuICAgICAgICAgICAgICAgIF9vbkRhdGFiYXNlQ3JlYXRlZChkYi5fZGVwcywgZGJOYW1lKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyICYmIGVyci5uYW1lID09PSAnVW5rbm93bkVycm9yJyAmJiBzdGF0ZS5QUjEzOThfbWF4TG9vcCA+IDApIHtcbiAgICAgICAgICAgIHN0YXRlLlBSMTM5OF9tYXhMb29wLS07XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RleGllOiBXb3JrYXJvdW5kIGZvciBDaHJvbWUgVW5rbm93bkVycm9yIG9uIG9wZW4oKScpO1xuICAgICAgICAgICAgcmV0dXJuIHRyeU9wZW5EQigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBEZXhpZVByb21pc2UucmFjZShbXG4gICAgICAgIG9wZW5DYW5jZWxsZXIsXG4gICAgICAgICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyA/IERleGllUHJvbWlzZS5yZXNvbHZlKCkgOiBpZGJSZWFkeSgpKS50aGVuKHRyeU9wZW5EQilcbiAgICBdKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhyb3dJZkNhbmNlbGxlZCgpO1xuICAgICAgICBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZCA9IFtdO1xuICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUodmlwKCgpID0+IGRiLm9uLnJlYWR5LmZpcmUoZGIudmlwKSkpLnRoZW4oZnVuY3Rpb24gZmlyZVJlbWFpbmRlcnMoKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUub25SZWFkeUJlaW5nRmlyZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCByZW1haW5kZXJzID0gc3RhdGUub25SZWFkeUJlaW5nRmlyZWQucmVkdWNlKHByb21pc2FibGVDaGFpbiwgbm9wKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZCA9IFtdO1xuICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZSh2aXAoKCkgPT4gcmVtYWluZGVycyhkYi52aXApKSkudGhlbihmaXJlUmVtYWluZGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZCA9IG51bGw7XG4gICAgICAgIHN0YXRlLmlzQmVpbmdPcGVuZWQgPSBmYWxzZTtcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGRiO1xuICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIHN0YXRlLmRiT3BlbkVycm9yID0gZXJyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uICYmIHVwZ3JhZGVUcmFuc2FjdGlvbi5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgIGlmIChvcGVuQ2FuY2VsbGVyID09PSBzdGF0ZS5vcGVuQ2FuY2VsbGVyKSB7XG4gICAgICAgICAgICBkYi5fY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGVycik7XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHN0YXRlLm9wZW5Db21wbGV0ZSA9IHRydWU7XG4gICAgICAgIHJlc29sdmVEYlJlYWR5KCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGF3YWl0SXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgICB2YXIgY2FsbE5leHQgPSByZXN1bHQgPT4gaXRlcmF0b3IubmV4dChyZXN1bHQpLCBkb1Rocm93ID0gZXJyb3IgPT4gaXRlcmF0b3IudGhyb3coZXJyb3IpLCBvblN1Y2Nlc3MgPSBzdGVwKGNhbGxOZXh0KSwgb25FcnJvciA9IHN0ZXAoZG9UaHJvdyk7XG4gICAgZnVuY3Rpb24gc3RlcChnZXROZXh0KSB7XG4gICAgICAgIHJldHVybiAodmFsKSA9PiB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGdldE5leHQodmFsKSwgdmFsdWUgPSBuZXh0LnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQuZG9uZSA/IHZhbHVlIDpcbiAgICAgICAgICAgICAgICAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZS50aGVuICE9PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICAgICAgaXNBcnJheSh2YWx1ZSkgPyBQcm9taXNlLmFsbCh2YWx1ZSkudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpIDogb25TdWNjZXNzKHZhbHVlKSA6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBzdGVwKGNhbGxOZXh0KSgpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNhY3Rpb25BcmdzKG1vZGUsIF90YWJsZUFyZ3NfLCBzY29wZUZ1bmMpIHtcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGkgPCAyKVxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJUb28gZmV3IGFyZ3VtZW50c1wiKTtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShpIC0gMSk7XG4gICAgd2hpbGUgKC0taSlcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgc2NvcGVGdW5jID0gYXJncy5wb3AoKTtcbiAgICB2YXIgdGFibGVzID0gZmxhdHRlbihhcmdzKTtcbiAgICByZXR1cm4gW21vZGUsIHRhYmxlcywgc2NvcGVGdW5jXTtcbn1cbmZ1bmN0aW9uIGVudGVyVHJhbnNhY3Rpb25TY29wZShkYiwgbW9kZSwgc3RvcmVOYW1lcywgcGFyZW50VHJhbnNhY3Rpb24sIHNjb3BlRnVuYykge1xuICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb25zdCB0cmFuc2xlc3MgPSBQU0QudHJhbnNsZXNzIHx8IFBTRDtcbiAgICAgICAgY29uc3QgdHJhbnMgPSBkYi5fY3JlYXRlVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGIuX2RiU2NoZW1hLCBwYXJlbnRUcmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IHpvbmVQcm9wcyA9IHtcbiAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcbiAgICAgICAgICAgIHRyYW5zbGVzczogdHJhbnNsZXNzXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgdHJhbnMuaWRidHJhbnMgPSBwYXJlbnRUcmFuc2FjdGlvbi5pZGJ0cmFucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdHJhbnMuY3JlYXRlKCk7XG4gICAgICAgICAgICAgICAgZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGlmIChleC5uYW1lID09PSBlcnJuYW1lcy5JbnZhbGlkU3RhdGUgJiYgZGIuaXNPcGVuKCkgJiYgLS1kYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRGV4aWU6IE5lZWQgdG8gcmVvcGVuIGRiJyk7XG4gICAgICAgICAgICAgICAgICAgIGRiLl9jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGIub3BlbigpLnRoZW4oKCkgPT4gZW50ZXJUcmFuc2FjdGlvblNjb3BlKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBudWxsLCBzY29wZUZ1bmMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NvcGVGdW5jSXNBc3luYyA9IGlzQXN5bmNGdW5jdGlvbihzY29wZUZ1bmMpO1xuICAgICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuICAgICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmV0dXJuVmFsdWU7XG4gICAgICAgIGNvbnN0IHByb21pc2VGb2xsb3dlZCA9IERleGllUHJvbWlzZS5mb2xsb3coKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBzY29wZUZ1bmMuY2FsbCh0cmFucywgdHJhbnMpO1xuICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlRnVuY0lzQXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlY3JlbWVudG9yID0gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMuYmluZChudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUudGhlbihkZWNyZW1lbnRvciwgZGVjcmVtZW50b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmV0dXJuVmFsdWUubmV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmV0dXJuVmFsdWUudGhyb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBhd2FpdEl0ZXJhdG9yKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHpvbmVQcm9wcyk7XG4gICAgICAgIHJldHVybiAocmV0dXJuVmFsdWUgJiYgdHlwZW9mIHJldHVyblZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgRGV4aWVQcm9taXNlLnJlc29sdmUocmV0dXJuVmFsdWUpLnRoZW4oeCA9PiB0cmFucy5hY3RpdmUgP1xuICAgICAgICAgICAgICAgIHhcbiAgICAgICAgICAgICAgICA6IHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5QcmVtYXR1cmVDb21taXQoXCJUcmFuc2FjdGlvbiBjb21taXR0ZWQgdG9vIGVhcmx5LiBTZWUgaHR0cDovL2JpdC5seS8ya2Rja01uXCIpKSlcbiAgICAgICAgICAgIDogcHJvbWlzZUZvbGxvd2VkLnRoZW4oKCkgPT4gcmV0dXJuVmFsdWUpKS50aGVuKHggPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgIHRyYW5zLl9yZXNvbHZlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnMuX2NvbXBsZXRpb24udGhlbigoKSA9PiB4KTtcbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICB0cmFucy5fcmVqZWN0KGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhZChhLCB2YWx1ZSwgY291bnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBpc0FycmF5KGEpID8gYS5zbGljZSgpIDogW2FdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSlcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVWaXJ0dWFsSW5kZXhNaWRkbGV3YXJlKGRvd24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5kb3duLFxuICAgICAgICB0YWJsZSh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gZG93bi50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWEgfSA9IHRhYmxlO1xuICAgICAgICAgICAgY29uc3QgaW5kZXhMb29rdXAgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGFsbFZpcnR1YWxJbmRleGVzID0gW107XG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRWaXJ0dWFsSW5kZXhlcyhrZXlQYXRoLCBrZXlUYWlsLCBsb3dMZXZlbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5UGF0aEFsaWFzID0gZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4TGlzdCA9IChpbmRleExvb2t1cFtrZXlQYXRoQWxpYXNdID0gaW5kZXhMb29rdXBba2V5UGF0aEFsaWFzXSB8fCBbXSk7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5TGVuZ3RoID0ga2V5UGF0aCA9PSBudWxsID8gMCA6IHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/IDEgOiBrZXlQYXRoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1ZpcnR1YWwgPSBrZXlUYWlsID4gMDtcbiAgICAgICAgICAgICAgICBjb25zdCB2aXJ0dWFsSW5kZXggPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmxvd0xldmVsSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGlzVmlydHVhbCxcbiAgICAgICAgICAgICAgICAgICAga2V5VGFpbCxcbiAgICAgICAgICAgICAgICAgICAga2V5TGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBleHRyYWN0S2V5OiBnZXRLZXlFeHRyYWN0b3Ioa2V5UGF0aCksXG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZTogIWlzVmlydHVhbCAmJiBsb3dMZXZlbEluZGV4LnVuaXF1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW5kZXhMaXN0LnB1c2godmlydHVhbEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXZpcnR1YWxJbmRleC5pc1ByaW1hcnlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsVmlydHVhbEluZGV4ZXMucHVzaCh2aXJ0dWFsSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5TGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aXJ0dWFsS2V5UGF0aCA9IGtleUxlbmd0aCA9PT0gMiA/XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoWzBdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGguc2xpY2UoMCwga2V5TGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZpcnR1YWxJbmRleGVzKHZpcnR1YWxLZXlQYXRoLCBrZXlUYWlsICsgMSwgbG93TGV2ZWxJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4TGlzdC5zb3J0KChhLCBiKSA9PiBhLmtleVRhaWwgLSBiLmtleVRhaWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXJ0dWFsSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmltYXJ5S2V5ID0gYWRkVmlydHVhbEluZGV4ZXMoc2NoZW1hLnByaW1hcnlLZXkua2V5UGF0aCwgMCwgc2NoZW1hLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgaW5kZXhMb29rdXBbXCI6aWRcIl0gPSBbcHJpbWFyeUtleV07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHNjaGVtYS5pbmRleGVzKSB7XG4gICAgICAgICAgICAgICAgYWRkVmlydHVhbEluZGV4ZXMoaW5kZXgua2V5UGF0aCwgMCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZmluZEJlc3RJbmRleChrZXlQYXRoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaW5kZXhMb29rdXBbZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICYmIHJlc3VsdFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJhbmdlKHJhbmdlLCBrZXlUYWlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogcmFuZ2UudHlwZSA9PT0gMSAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgMiAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbG93ZXI6IHBhZChyYW5nZS5sb3dlciwgcmFuZ2UubG93ZXJPcGVuID8gZG93bi5NQVhfS0VZIDogZG93bi5NSU5fS0VZLCBrZXlUYWlsKSxcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB1cHBlcjogcGFkKHJhbmdlLnVwcGVyLCByYW5nZS51cHBlck9wZW4gPyBkb3duLk1JTl9LRVkgOiBkb3duLk1BWF9LRVksIGtleVRhaWwpLFxuICAgICAgICAgICAgICAgICAgICB1cHBlck9wZW46IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdHJhbnNsYXRlUmVxdWVzdChyZXEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHJlcS5xdWVyeS5pbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXguaXNWaXJ0dWFsID8ge1xuICAgICAgICAgICAgICAgICAgICAuLi5yZXEsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB0cmFuc2xhdGVSYW5nZShyZXEucXVlcnkucmFuZ2UsIGluZGV4LmtleVRhaWwpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IDogcmVxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIC4uLnRhYmxlLFxuICAgICAgICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgICAgICAgICAuLi5zY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXksXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXM6IGFsbFZpcnR1YWxJbmRleGVzLFxuICAgICAgICAgICAgICAgICAgICBnZXRJbmRleEJ5S2V5UGF0aDogZmluZEJlc3RJbmRleFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY291bnQocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5jb3VudCh0cmFuc2xhdGVSZXF1ZXN0KHJlcSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcXVlcnkocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5xdWVyeSh0cmFuc2xhdGVSZXF1ZXN0KHJlcSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3BlbkN1cnNvcihyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBrZXlUYWlsLCBpc1ZpcnR1YWwsIGtleUxlbmd0aCB9ID0gcmVxLnF1ZXJ5LmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmlydHVhbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5vcGVuQ3Vyc29yKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVZpcnR1YWxDdXJzb3IoY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBfY29udGludWUoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ICE9IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUocGFkKGtleSwgcmVxLnJldmVyc2UgPyBkb3duLk1BWF9LRVkgOiBkb3duLk1JTl9LRVksIGtleVRhaWwpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS51bmlxdWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKGN1cnNvci5rZXkuc2xpY2UoMCwga2V5TGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQocmVxLnJldmVyc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGRvd24uTUlOX0tFWVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZG93bi5NQVhfS0VZLCBrZXlUYWlsKSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2aXJ0dWFsQ3Vyc29yID0gT2JqZWN0LmNyZWF0ZShjdXJzb3IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTogeyB2YWx1ZTogX2NvbnRpbnVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVQcmltYXJ5S2V5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlKGtleSwgcHJpbWFyeUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleShwYWQoa2V5LCBkb3duLk1BWF9LRVksIGtleVRhaWwpLCBwcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjdXJzb3Iua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleUxlbmd0aCA9PT0gMSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5WzBdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkuc2xpY2UoMCwga2V5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpcnR1YWxDdXJzb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm9wZW5DdXJzb3IodHJhbnNsYXRlUmVxdWVzdChyZXEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oY3Vyc29yID0+IGN1cnNvciAmJiBjcmVhdGVWaXJ0dWFsQ3Vyc29yKGN1cnNvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IHZpcnR1YWxJbmRleE1pZGRsZXdhcmUgPSB7XG4gICAgc3RhY2s6IFwiZGJjb3JlXCIsXG4gICAgbmFtZTogXCJWaXJ0dWFsSW5kZXhNaWRkbGV3YXJlXCIsXG4gICAgbGV2ZWw6IDEsXG4gICAgY3JlYXRlOiBjcmVhdGVWaXJ0dWFsSW5kZXhNaWRkbGV3YXJlXG59O1xuXG5mdW5jdGlvbiBnZXRPYmplY3REaWZmKGEsIGIsIHJ2LCBwcmZ4KSB7XG4gICAgcnYgPSBydiB8fCB7fTtcbiAgICBwcmZ4ID0gcHJmeCB8fCAnJztcbiAgICBrZXlzKGEpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgaWYgKCFoYXNPd24oYiwgcHJvcCkpIHtcbiAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhcCA9IGFbcHJvcF0sIGJwID0gYltwcm9wXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXAgPT09ICdvYmplY3QnICYmIHR5cGVvZiBicCA9PT0gJ29iamVjdCcgJiYgYXAgJiYgYnApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcFR5cGVOYW1lID0gdG9TdHJpbmdUYWcoYXApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJwVHlwZU5hbWUgPSB0b1N0cmluZ1RhZyhicCk7XG4gICAgICAgICAgICAgICAgaWYgKGFwVHlwZU5hbWUgIT09IGJwVHlwZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gYltwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXBUeXBlTmFtZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0T2JqZWN0RGlmZihhcCwgYnAsIHJ2LCBwcmZ4ICsgcHJvcCArICcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFwICE9PSBicCkge1xuICAgICAgICAgICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFwICE9PSBicClcbiAgICAgICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAga2V5cyhiKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGlmICghaGFzT3duKGEsIHByb3ApKSB7XG4gICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJ2O1xufVxuXG5mdW5jdGlvbiBnZXRFZmZlY3RpdmVLZXlzKHByaW1hcnlLZXksIHJlcSkge1xuICAgIGlmIChyZXEudHlwZSA9PT0gJ2RlbGV0ZScpXG4gICAgICAgIHJldHVybiByZXEua2V5cztcbiAgICByZXR1cm4gcmVxLmtleXMgfHwgcmVxLnZhbHVlcy5tYXAocHJpbWFyeUtleS5leHRyYWN0S2V5KTtcbn1cblxuY29uc3QgaG9va3NNaWRkbGV3YXJlID0ge1xuICAgIHN0YWNrOiBcImRiY29yZVwiLFxuICAgIG5hbWU6IFwiSG9va3NNaWRkbGV3YXJlXCIsXG4gICAgbGV2ZWw6IDIsXG4gICAgY3JlYXRlOiAoZG93bkNvcmUpID0+ICh7XG4gICAgICAgIC4uLmRvd25Db3JlLFxuICAgICAgICB0YWJsZSh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvd25UYWJsZSA9IGRvd25Db3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCB7IHByaW1hcnlLZXkgfSA9IGRvd25UYWJsZS5zY2hlbWE7XG4gICAgICAgICAgICBjb25zdCB0YWJsZU1pZGRsZXdhcmUgPSB7XG4gICAgICAgICAgICAgICAgLi4uZG93blRhYmxlLFxuICAgICAgICAgICAgICAgIG11dGF0ZShyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHhUcmFucyA9IFBTRC50cmFucztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZWxldGluZywgY3JlYXRpbmcsIHVwZGF0aW5nIH0gPSBkeFRyYW5zLnRhYmxlKHRhYmxlTmFtZSkuaG9vaztcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyZXEudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3JlYXRpbmcuZmlyZSA9PT0gbm9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHhUcmFucy5fcHJvbWlzZSgncmVhZHdyaXRlJywgKCkgPT4gYWRkUHV0T3JEZWxldGUocmVxKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwdXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcmVhdGluZy5maXJlID09PSBub3AgJiYgdXBkYXRpbmcuZmlyZSA9PT0gbm9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHhUcmFucy5fcHJvbWlzZSgncmVhZHdyaXRlJywgKCkgPT4gYWRkUHV0T3JEZWxldGUocmVxKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGluZy5maXJlID09PSBub3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCAoKSA9PiBhZGRQdXRPckRlbGV0ZShyZXEpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZVJhbmdlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRpbmcuZmlyZSA9PT0gbm9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHhUcmFucy5fcHJvbWlzZSgncmVhZHdyaXRlJywgKCkgPT4gZGVsZXRlUmFuZ2UocmVxKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5tdXRhdGUocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYWRkUHV0T3JEZWxldGUocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkeFRyYW5zID0gUFNELnRyYW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IHJlcS5rZXlzIHx8IGdldEVmZmVjdGl2ZUtleXMocHJpbWFyeUtleSwgcmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgha2V5cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXlzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEgPSByZXEudHlwZSA9PT0gJ2FkZCcgfHwgcmVxLnR5cGUgPT09ICdwdXQnID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IC4uLnJlcSwga2V5cyB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IC4uLnJlcSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS50eXBlICE9PSAnZGVsZXRlJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudmFsdWVzID0gWy4uLnJlcS52YWx1ZXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5rZXlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5rZXlzID0gWy4uLnJlcS5rZXlzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRFeGlzdGluZ1ZhbHVlcyhkb3duVGFibGUsIHJlcSwga2V5cykudGhlbihleGlzdGluZ1ZhbHVlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dHMgPSBrZXlzLm1hcCgoa2V5LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSBleGlzdGluZ1ZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3R4ID0geyBvbmVycm9yOiBudWxsLCBvbnN1Y2Nlc3M6IG51bGwgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS50eXBlID09PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRpbmcuZmlyZS5jYWxsKGN0eCwga2V5LCBleGlzdGluZ1ZhbHVlLCBkeFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXEudHlwZSA9PT0gJ2FkZCcgfHwgZXhpc3RpbmdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWRQcmltYXJ5S2V5ID0gY3JlYXRpbmcuZmlyZS5jYWxsKGN0eCwga2V5LCByZXEudmFsdWVzW2ldLCBkeFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gbnVsbCAmJiBnZW5lcmF0ZWRQcmltYXJ5S2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBnZW5lcmF0ZWRQcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5rZXlzW2ldID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJpbWFyeUtleS5vdXRib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgocmVxLnZhbHVlc1tpXSwgcHJpbWFyeUtleS5rZXlQYXRoLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdERpZmYgPSBnZXRPYmplY3REaWZmKGV4aXN0aW5nVmFsdWUsIHJlcS52YWx1ZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkaXRpb25hbENoYW5nZXMgPSB1cGRhdGluZy5maXJlLmNhbGwoY3R4LCBvYmplY3REaWZmLCBrZXksIGV4aXN0aW5nVmFsdWUsIGR4VHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdGVkVmFsdWUgPSByZXEudmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGFkZGl0aW9uYWxDaGFuZ2VzKS5mb3JFYWNoKGtleVBhdGggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duKHJlcXVlc3RlZFZhbHVlLCBrZXlQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVkVmFsdWVba2V5UGF0aF0gPSBhZGRpdGlvbmFsQ2hhbmdlc1trZXlQYXRoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChyZXF1ZXN0ZWRWYWx1ZSwga2V5UGF0aCwgYWRkaXRpb25hbENoYW5nZXNba2V5UGF0aF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLm11dGF0ZShyZXEpLnRoZW4oKHsgZmFpbHVyZXMsIHJlc3VsdHMsIG51bUZhaWx1cmVzLCBsYXN0UmVzdWx0IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmltS2V5ID0gcmVzdWx0cyA/IHJlc3VsdHNbaV0gOiBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gY29udGV4dHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJpbUtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm9uZXJyb3IgJiYgY3R4Lm9uZXJyb3IoZmFpbHVyZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm9uc3VjY2VzcyAmJiBjdHgub25zdWNjZXNzKHJlcS50eXBlID09PSAncHV0JyAmJiBleGlzdGluZ1ZhbHVlc1tpXSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS52YWx1ZXNbaV0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBmYWlsdXJlcywgcmVzdWx0cywgbnVtRmFpbHVyZXMsIGxhc3RSZXN1bHQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRzLmZvckVhY2goY3R4ID0+IGN0eC5vbmVycm9yICYmIGN0eC5vbmVycm9yKGVycm9yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWxldGVSYW5nZShyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxldGVOZXh0Q2h1bmsocmVxLnRyYW5zLCByZXEucmFuZ2UsIDEwMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWxldGVOZXh0Q2h1bmsodHJhbnMsIHJhbmdlLCBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5xdWVyeSh7IHRyYW5zLCB2YWx1ZXM6IGZhbHNlLCBxdWVyeTogeyBpbmRleDogcHJpbWFyeUtleSwgcmFuZ2UgfSwgbGltaXQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoeyByZXN1bHQgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRQdXRPckRlbGV0ZSh7IHR5cGU6ICdkZWxldGUnLCBrZXlzOiByZXN1bHQsIHRyYW5zIH0pLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5udW1GYWlsdXJlcyA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZmFpbHVyZXM6IFtdLCBudW1GYWlsdXJlczogMCwgbGFzdFJlc3VsdDogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlTmV4dENodW5rKHRyYW5zLCB7IC4uLnJhbmdlLCBsb3dlcjogcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSwgbG93ZXJPcGVuOiB0cnVlIH0sIGxpbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRhYmxlTWlkZGxld2FyZTtcbiAgICAgICAgfSxcbiAgICB9KVxufTtcbmZ1bmN0aW9uIGdldEV4aXN0aW5nVmFsdWVzKHRhYmxlLCByZXEsIGVmZmVjdGl2ZUtleXMpIHtcbiAgICByZXR1cm4gcmVxLnR5cGUgPT09IFwiYWRkXCJcbiAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoW10pXG4gICAgICAgIDogdGFibGUuZ2V0TWFueSh7IHRyYW5zOiByZXEudHJhbnMsIGtleXM6IGVmZmVjdGl2ZUtleXMsIGNhY2hlOiBcImltbXV0YWJsZVwiIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZShrZXlzLCBjYWNoZSwgY2xvbmUpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWNhY2hlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChjYWNoZS5rZXlzLmxlbmd0aCA8IGtleXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBjYWNoZS5rZXlzLmxlbmd0aCAmJiBqIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGNtcChjYWNoZS5rZXlzW2ldLCBrZXlzW2pdKSAhPT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNsb25lID8gZGVlcENsb25lKGNhY2hlLnZhbHVlc1tpXSkgOiBjYWNoZS52YWx1ZXNbaV0pO1xuICAgICAgICAgICAgKytqO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09PSBrZXlzLmxlbmd0aCA/IHJlc3VsdCA6IG51bGw7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5jb25zdCBjYWNoZUV4aXN0aW5nVmFsdWVzTWlkZGxld2FyZSA9IHtcbiAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICBsZXZlbDogLTEsXG4gICAgY3JlYXRlOiAoY29yZSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFibGU6ICh0YWJsZU5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi50YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0TWFueTogKHJlcSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXEuY2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUuZ2V0TWFueShyZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkUmVzdWx0ID0gZ2V0RnJvbVRyYW5zYWN0aW9uQ2FjaGUocmVxLmtleXMsIHJlcS50cmFuc1tcIl9jYWNoZVwiXSwgcmVxLmNhY2hlID09PSBcImNsb25lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShjYWNoZWRSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLmdldE1hbnkocmVxKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudHJhbnNbXCJfY2FjaGVcIl0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IHJlcS5rZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHJlcS5jYWNoZSA9PT0gXCJjbG9uZVwiID8gZGVlcENsb25lKHJlcykgOiByZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG11dGF0ZTogKHJlcSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS50eXBlICE9PSBcImFkZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS50cmFuc1tcIl9jYWNoZVwiXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUubXV0YXRlKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5cbmZ1bmN0aW9uIGlzRW1wdHlSYW5nZShub2RlKSB7XG4gICAgcmV0dXJuICEoXCJmcm9tXCIgaW4gbm9kZSk7XG59XG5jb25zdCBSYW5nZVNldCA9IGZ1bmN0aW9uIChmcm9tT3JUcmVlLCB0bykge1xuICAgIGlmICh0aGlzKSB7XG4gICAgICAgIGV4dGVuZCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8geyBkOiAxLCBmcm9tOiBmcm9tT3JUcmVlLCB0bzogYXJndW1lbnRzLmxlbmd0aCA+IDEgPyB0byA6IGZyb21PclRyZWUgfSA6IHsgZDogMCB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJ2ID0gbmV3IFJhbmdlU2V0KCk7XG4gICAgICAgIGlmIChmcm9tT3JUcmVlICYmIChcImRcIiBpbiBmcm9tT3JUcmVlKSkge1xuICAgICAgICAgICAgZXh0ZW5kKHJ2LCBmcm9tT3JUcmVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxufTtcbnByb3BzKFJhbmdlU2V0LnByb3RvdHlwZSwge1xuICAgIGFkZChyYW5nZVNldCkge1xuICAgICAgICBtZXJnZVJhbmdlcyh0aGlzLCByYW5nZVNldCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgYWRkS2V5KGtleSkge1xuICAgICAgICBhZGRSYW5nZSh0aGlzLCBrZXksIGtleSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgYWRkS2V5cyhrZXlzKSB7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkUmFuZ2UodGhpcywga2V5LCBrZXkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBbaXRlcmF0b3JTeW1ib2xdKCkge1xuICAgICAgICByZXR1cm4gZ2V0UmFuZ2VTZXRJdGVyYXRvcih0aGlzKTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGFkZFJhbmdlKHRhcmdldCwgZnJvbSwgdG8pIHtcbiAgICBjb25zdCBkaWZmID0gY21wKGZyb20sIHRvKTtcbiAgICBpZiAoaXNOYU4oZGlmZikpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoZGlmZiA+IDApXG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoKTtcbiAgICBpZiAoaXNFbXB0eVJhbmdlKHRhcmdldCkpXG4gICAgICAgIHJldHVybiBleHRlbmQodGFyZ2V0LCB7IGZyb20sIHRvLCBkOiAxIH0pO1xuICAgIGNvbnN0IGxlZnQgPSB0YXJnZXQubDtcbiAgICBjb25zdCByaWdodCA9IHRhcmdldC5yO1xuICAgIGlmIChjbXAodG8sIHRhcmdldC5mcm9tKSA8IDApIHtcbiAgICAgICAgbGVmdFxuICAgICAgICAgICAgPyBhZGRSYW5nZShsZWZ0LCBmcm9tLCB0bylcbiAgICAgICAgICAgIDogKHRhcmdldC5sID0geyBmcm9tLCB0bywgZDogMSwgbDogbnVsbCwgcjogbnVsbCB9KTtcbiAgICAgICAgcmV0dXJuIHJlYmFsYW5jZSh0YXJnZXQpO1xuICAgIH1cbiAgICBpZiAoY21wKGZyb20sIHRhcmdldC50bykgPiAwKSB7XG4gICAgICAgIHJpZ2h0XG4gICAgICAgICAgICA/IGFkZFJhbmdlKHJpZ2h0LCBmcm9tLCB0bylcbiAgICAgICAgICAgIDogKHRhcmdldC5yID0geyBmcm9tLCB0bywgZDogMSwgbDogbnVsbCwgcjogbnVsbCB9KTtcbiAgICAgICAgcmV0dXJuIHJlYmFsYW5jZSh0YXJnZXQpO1xuICAgIH1cbiAgICBpZiAoY21wKGZyb20sIHRhcmdldC5mcm9tKSA8IDApIHtcbiAgICAgICAgdGFyZ2V0LmZyb20gPSBmcm9tO1xuICAgICAgICB0YXJnZXQubCA9IG51bGw7XG4gICAgICAgIHRhcmdldC5kID0gcmlnaHQgPyByaWdodC5kICsgMSA6IDE7XG4gICAgfVxuICAgIGlmIChjbXAodG8sIHRhcmdldC50bykgPiAwKSB7XG4gICAgICAgIHRhcmdldC50byA9IHRvO1xuICAgICAgICB0YXJnZXQuciA9IG51bGw7XG4gICAgICAgIHRhcmdldC5kID0gdGFyZ2V0LmwgPyB0YXJnZXQubC5kICsgMSA6IDE7XG4gICAgfVxuICAgIGNvbnN0IHJpZ2h0V2FzQ3V0T2ZmID0gIXRhcmdldC5yO1xuICAgIGlmIChsZWZ0ICYmICF0YXJnZXQubCkge1xuICAgICAgICBtZXJnZVJhbmdlcyh0YXJnZXQsIGxlZnQpO1xuICAgIH1cbiAgICBpZiAocmlnaHQgJiYgcmlnaHRXYXNDdXRPZmYpIHtcbiAgICAgICAgbWVyZ2VSYW5nZXModGFyZ2V0LCByaWdodCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VSYW5nZXModGFyZ2V0LCBuZXdTZXQpIHtcbiAgICBmdW5jdGlvbiBfYWRkUmFuZ2VTZXQodGFyZ2V0LCB7IGZyb20sIHRvLCBsLCByIH0pIHtcbiAgICAgICAgYWRkUmFuZ2UodGFyZ2V0LCBmcm9tLCB0byk7XG4gICAgICAgIGlmIChsKVxuICAgICAgICAgICAgX2FkZFJhbmdlU2V0KHRhcmdldCwgbCk7XG4gICAgICAgIGlmIChyKVxuICAgICAgICAgICAgX2FkZFJhbmdlU2V0KHRhcmdldCwgcik7XG4gICAgfVxuICAgIGlmICghaXNFbXB0eVJhbmdlKG5ld1NldCkpXG4gICAgICAgIF9hZGRSYW5nZVNldCh0YXJnZXQsIG5ld1NldCk7XG59XG5mdW5jdGlvbiByYW5nZXNPdmVybGFwKHJhbmdlU2V0MSwgcmFuZ2VTZXQyKSB7XG4gICAgY29uc3QgaTEgPSBnZXRSYW5nZVNldEl0ZXJhdG9yKHJhbmdlU2V0Mik7XG4gICAgbGV0IG5leHRSZXN1bHQxID0gaTEubmV4dCgpO1xuICAgIGlmIChuZXh0UmVzdWx0MS5kb25lKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGEgPSBuZXh0UmVzdWx0MS52YWx1ZTtcbiAgICBjb25zdCBpMiA9IGdldFJhbmdlU2V0SXRlcmF0b3IocmFuZ2VTZXQxKTtcbiAgICBsZXQgbmV4dFJlc3VsdDIgPSBpMi5uZXh0KGEuZnJvbSk7XG4gICAgbGV0IGIgPSBuZXh0UmVzdWx0Mi52YWx1ZTtcbiAgICB3aGlsZSAoIW5leHRSZXN1bHQxLmRvbmUgJiYgIW5leHRSZXN1bHQyLmRvbmUpIHtcbiAgICAgICAgaWYgKGNtcChiLmZyb20sIGEudG8pIDw9IDAgJiYgY21wKGIudG8sIGEuZnJvbSkgPj0gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjbXAoYS5mcm9tLCBiLmZyb20pIDwgMFxuICAgICAgICAgICAgPyAoYSA9IChuZXh0UmVzdWx0MSA9IGkxLm5leHQoYi5mcm9tKSkudmFsdWUpXG4gICAgICAgICAgICA6IChiID0gKG5leHRSZXN1bHQyID0gaTIubmV4dChhLmZyb20pKS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFJhbmdlU2V0SXRlcmF0b3Iobm9kZSkge1xuICAgIGxldCBzdGF0ZSA9IGlzRW1wdHlSYW5nZShub2RlKSA/IG51bGwgOiB7IHM6IDAsIG46IG5vZGUgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZXh0KGtleSkge1xuICAgICAgICAgICAgY29uc3Qga2V5UHJvdmlkZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIHdoaWxlIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUucykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlQcm92aWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5uLmwgJiYgY21wKGtleSwgc3RhdGUubi5mcm9tKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4ubCwgczogMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLm4ubClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IHVwOiBzdGF0ZSwgbjogc3RhdGUubi5sLCBzOiAxIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnMgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXlQcm92aWRlZCB8fCBjbXAoa2V5LCBzdGF0ZS5uLnRvKSA8PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBzdGF0ZS5uLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUubi5yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUucyA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IHVwOiBzdGF0ZSwgbjogc3RhdGUubi5yLCBzOiAwIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGUudXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiByZWJhbGFuY2UodGFyZ2V0KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBkaWZmID0gKCgoX2EgPSB0YXJnZXQucikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmQpIHx8IDApIC0gKCgoX2IgPSB0YXJnZXQubCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmQpIHx8IDApO1xuICAgIGNvbnN0IHIgPSBkaWZmID4gMSA/IFwiclwiIDogZGlmZiA8IC0xID8gXCJsXCIgOiBcIlwiO1xuICAgIGlmIChyKSB7XG4gICAgICAgIGNvbnN0IGwgPSByID09PSBcInJcIiA/IFwibFwiIDogXCJyXCI7XG4gICAgICAgIGNvbnN0IHJvb3RDbG9uZSA9IHsgLi4udGFyZ2V0IH07XG4gICAgICAgIGNvbnN0IG9sZFJvb3RSaWdodCA9IHRhcmdldFtyXTtcbiAgICAgICAgdGFyZ2V0LmZyb20gPSBvbGRSb290UmlnaHQuZnJvbTtcbiAgICAgICAgdGFyZ2V0LnRvID0gb2xkUm9vdFJpZ2h0LnRvO1xuICAgICAgICB0YXJnZXRbcl0gPSBvbGRSb290UmlnaHRbcl07XG4gICAgICAgIHJvb3RDbG9uZVtyXSA9IG9sZFJvb3RSaWdodFtsXTtcbiAgICAgICAgdGFyZ2V0W2xdID0gcm9vdENsb25lO1xuICAgICAgICByb290Q2xvbmUuZCA9IGNvbXB1dGVEZXB0aChyb290Q2xvbmUpO1xuICAgIH1cbiAgICB0YXJnZXQuZCA9IGNvbXB1dGVEZXB0aCh0YXJnZXQpO1xufVxuZnVuY3Rpb24gY29tcHV0ZURlcHRoKHsgciwgbCB9KSB7XG4gICAgcmV0dXJuIChyID8gKGwgPyBNYXRoLm1heChyLmQsIGwuZCkgOiByLmQpIDogbCA/IGwuZCA6IDApICsgMTtcbn1cblxuY29uc3Qgb2JzZXJ2YWJpbGl0eU1pZGRsZXdhcmUgPSB7XG4gICAgc3RhY2s6IFwiZGJjb3JlXCIsXG4gICAgbGV2ZWw6IDAsXG4gICAgY3JlYXRlOiAoY29yZSkgPT4ge1xuICAgICAgICBjb25zdCBkYk5hbWUgPSBjb3JlLnNjaGVtYS5uYW1lO1xuICAgICAgICBjb25zdCBGVUxMX1JBTkdFID0gbmV3IFJhbmdlU2V0KGNvcmUuTUlOX0tFWSwgY29yZS5NQVhfS0VZKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvcmUsXG4gICAgICAgICAgICB0YWJsZTogKHRhYmxlTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hIH0gPSB0YWJsZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByaW1hcnlLZXkgfSA9IHNjaGVtYTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGV4dHJhY3RLZXksIG91dGJvdW5kIH0gPSBwcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlQ2xvbmUgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhYmxlLFxuICAgICAgICAgICAgICAgICAgICBtdXRhdGU6IChyZXEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zID0gcmVxLnRyYW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXV0YXRlZFBhcnRzID0gdHJhbnMubXV0YXRlZFBhcnRzIHx8ICh0cmFucy5tdXRhdGVkUGFydHMgPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnZXRSYW5nZVNldCA9IChpbmRleE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0ID0gYGlkYjovLyR7ZGJOYW1lfS8ke3RhYmxlTmFtZX0vJHtpbmRleE5hbWV9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG11dGF0ZWRQYXJ0c1twYXJ0XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobXV0YXRlZFBhcnRzW3BhcnRdID0gbmV3IFJhbmdlU2V0KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwa1JhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxzUmFuZ2VTZXQgPSBnZXRSYW5nZVNldChcIjpkZWxzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0eXBlIH0gPSByZXE7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgW2tleXMsIG5ld09ianNdID0gcmVxLnR5cGUgPT09IFwiZGVsZXRlUmFuZ2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gW3JlcS5yYW5nZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlcS50eXBlID09PSBcImRlbGV0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gW3JlcS5rZXlzXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlcS52YWx1ZXMubGVuZ3RoIDwgNTBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gW1tdLCByZXEudmFsdWVzXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZENhY2hlID0gcmVxLnRyYW5zW1wiX2NhY2hlXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm11dGF0ZShyZXEpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGtleXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSBcImRlbGV0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5cyA9IHJlcy5yZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZEtleXMoa2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZE9ianMgPSBnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZShrZXlzLCBvbGRDYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2xkT2JqcyAmJiB0eXBlICE9PSBcImFkZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkS2V5cyhrZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkT2JqcyB8fCBuZXdPYmpzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja0FmZmVjdGVkSW5kZXhlcyhnZXRSYW5nZVNldCwgc2NoZW1hLCBvbGRPYmpzLCBuZXdPYmpzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0geyBmcm9tOiBrZXlzLmxvd2VyLCB0bzoga2V5cy51cHBlciB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGQocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGQoRlVMTF9SQU5HRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGQoRlVMTF9SQU5HRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYS5pbmRleGVzLmZvckVhY2goaWR4ID0+IGdldFJhbmdlU2V0KGlkeC5uYW1lKS5hZGQoRlVMTF9SQU5HRSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBnZXRSYW5nZSA9ICh7IHF1ZXJ5OiB7IGluZGV4LCByYW5nZSB9LCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBSYW5nZVNldCgoX2EgPSByYW5nZS5sb3dlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29yZS5NSU5fS0VZLCAoX2IgPSByYW5nZS51cHBlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29yZS5NQVhfS0VZKSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRTdWJzY3JpYmVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAocmVxKSA9PiBbcHJpbWFyeUtleSwgbmV3IFJhbmdlU2V0KHJlcS5rZXkpXSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0TWFueTogKHJlcSkgPT4gW3ByaW1hcnlLZXksIG5ldyBSYW5nZVNldCgpLmFkZEtleXMocmVxLmtleXMpXSxcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IGdldFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogZ2V0UmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9wZW5DdXJzb3I6IGdldFJhbmdlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAga2V5cyhyZWFkU3Vic2NyaWJlcnMpLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGFibGVDbG9uZVttZXRob2RdID0gZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzdWJzY3IgfSA9IFBTRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJzY3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnZXRSYW5nZVNldCA9IChpbmRleE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydCA9IGBpZGI6Ly8ke2RiTmFtZX0vJHt0YWJsZU5hbWV9LyR7aW5kZXhOYW1lfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoc3Vic2NyW3BhcnRdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3Vic2NyW3BhcnRdID0gbmV3IFJhbmdlU2V0KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBrUmFuZ2VTZXQgPSBnZXRSYW5nZVNldChcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxzUmFuZ2VTZXQgPSBnZXRSYW5nZVNldChcIjpkZWxzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtxdWVyaWVkSW5kZXgsIHF1ZXJpZWRSYW5nZXNdID0gcmVhZFN1YnNjcmliZXJzW21ldGhvZF0ocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRSYW5nZVNldChxdWVyaWVkSW5kZXgubmFtZSB8fCBcIlwiKS5hZGQocXVlcmllZFJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFxdWVyaWVkSW5kZXguaXNQcmltYXJ5S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiY291bnRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZChGVUxMX1JBTkdFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXNQcm9taXNlID0gbWV0aG9kID09PSBcInF1ZXJ5XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRib3VuZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS52YWx1ZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZS5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnJlcSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZVttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJxdWVyeVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRib3VuZCAmJiByZXEudmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1Byb21pc2UudGhlbigoeyByZXN1bHQ6IHJlc3VsdGluZ0tleXMgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkS2V5cyhyZXN1bHRpbmdLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcEtleXMgPSByZXEudmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlcy5yZXN1bHQubWFwKGV4dHJhY3RLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlcy5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEudmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZEtleXMocEtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZEtleXMocEtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJvcGVuQ3Vyc29yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3YW50VmFsdWVzID0gcmVxLnZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjdXJzb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoY3Vyc29yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGRLZXkoY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBrZXkgPSBjdXJzb3IucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGRLZXkocGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbnRWYWx1ZXMgJiYgcGtSYW5nZVNldC5hZGRLZXkoY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZUNsb25lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHRyYWNrQWZmZWN0ZWRJbmRleGVzKGdldFJhbmdlU2V0LCBzY2hlbWEsIG9sZE9ianMsIG5ld09ianMpIHtcbiAgICBmdW5jdGlvbiBhZGRBZmZlY3RlZEluZGV4KGl4KSB7XG4gICAgICAgIGNvbnN0IHJhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoaXgubmFtZSB8fCBcIlwiKTtcbiAgICAgICAgZnVuY3Rpb24gZXh0cmFjdEtleShvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogIT0gbnVsbCA/IGl4LmV4dHJhY3RLZXkob2JqKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkS2V5T3JLZXlzID0gKGtleSkgPT4gaXgubXVsdGlFbnRyeSAmJiBpc0FycmF5KGtleSlcbiAgICAgICAgICAgID8ga2V5LmZvckVhY2goa2V5ID0+IHJhbmdlU2V0LmFkZEtleShrZXkpKVxuICAgICAgICAgICAgOiByYW5nZVNldC5hZGRLZXkoa2V5KTtcbiAgICAgICAgKG9sZE9ianMgfHwgbmV3T2JqcykuZm9yRWFjaCgoXywgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2xkS2V5ID0gb2xkT2JqcyAmJiBleHRyYWN0S2V5KG9sZE9ianNbaV0pO1xuICAgICAgICAgICAgY29uc3QgbmV3S2V5ID0gbmV3T2JqcyAmJiBleHRyYWN0S2V5KG5ld09ianNbaV0pO1xuICAgICAgICAgICAgaWYgKGNtcChvbGRLZXksIG5ld0tleSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkS2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGFkZEtleU9yS2V5cyhvbGRLZXkpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdLZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgYWRkS2V5T3JLZXlzKG5ld0tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY2hlbWEuaW5kZXhlcy5mb3JFYWNoKGFkZEFmZmVjdGVkSW5kZXgpO1xufVxuXG5jbGFzcyBEZXhpZSQxIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX21pZGRsZXdhcmVzID0ge307XG4gICAgICAgIHRoaXMudmVybm8gPSAwO1xuICAgICAgICBjb25zdCBkZXBzID0gRGV4aWUkMS5kZXBlbmRlbmNpZXM7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zID0ge1xuICAgICAgICAgICAgYWRkb25zOiBEZXhpZSQxLmFkZG9ucyxcbiAgICAgICAgICAgIGF1dG9PcGVuOiB0cnVlLFxuICAgICAgICAgICAgaW5kZXhlZERCOiBkZXBzLmluZGV4ZWREQixcbiAgICAgICAgICAgIElEQktleVJhbmdlOiBkZXBzLklEQktleVJhbmdlLFxuICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kZXBzID0ge1xuICAgICAgICAgICAgaW5kZXhlZERCOiBvcHRpb25zLmluZGV4ZWREQixcbiAgICAgICAgICAgIElEQktleVJhbmdlOiBvcHRpb25zLklEQktleVJhbmdlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgYWRkb25zLCB9ID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fZGJTY2hlbWEgPSB7fTtcbiAgICAgICAgdGhpcy5fdmVyc2lvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fc3RvcmVOYW1lcyA9IFtdO1xuICAgICAgICB0aGlzLl9hbGxUYWJsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5pZGJkYiA9IG51bGw7XG4gICAgICAgIHRoaXMuX25vdmlwID0gdGhpcztcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICBkYk9wZW5FcnJvcjogbnVsbCxcbiAgICAgICAgICAgIGlzQmVpbmdPcGVuZWQ6IGZhbHNlLFxuICAgICAgICAgICAgb25SZWFkeUJlaW5nRmlyZWQ6IG51bGwsXG4gICAgICAgICAgICBvcGVuQ29tcGxldGU6IGZhbHNlLFxuICAgICAgICAgICAgZGJSZWFkeVJlc29sdmU6IG5vcCxcbiAgICAgICAgICAgIGRiUmVhZHlQcm9taXNlOiBudWxsLFxuICAgICAgICAgICAgY2FuY2VsT3Blbjogbm9wLFxuICAgICAgICAgICAgb3BlbkNhbmNlbGxlcjogbnVsbCxcbiAgICAgICAgICAgIGF1dG9TY2hlbWE6IHRydWUsXG4gICAgICAgICAgICBQUjEzOThfbWF4TG9vcDogM1xuICAgICAgICB9O1xuICAgICAgICBzdGF0ZS5kYlJlYWR5UHJvbWlzZSA9IG5ldyBEZXhpZVByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5kYlJlYWR5UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5vcGVuQ2FuY2VsbGVyID0gbmV3IERleGllUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5jYW5jZWxPcGVuID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5vbiA9IEV2ZW50cyh0aGlzLCBcInBvcHVsYXRlXCIsIFwiYmxvY2tlZFwiLCBcInZlcnNpb25jaGFuZ2VcIiwgXCJjbG9zZVwiLCB7IHJlYWR5OiBbcHJvbWlzYWJsZUNoYWluLCBub3BdIH0pO1xuICAgICAgICB0aGlzLm9uLnJlYWR5LnN1YnNjcmliZSA9IG92ZXJyaWRlKHRoaXMub24ucmVhZHkuc3Vic2NyaWJlLCBzdWJzY3JpYmUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChzdWJzY3JpYmVyLCBiU3RpY2t5KSA9PiB7XG4gICAgICAgICAgICAgICAgRGV4aWUkMS52aXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUub3BlbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmRiT3BlbkVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERleGllUHJvbWlzZS5yZXNvbHZlKCkudGhlbihzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiU3RpY2t5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQucHVzaChzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiU3RpY2t5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRiID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYlN0aWNreSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLm9uLnJlYWR5LnVuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5vbi5yZWFkeS51bnN1YnNjcmliZSh1bnN1YnNjcmliZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLkNvbGxlY3Rpb24gPSBjcmVhdGVDb2xsZWN0aW9uQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgIHRoaXMuVGFibGUgPSBjcmVhdGVUYWJsZUNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICB0aGlzLlRyYW5zYWN0aW9uID0gY3JlYXRlVHJhbnNhY3Rpb25Db25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgdGhpcy5WZXJzaW9uID0gY3JlYXRlVmVyc2lvbkNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICB0aGlzLldoZXJlQ2xhdXNlID0gY3JlYXRlV2hlcmVDbGF1c2VDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgdGhpcy5vbihcInZlcnNpb25jaGFuZ2VcIiwgZXYgPT4ge1xuICAgICAgICAgICAgaWYgKGV2Lm5ld1ZlcnNpb24gPiAwKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQW5vdGhlciBjb25uZWN0aW9uIHdhbnRzIHRvIHVwZ3JhZGUgZGF0YWJhc2UgJyR7dGhpcy5uYW1lfScuIENsb3NpbmcgZGIgbm93IHRvIHJlc3VtZSB0aGUgdXBncmFkZS5gKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEFub3RoZXIgY29ubmVjdGlvbiB3YW50cyB0byBkZWxldGUgZGF0YWJhc2UgJyR7dGhpcy5uYW1lfScuIENsb3NpbmcgZGIgbm93IHRvIHJlc3VtZSB0aGUgZGVsZXRlIHJlcXVlc3QuYCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKFwiYmxvY2tlZFwiLCBldiA9PiB7XG4gICAgICAgICAgICBpZiAoIWV2Lm5ld1ZlcnNpb24gfHwgZXYubmV3VmVyc2lvbiA8IGV2Lm9sZFZlcnNpb24pXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBEZXhpZS5kZWxldGUoJyR7dGhpcy5uYW1lfScpIHdhcyBibG9ja2VkYCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBVcGdyYWRlICcke3RoaXMubmFtZX0nIGJsb2NrZWQgYnkgb3RoZXIgY29ubmVjdGlvbiBob2xkaW5nIHZlcnNpb24gJHtldi5vbGRWZXJzaW9uIC8gMTB9YCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9tYXhLZXkgPSBnZXRNYXhLZXkob3B0aW9ucy5JREJLZXlSYW5nZSk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVRyYW5zYWN0aW9uID0gKG1vZGUsIHN0b3JlTmFtZXMsIGRic2NoZW1hLCBwYXJlbnRUcmFuc2FjdGlvbikgPT4gbmV3IHRoaXMuVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGJzY2hlbWEsIHRoaXMuX29wdGlvbnMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5LCBwYXJlbnRUcmFuc2FjdGlvbik7XG4gICAgICAgIHRoaXMuX2ZpcmVPbkJsb2NrZWQgPSBldiA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uKFwiYmxvY2tlZFwiKS5maXJlKGV2KTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcihjID0+IGMubmFtZSA9PT0gdGhpcy5uYW1lICYmIGMgIT09IHRoaXMgJiYgIWMuX3N0YXRlLnZjRmlyZWQpXG4gICAgICAgICAgICAgICAgLm1hcChjID0+IGMub24oXCJ2ZXJzaW9uY2hhbmdlXCIpLmZpcmUoZXYpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51c2UodmlydHVhbEluZGV4TWlkZGxld2FyZSk7XG4gICAgICAgIHRoaXMudXNlKGhvb2tzTWlkZGxld2FyZSk7XG4gICAgICAgIHRoaXMudXNlKG9ic2VydmFiaWxpdHlNaWRkbGV3YXJlKTtcbiAgICAgICAgdGhpcy51c2UoY2FjaGVFeGlzdGluZ1ZhbHVlc01pZGRsZXdhcmUpO1xuICAgICAgICB0aGlzLnZpcCA9IE9iamVjdC5jcmVhdGUodGhpcywgeyBfdmlwOiB7IHZhbHVlOiB0cnVlIH0gfSk7XG4gICAgICAgIGFkZG9ucy5mb3JFYWNoKGFkZG9uID0+IGFkZG9uKHRoaXMpKTtcbiAgICB9XG4gICAgdmVyc2lvbih2ZXJzaW9uTnVtYmVyKSB7XG4gICAgICAgIGlmIChpc05hTih2ZXJzaW9uTnVtYmVyKSB8fCB2ZXJzaW9uTnVtYmVyIDwgMC4xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuVHlwZShgR2l2ZW4gdmVyc2lvbiBpcyBub3QgYSBwb3NpdGl2ZSBudW1iZXJgKTtcbiAgICAgICAgdmVyc2lvbk51bWJlciA9IE1hdGgucm91bmQodmVyc2lvbk51bWJlciAqIDEwKSAvIDEwO1xuICAgICAgICBpZiAodGhpcy5pZGJkYiB8fCB0aGlzLl9zdGF0ZS5pc0JlaW5nT3BlbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiQ2Fubm90IGFkZCB2ZXJzaW9uIHdoZW4gZGF0YWJhc2UgaXMgb3BlblwiKTtcbiAgICAgICAgdGhpcy52ZXJubyA9IE1hdGgubWF4KHRoaXMudmVybm8sIHZlcnNpb25OdW1iZXIpO1xuICAgICAgICBjb25zdCB2ZXJzaW9ucyA9IHRoaXMuX3ZlcnNpb25zO1xuICAgICAgICB2YXIgdmVyc2lvbkluc3RhbmNlID0gdmVyc2lvbnMuZmlsdGVyKHYgPT4gdi5fY2ZnLnZlcnNpb24gPT09IHZlcnNpb25OdW1iZXIpWzBdO1xuICAgICAgICBpZiAodmVyc2lvbkluc3RhbmNlKVxuICAgICAgICAgICAgcmV0dXJuIHZlcnNpb25JbnN0YW5jZTtcbiAgICAgICAgdmVyc2lvbkluc3RhbmNlID0gbmV3IHRoaXMuVmVyc2lvbih2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgdmVyc2lvbnMucHVzaCh2ZXJzaW9uSW5zdGFuY2UpO1xuICAgICAgICB2ZXJzaW9ucy5zb3J0KGxvd2VyVmVyc2lvbkZpcnN0KTtcbiAgICAgICAgdmVyc2lvbkluc3RhbmNlLnN0b3Jlcyh7fSk7XG4gICAgICAgIHRoaXMuX3N0YXRlLmF1dG9TY2hlbWEgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHZlcnNpb25JbnN0YW5jZTtcbiAgICB9XG4gICAgX3doZW5SZWFkeShmbikge1xuICAgICAgICByZXR1cm4gKHRoaXMuaWRiZGIgJiYgKHRoaXMuX3N0YXRlLm9wZW5Db21wbGV0ZSB8fCBQU0QubGV0VGhyb3VnaCB8fCB0aGlzLl92aXApKSA/IGZuKCkgOiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5vcGVuQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKHRoaXMuX3N0YXRlLmRiT3BlbkVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXRlLmlzQmVpbmdPcGVuZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMuYXV0b09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMub3BlbigpLmNhdGNoKG5vcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5kYlJlYWR5UHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pLnRoZW4oZm4pO1xuICAgIH1cbiAgICB1c2UoeyBzdGFjaywgY3JlYXRlLCBsZXZlbCwgbmFtZSB9KSB7XG4gICAgICAgIGlmIChuYW1lKVxuICAgICAgICAgICAgdGhpcy51bnVzZSh7IHN0YWNrLCBuYW1lIH0pO1xuICAgICAgICBjb25zdCBtaWRkbGV3YXJlcyA9IHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSB8fCAodGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdID0gW10pO1xuICAgICAgICBtaWRkbGV3YXJlcy5wdXNoKHsgc3RhY2ssIGNyZWF0ZSwgbGV2ZWw6IGxldmVsID09IG51bGwgPyAxMCA6IGxldmVsLCBuYW1lIH0pO1xuICAgICAgICBtaWRkbGV3YXJlcy5zb3J0KChhLCBiKSA9PiBhLmxldmVsIC0gYi5sZXZlbCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1bnVzZSh7IHN0YWNrLCBuYW1lLCBjcmVhdGUgfSkge1xuICAgICAgICBpZiAoc3RhY2sgJiYgdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdKSB7XG4gICAgICAgICAgICB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10gPSB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10uZmlsdGVyKG13ID0+IGNyZWF0ZSA/IG13LmNyZWF0ZSAhPT0gY3JlYXRlIDpcbiAgICAgICAgICAgICAgICBuYW1lID8gbXcubmFtZSAhPT0gbmFtZSA6XG4gICAgICAgICAgICAgICAgICAgIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3BlbigpIHtcbiAgICAgICAgcmV0dXJuIGRleGllT3Blbih0aGlzKTtcbiAgICB9XG4gICAgX2Nsb3NlKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBjb25zdCBpZHggPSBjb25uZWN0aW9ucy5pbmRleE9mKHRoaXMpO1xuICAgICAgICBpZiAoaWR4ID49IDApXG4gICAgICAgICAgICBjb25uZWN0aW9ucy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgaWYgKHRoaXMuaWRiZGIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZGJkYi5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgdGhpcy5fbm92aXAuaWRiZGIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmRiUmVhZHlQcm9taXNlID0gbmV3IERleGllUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmRiUmVhZHlSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRlLm9wZW5DYW5jZWxsZXIgPSBuZXcgRGV4aWVQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmNhbmNlbE9wZW4gPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5fY2xvc2UoKTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5hdXRvT3BlbiA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5kYk9wZW5FcnJvciA9IG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCk7XG4gICAgICAgIGlmIChzdGF0ZS5pc0JlaW5nT3BlbmVkKVxuICAgICAgICAgICAgc3RhdGUuY2FuY2VsT3BlbihzdGF0ZS5kYk9wZW5FcnJvcik7XG4gICAgfVxuICAgIGRlbGV0ZSgpIHtcbiAgICAgICAgY29uc3QgaGFzQXJndW1lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDA7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRvRGVsZXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVxID0gdGhpcy5fZGVwcy5pbmRleGVkREIuZGVsZXRlRGF0YWJhc2UodGhpcy5uYW1lKTtcbiAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIF9vbkRhdGFiYXNlRGVsZXRlZCh0aGlzLl9kZXBzLCB0aGlzLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICByZXEub25ibG9ja2VkID0gdGhpcy5fZmlyZU9uQmxvY2tlZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaGFzQXJndW1lbnRzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkFyZ3VtZW50cyBub3QgYWxsb3dlZCBpbiBkYi5kZWxldGUoKVwiKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbihkb0RlbGV0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb0RlbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYmFja2VuZERCKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZGJkYjtcbiAgICB9XG4gICAgaXNPcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZGJkYiAhPT0gbnVsbDtcbiAgICB9XG4gICAgaGFzQmVlbkNsb3NlZCgpIHtcbiAgICAgICAgY29uc3QgZGJPcGVuRXJyb3IgPSB0aGlzLl9zdGF0ZS5kYk9wZW5FcnJvcjtcbiAgICAgICAgcmV0dXJuIGRiT3BlbkVycm9yICYmIChkYk9wZW5FcnJvci5uYW1lID09PSAnRGF0YWJhc2VDbG9zZWQnKTtcbiAgICB9XG4gICAgaGFzRmFpbGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuZGJPcGVuRXJyb3IgIT09IG51bGw7XG4gICAgfVxuICAgIGR5bmFtaWNhbGx5T3BlbmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuYXV0b1NjaGVtYTtcbiAgICB9XG4gICAgZ2V0IHRhYmxlcygpIHtcbiAgICAgICAgcmV0dXJuIGtleXModGhpcy5fYWxsVGFibGVzKS5tYXAobmFtZSA9PiB0aGlzLl9hbGxUYWJsZXNbbmFtZV0pO1xuICAgIH1cbiAgICB0cmFuc2FjdGlvbigpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IGV4dHJhY3RUcmFuc2FjdGlvbkFyZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBfdHJhbnNhY3Rpb24obW9kZSwgdGFibGVzLCBzY29wZUZ1bmMpIHtcbiAgICAgICAgbGV0IHBhcmVudFRyYW5zYWN0aW9uID0gUFNELnRyYW5zO1xuICAgICAgICBpZiAoIXBhcmVudFRyYW5zYWN0aW9uIHx8IHBhcmVudFRyYW5zYWN0aW9uLmRiICE9PSB0aGlzIHx8IG1vZGUuaW5kZXhPZignIScpICE9PSAtMSlcbiAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgY29uc3Qgb25seUlmQ29tcGF0aWJsZSA9IG1vZGUuaW5kZXhPZignPycpICE9PSAtMTtcbiAgICAgICAgbW9kZSA9IG1vZGUucmVwbGFjZSgnIScsICcnKS5yZXBsYWNlKCc/JywgJycpO1xuICAgICAgICBsZXQgaWRiTW9kZSwgc3RvcmVOYW1lcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0b3JlTmFtZXMgPSB0YWJsZXMubWFwKHRhYmxlID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcmVOYW1lID0gdGFibGUgaW5zdGFuY2VvZiB0aGlzLlRhYmxlID8gdGFibGUubmFtZSA6IHRhYmxlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVOYW1lICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdGFibGUgYXJndW1lbnQgdG8gRGV4aWUudHJhbnNhY3Rpb24oKS4gT25seSBUYWJsZSBvciBTdHJpbmcgYXJlIGFsbG93ZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlTmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG1vZGUgPT0gXCJyXCIgfHwgbW9kZSA9PT0gUkVBRE9OTFkpXG4gICAgICAgICAgICAgICAgaWRiTW9kZSA9IFJFQURPTkxZO1xuICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PSBcInJ3XCIgfHwgbW9kZSA9PSBSRUFEV1JJVEUpXG4gICAgICAgICAgICAgICAgaWRiTW9kZSA9IFJFQURXUklURTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJJbnZhbGlkIHRyYW5zYWN0aW9uIG1vZGU6IFwiICsgbW9kZSk7XG4gICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24ubW9kZSA9PT0gUkVBRE9OTFkgJiYgaWRiTW9kZSA9PT0gUkVBRFdSSVRFKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbmx5SWZDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU3ViVHJhbnNhY3Rpb24oXCJDYW5ub3QgZW50ZXIgYSBzdWItdHJhbnNhY3Rpb24gd2l0aCBSRUFEV1JJVEUgbW9kZSB3aGVuIHBhcmVudCB0cmFuc2FjdGlvbiBpcyBSRUFET05MWVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlTmFtZXMuZm9yRWFjaChzdG9yZU5hbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uICYmIHBhcmVudFRyYW5zYWN0aW9uLnN0b3JlTmFtZXMuaW5kZXhPZihzdG9yZU5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmx5SWZDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TdWJUcmFuc2FjdGlvbihcIlRhYmxlIFwiICsgc3RvcmVOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIG5vdCBpbmNsdWRlZCBpbiBwYXJlbnQgdHJhbnNhY3Rpb24uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUgJiYgcGFyZW50VHJhbnNhY3Rpb24gJiYgIXBhcmVudFRyYW5zYWN0aW9uLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50VHJhbnNhY3Rpb24gP1xuICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uLl9wcm9taXNlKG51bGwsIChfLCByZWplY3QpID0+IHsgcmVqZWN0KGUpOyB9KSA6XG4gICAgICAgICAgICAgICAgcmVqZWN0aW9uKGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudGVyVHJhbnNhY3Rpb24gPSBlbnRlclRyYW5zYWN0aW9uU2NvcGUuYmluZChudWxsLCB0aGlzLCBpZGJNb2RlLCBzdG9yZU5hbWVzLCBwYXJlbnRUcmFuc2FjdGlvbiwgc2NvcGVGdW5jKTtcbiAgICAgICAgcmV0dXJuIChwYXJlbnRUcmFuc2FjdGlvbiA/XG4gICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbi5fcHJvbWlzZShpZGJNb2RlLCBlbnRlclRyYW5zYWN0aW9uLCBcImxvY2tcIikgOlxuICAgICAgICAgICAgUFNELnRyYW5zID9cbiAgICAgICAgICAgICAgICB1c2VQU0QoUFNELnRyYW5zbGVzcywgKCkgPT4gdGhpcy5fd2hlblJlYWR5KGVudGVyVHJhbnNhY3Rpb24pKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5fd2hlblJlYWR5KGVudGVyVHJhbnNhY3Rpb24pKTtcbiAgICB9XG4gICAgdGFibGUodGFibGVOYW1lKSB7XG4gICAgICAgIGlmICghaGFzT3duKHRoaXMuX2FsbFRhYmxlcywgdGFibGVOYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZFRhYmxlKGBUYWJsZSAke3RhYmxlTmFtZX0gZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWxsVGFibGVzW3RhYmxlTmFtZV07XG4gICAgfVxufVxuXG5jb25zdCBzeW1ib2xPYnNlcnZhYmxlID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIm9ic2VydmFibGVcIiBpbiBTeW1ib2xcbiAgICA/IFN5bWJvbC5vYnNlcnZhYmxlXG4gICAgOiBcIkBAb2JzZXJ2YWJsZVwiO1xuY2xhc3MgT2JzZXJ2YWJsZSB7XG4gICAgY29uc3RydWN0b3Ioc3Vic2NyaWJlKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKHgsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKCF4IHx8IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB7IG5leHQ6IHgsIGVycm9yLCBjb21wbGV0ZSB9IDogeCk7XG4gICAgfVxuICAgIFtzeW1ib2xPYnNlcnZhYmxlXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBleHRlbmRPYnNlcnZhYmlsaXR5U2V0KHRhcmdldCwgbmV3U2V0KSB7XG4gICAga2V5cyhuZXdTZXQpLmZvckVhY2gocGFydCA9PiB7XG4gICAgICAgIGNvbnN0IHJhbmdlU2V0ID0gdGFyZ2V0W3BhcnRdIHx8ICh0YXJnZXRbcGFydF0gPSBuZXcgUmFuZ2VTZXQoKSk7XG4gICAgICAgIG1lcmdlUmFuZ2VzKHJhbmdlU2V0LCBuZXdTZXRbcGFydF0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGxpdmVRdWVyeShxdWVyaWVyKSB7XG4gICAgbGV0IGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgbGV0IGN1cnJlbnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKG9ic2VydmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHNjb3BlRnVuY0lzQXN5bmMgPSBpc0FzeW5jRnVuY3Rpb24ocXVlcmllcik7XG4gICAgICAgIGZ1bmN0aW9uIGV4ZWN1dGUoc3Vic2NyKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuICAgICAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleGVjID0gKCkgPT4gbmV3U2NvcGUocXVlcmllciwgeyBzdWJzY3IsIHRyYW5zOiBudWxsIH0pO1xuICAgICAgICAgICAgY29uc3QgcnYgPSBQU0QudHJhbnNcbiAgICAgICAgICAgICAgICA/XG4gICAgICAgICAgICAgICAgICAgIHVzZVBTRChQU0QudHJhbnNsZXNzLCBleGVjKVxuICAgICAgICAgICAgICAgIDogZXhlYygpO1xuICAgICAgICAgICAgaWYgKHNjb3BlRnVuY0lzQXN5bmMpIHtcbiAgICAgICAgICAgICAgICBydi50aGVuKGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzLCBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNsb3NlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgYWNjdW1NdXRzID0ge307XG4gICAgICAgIGxldCBjdXJyZW50T2JzID0ge307XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb3NlZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRzLnN0b3JhZ2VtdXRhdGVkLnVuc3Vic2NyaWJlKG11dGF0aW9uTGlzdGVuZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgb2JzZXJ2ZXIuc3RhcnQgJiYgb2JzZXJ2ZXIuc3RhcnQoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgbGV0IHF1ZXJ5aW5nID0gZmFsc2UsIHN0YXJ0ZWRMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgZnVuY3Rpb24gc2hvdWxkTm90aWZ5KCkge1xuICAgICAgICAgICAgcmV0dXJuIGtleXMoY3VycmVudE9icykuc29tZSgoa2V5KSA9PiBhY2N1bU11dHNba2V5XSAmJiByYW5nZXNPdmVybGFwKGFjY3VtTXV0c1trZXldLCBjdXJyZW50T2JzW2tleV0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtdXRhdGlvbkxpc3RlbmVyID0gKHBhcnRzKSA9PiB7XG4gICAgICAgICAgICBleHRlbmRPYnNlcnZhYmlsaXR5U2V0KGFjY3VtTXV0cywgcGFydHMpO1xuICAgICAgICAgICAgaWYgKHNob3VsZE5vdGlmeSgpKSB7XG4gICAgICAgICAgICAgICAgZG9RdWVyeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkb1F1ZXJ5ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5aW5nIHx8IGNsb3NlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBhY2N1bU11dHMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gZXhlY3V0ZShzdWJzY3IpO1xuICAgICAgICAgICAgaWYgKCFzdGFydGVkTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCBtdXRhdGlvbkxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICBzdGFydGVkTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXJ5aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShyZXQpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcXVlcnlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZE5vdGlmeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvUXVlcnkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY3VtTXV0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50T2JzID0gc3Vic2NyO1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0ICYmIG9ic2VydmVyLm5leHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgcXVlcnlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yICYmIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgZG9RdWVyeSgpO1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH0pO1xuICAgIG9ic2VydmFibGUuaGFzVmFsdWUgPSAoKSA9PiBoYXNWYWx1ZTtcbiAgICBvYnNlcnZhYmxlLmdldFZhbHVlID0gKCkgPT4gY3VycmVudFZhbHVlO1xuICAgIHJldHVybiBvYnNlcnZhYmxlO1xufVxuXG5sZXQgZG9tRGVwcztcbnRyeSB7XG4gICAgZG9tRGVwcyA9IHtcbiAgICAgICAgaW5kZXhlZERCOiBfZ2xvYmFsLmluZGV4ZWREQiB8fCBfZ2xvYmFsLm1vekluZGV4ZWREQiB8fCBfZ2xvYmFsLndlYmtpdEluZGV4ZWREQiB8fCBfZ2xvYmFsLm1zSW5kZXhlZERCLFxuICAgICAgICBJREJLZXlSYW5nZTogX2dsb2JhbC5JREJLZXlSYW5nZSB8fCBfZ2xvYmFsLndlYmtpdElEQktleVJhbmdlXG4gICAgfTtcbn1cbmNhdGNoIChlKSB7XG4gICAgZG9tRGVwcyA9IHsgaW5kZXhlZERCOiBudWxsLCBJREJLZXlSYW5nZTogbnVsbCB9O1xufVxuXG5jb25zdCBEZXhpZSA9IERleGllJDE7XG5wcm9wcyhEZXhpZSwge1xuICAgIC4uLmZ1bGxOYW1lRXhjZXB0aW9ucyxcbiAgICBkZWxldGUoZGF0YWJhc2VOYW1lKSB7XG4gICAgICAgIGNvbnN0IGRiID0gbmV3IERleGllKGRhdGFiYXNlTmFtZSwgeyBhZGRvbnM6IFtdIH0pO1xuICAgICAgICByZXR1cm4gZGIuZGVsZXRlKCk7XG4gICAgfSxcbiAgICBleGlzdHMobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IERleGllKG5hbWUsIHsgYWRkb25zOiBbXSB9KS5vcGVuKCkudGhlbihkYiA9PiB7XG4gICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pLmNhdGNoKCdOb1N1Y2hEYXRhYmFzZUVycm9yJywgKCkgPT4gZmFsc2UpO1xuICAgIH0sXG4gICAgZ2V0RGF0YWJhc2VOYW1lcyhjYikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldERhdGFiYXNlTmFtZXMoRGV4aWUuZGVwZW5kZW5jaWVzKS50aGVuKGNiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGVmaW5lQ2xhc3MoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENsYXNzKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGV4dGVuZCh0aGlzLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2xhc3M7XG4gICAgfSxcbiAgICBpZ25vcmVUcmFuc2FjdGlvbihzY29wZUZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIFBTRC50cmFucyA/XG4gICAgICAgICAgICB1c2VQU0QoUFNELnRyYW5zbGVzcywgc2NvcGVGdW5jKSA6XG4gICAgICAgICAgICBzY29wZUZ1bmMoKTtcbiAgICB9LFxuICAgIHZpcCxcbiAgICBhc3luYzogZnVuY3Rpb24gKGdlbmVyYXRvckZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBydiA9IGF3YWl0SXRlcmF0b3IoZ2VuZXJhdG9yRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFydiB8fCB0eXBlb2YgcnYudGhlbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHJ2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBzcGF3bjogZnVuY3Rpb24gKGdlbmVyYXRvckZuLCBhcmdzLCB0aGl6KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcnYgPSBhd2FpdEl0ZXJhdG9yKGdlbmVyYXRvckZuLmFwcGx5KHRoaXosIGFyZ3MgfHwgW10pKTtcbiAgICAgICAgICAgIGlmICghcnYgfHwgdHlwZW9mIHJ2LnRoZW4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHJ2KTtcbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3VycmVudFRyYW5zYWN0aW9uOiB7XG4gICAgICAgIGdldDogKCkgPT4gUFNELnRyYW5zIHx8IG51bGxcbiAgICB9LFxuICAgIHdhaXRGb3I6IGZ1bmN0aW9uIChwcm9taXNlT3JGdW5jdGlvbiwgb3B0aW9uYWxUaW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBEZXhpZVByb21pc2UucmVzb2x2ZSh0eXBlb2YgcHJvbWlzZU9yRnVuY3Rpb24gPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgRGV4aWUuaWdub3JlVHJhbnNhY3Rpb24ocHJvbWlzZU9yRnVuY3Rpb24pIDpcbiAgICAgICAgICAgIHByb21pc2VPckZ1bmN0aW9uKVxuICAgICAgICAgICAgLnRpbWVvdXQob3B0aW9uYWxUaW1lb3V0IHx8IDYwMDAwKTtcbiAgICAgICAgcmV0dXJuIFBTRC50cmFucyA/XG4gICAgICAgICAgICBQU0QudHJhbnMud2FpdEZvcihwcm9taXNlKSA6XG4gICAgICAgICAgICBwcm9taXNlO1xuICAgIH0sXG4gICAgUHJvbWlzZTogRGV4aWVQcm9taXNlLFxuICAgIGRlYnVnOiB7XG4gICAgICAgIGdldDogKCkgPT4gZGVidWcsXG4gICAgICAgIHNldDogdmFsdWUgPT4ge1xuICAgICAgICAgICAgc2V0RGVidWcodmFsdWUsIHZhbHVlID09PSAnZGV4aWUnID8gKCkgPT4gdHJ1ZSA6IGRleGllU3RhY2tGcmFtZUZpbHRlcik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlcml2ZTogZGVyaXZlLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICBvdmVycmlkZTogb3ZlcnJpZGUsXG4gICAgRXZlbnRzOiBFdmVudHMsXG4gICAgb246IGdsb2JhbEV2ZW50cyxcbiAgICBsaXZlUXVlcnksXG4gICAgZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldCxcbiAgICBnZXRCeUtleVBhdGg6IGdldEJ5S2V5UGF0aCxcbiAgICBzZXRCeUtleVBhdGg6IHNldEJ5S2V5UGF0aCxcbiAgICBkZWxCeUtleVBhdGg6IGRlbEJ5S2V5UGF0aCxcbiAgICBzaGFsbG93Q2xvbmU6IHNoYWxsb3dDbG9uZSxcbiAgICBkZWVwQ2xvbmU6IGRlZXBDbG9uZSxcbiAgICBnZXRPYmplY3REaWZmOiBnZXRPYmplY3REaWZmLFxuICAgIGNtcCxcbiAgICBhc2FwOiBhc2FwJDEsXG4gICAgbWluS2V5OiBtaW5LZXksXG4gICAgYWRkb25zOiBbXSxcbiAgICBjb25uZWN0aW9uczogY29ubmVjdGlvbnMsXG4gICAgZXJybmFtZXM6IGVycm5hbWVzLFxuICAgIGRlcGVuZGVuY2llczogZG9tRGVwcyxcbiAgICBzZW1WZXI6IERFWElFX1ZFUlNJT04sXG4gICAgdmVyc2lvbjogREVYSUVfVkVSU0lPTi5zcGxpdCgnLicpXG4gICAgICAgIC5tYXAobiA9PiBwYXJzZUludChuKSlcbiAgICAgICAgLnJlZHVjZSgocCwgYywgaSkgPT4gcCArIChjIC8gTWF0aC5wb3coMTAsIGkgKiAyKSkpLFxufSk7XG5EZXhpZS5tYXhLZXkgPSBnZXRNYXhLZXkoRGV4aWUuZGVwZW5kZW5jaWVzLklEQktleVJhbmdlKTtcblxuaWYgKHR5cGVvZiBkaXNwYXRjaEV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIHVwZGF0ZWRQYXJ0cyA9PiB7XG4gICAgICAgIGlmICghcHJvcGFnYXRpbmdMb2NhbGx5KSB7XG4gICAgICAgICAgICBsZXQgZXZlbnQ7XG4gICAgICAgICAgICBpZiAoaXNJRU9yRWRnZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgICAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSwgdHJ1ZSwgdHJ1ZSwgdXBkYXRlZFBhcnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSwge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHVwZGF0ZWRQYXJ0c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBhZGRFdmVudExpc3RlbmVyKFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSwgKHsgZGV0YWlsIH0pID0+IHtcbiAgICAgICAgaWYgKCFwcm9wYWdhdGluZ0xvY2FsbHkpIHtcbiAgICAgICAgICAgIHByb3BhZ2F0ZUxvY2FsbHkoZGV0YWlsKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcHJvcGFnYXRlTG9jYWxseSh1cGRhdGVQYXJ0cykge1xuICAgIGxldCB3YXNNZSA9IHByb3BhZ2F0aW5nTG9jYWxseTtcbiAgICB0cnkge1xuICAgICAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSB0cnVlO1xuICAgICAgICBnbG9iYWxFdmVudHMuc3RvcmFnZW11dGF0ZWQuZmlyZSh1cGRhdGVQYXJ0cyk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSB3YXNNZTtcbiAgICB9XG59XG5sZXQgcHJvcGFnYXRpbmdMb2NhbGx5ID0gZmFsc2U7XG5cbmlmICh0eXBlb2YgQnJvYWRjYXN0Q2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zdCBiYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSk7XG4gICAgaWYgKHR5cGVvZiBiYy51bnJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBiYy51bnJlZigpO1xuICAgIH1cbiAgICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIChjaGFuZ2VkUGFydHMpID0+IHtcbiAgICAgICAgaWYgKCFwcm9wYWdhdGluZ0xvY2FsbHkpIHtcbiAgICAgICAgICAgIGJjLnBvc3RNZXNzYWdlKGNoYW5nZWRQYXJ0cyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBiYy5vbm1lc3NhZ2UgPSAoZXYpID0+IHtcbiAgICAgICAgaWYgKGV2LmRhdGEpXG4gICAgICAgICAgICBwcm9wYWdhdGVMb2NhbGx5KGV2LmRhdGEpO1xuICAgIH07XG59XG5lbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIChjaGFuZ2VkUGFydHMpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghcHJvcGFnYXRpbmdMb2NhbGx5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZzogTWF0aC5yYW5kb20oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWRQYXJ0cyxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlbGZbJ2NsaWVudHMnXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgWy4uLnNlbGZbJ2NsaWVudHMnXS5tYXRjaEFsbCh7IGluY2x1ZGVVbmNvbnRyb2xsZWQ6IHRydWUgfSldLmZvckVhY2goKGNsaWVudCkgPT4gY2xpZW50LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWRQYXJ0cyxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIChldikgPT4ge1xuICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXYubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhKVxuICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGVMb2NhbGx5KGRhdGEuY2hhbmdlZFBhcnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHN3Q29udGFpbmVyID0gc2VsZi5kb2N1bWVudCAmJiBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlcjtcbiAgICBpZiAoc3dDb250YWluZXIpIHtcbiAgICAgICAgc3dDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHByb3BhZ2F0ZU1lc3NhZ2VMb2NhbGx5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcm9wYWdhdGVNZXNzYWdlTG9jYWxseSh7IGRhdGEgfSkge1xuICAgIGlmIChkYXRhICYmIGRhdGEudHlwZSA9PT0gU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FKSB7XG4gICAgICAgIHByb3BhZ2F0ZUxvY2FsbHkoZGF0YS5jaGFuZ2VkUGFydHMpO1xuICAgIH1cbn1cblxuRGV4aWVQcm9taXNlLnJlamVjdGlvbk1hcHBlciA9IG1hcEVycm9yO1xuc2V0RGVidWcoZGVidWcsIGRleGllU3RhY2tGcmFtZUZpbHRlcik7XG5cbmV4cG9ydCB7IERleGllJDEgYXMgRGV4aWUsIFJhbmdlU2V0LCBEZXhpZSQxIGFzIGRlZmF1bHQsIGxpdmVRdWVyeSwgbWVyZ2VSYW5nZXMsIHJhbmdlc092ZXJsYXAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRleGllLm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZ2xvYmFsIiwiZ2xvYmFsVGhpcyIsInNlbGYiLCJ3aW5kb3ciLCJnbG9iYWwiLCJrZXlzIiwiT2JqZWN0IiwiaXNBcnJheSIsIkFycmF5IiwiUHJvbWlzZSIsImV4dGVuZCIsIm9iaiIsImV4dGVuc2lvbiIsImZvckVhY2giLCJrZXkiLCJnZXRQcm90byIsImdldFByb3RvdHlwZU9mIiwiX2hhc093biIsImhhc093blByb3BlcnR5IiwiaGFzT3duIiwicHJvcCIsImNhbGwiLCJwcm9wcyIsInByb3RvIiwiUmVmbGVjdCIsIm93bktleXMiLCJzZXRQcm9wIiwiZGVmaW5lUHJvcGVydHkiLCJmdW5jdGlvbk9yR2V0U2V0Iiwib3B0aW9ucyIsImdldCIsInNldCIsImNvbmZpZ3VyYWJsZSIsInZhbHVlIiwid3JpdGFibGUiLCJkZXJpdmUiLCJDaGlsZCIsImZyb20iLCJQYXJlbnQiLCJwcm90b3R5cGUiLCJjcmVhdGUiLCJiaW5kIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0UHJvcGVydHlEZXNjcmlwdG9yIiwicGQiLCJfc2xpY2UiLCJzbGljZSIsImFyZ3MiLCJzdGFydCIsImVuZCIsIm92ZXJyaWRlIiwib3JpZ0Z1bmMiLCJvdmVycmlkZWRGYWN0b3J5IiwiYXNzZXJ0IiwiYiIsIkVycm9yIiwiYXNhcCQxIiwiZm4iLCJzZXRJbW1lZGlhdGUiLCJzZXRUaW1lb3V0IiwiYXJyYXlUb09iamVjdCIsImFycmF5IiwiZXh0cmFjdG9yIiwicmVkdWNlIiwicmVzdWx0IiwiaXRlbSIsImkiLCJuYW1lQW5kVmFsdWUiLCJ0cnlDYXRjaCIsIm9uZXJyb3IiLCJhcHBseSIsImV4IiwiZ2V0QnlLZXlQYXRoIiwia2V5UGF0aCIsInJ2IiwibCIsImxlbmd0aCIsInZhbCIsInB1c2giLCJwZXJpb2QiLCJpbmRleE9mIiwiaW5uZXJPYmoiLCJzdWJzdHIiLCJ1bmRlZmluZWQiLCJzZXRCeUtleVBhdGgiLCJpc0Zyb3plbiIsImN1cnJlbnRLZXlQYXRoIiwicmVtYWluaW5nS2V5UGF0aCIsImlzTmFOIiwicGFyc2VJbnQiLCJzcGxpY2UiLCJkZWxCeUtleVBhdGgiLCJtYXAiLCJrcCIsInNoYWxsb3dDbG9uZSIsIm0iLCJjb25jYXQiLCJmbGF0dGVuIiwiYSIsImludHJpbnNpY1R5cGVOYW1lcyIsInNwbGl0IiwibnVtIiwidCIsImZpbHRlciIsImludHJpbnNpY1R5cGVzIiwieCIsImNpcmN1bGFyUmVmcyIsImRlZXBDbG9uZSIsImFueSIsIldlYWtNYXAiLCJpbm5lckRlZXBDbG9uZSIsImNvbnN0cnVjdG9yIiwidG9TdHJpbmciLCJ0b1N0cmluZ1RhZyIsIm8iLCJpdGVyYXRvclN5bWJvbCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiZ2V0SXRlcmF0b3JPZiIsIk5PX0NIQVJfQVJSQVkiLCJnZXRBcnJheU9mIiwiYXJyYXlMaWtlIiwiaXQiLCJhcmd1bWVudHMiLCJuZXh0IiwiZG9uZSIsImlzQXN5bmNGdW5jdGlvbiIsImRlYnVnIiwibG9jYXRpb24iLCJ0ZXN0IiwiaHJlZiIsInNldERlYnVnIiwibGlicmFyeUZpbHRlciIsIk5FRURTX1RIUk9XX0ZPUl9TVEFDSyIsInN0YWNrIiwiZ2V0RXJyb3JXaXRoU3RhY2siLCJlIiwicHJldHR5U3RhY2siLCJleGNlcHRpb24iLCJudW1JZ25vcmVkRnJhbWVzIiwibmFtZSIsIm1lc3NhZ2UiLCJmcmFtZSIsImpvaW4iLCJkZXhpZUVycm9yTmFtZXMiLCJpZGJEb21FcnJvck5hbWVzIiwiZXJyb3JMaXN0IiwiZGVmYXVsdFRleHRzIiwiVmVyc2lvbkNoYW5nZWQiLCJEYXRhYmFzZUNsb3NlZCIsIkFib3J0IiwiVHJhbnNhY3Rpb25JbmFjdGl2ZSIsIk1pc3NpbmdBUEkiLCJEZXhpZUVycm9yIiwibXNnIiwiX2UiLCJfc3RhY2siLCJnZXRNdWx0aUVycm9yTWVzc2FnZSIsImZhaWx1cmVzIiwidiIsInMiLCJNb2RpZnlFcnJvciIsInN1Y2Nlc3NDb3VudCIsImZhaWxlZEtleXMiLCJCdWxrRXJyb3IiLCJwb3MiLCJmYWlsdXJlc0J5UG9zIiwiZXJybmFtZXMiLCJCYXNlRXhjZXB0aW9uIiwiZXhjZXB0aW9ucyIsImZ1bGxOYW1lIiwibXNnT3JJbm5lciIsImlubmVyIiwiU3ludGF4IiwiU3ludGF4RXJyb3IiLCJUeXBlIiwiVHlwZUVycm9yIiwiUmFuZ2UiLCJSYW5nZUVycm9yIiwiZXhjZXB0aW9uTWFwIiwibWFwRXJyb3IiLCJkb21FcnJvciIsImZ1bGxOYW1lRXhjZXB0aW9ucyIsIm5vcCIsIm1pcnJvciIsInB1cmVGdW5jdGlvbkNoYWluIiwiZjEiLCJmMiIsImNhbGxCb3RoIiwib24xIiwib24yIiwiaG9va0NyZWF0aW5nQ2hhaW4iLCJyZXMiLCJvbnN1Y2Nlc3MiLCJyZXMyIiwiaG9va0RlbGV0aW5nQ2hhaW4iLCJob29rVXBkYXRpbmdDaGFpbiIsIm1vZGlmaWNhdGlvbnMiLCJyZXZlcnNlU3RvcHBhYmxlRXZlbnRDaGFpbiIsInByb21pc2FibGVDaGFpbiIsInRoZW4iLCJ0aGl6IiwiSU5URVJOQUwiLCJMT05HX1NUQUNLU19DTElQX0xJTUlUIiwiTUFYX0xPTkdfU1RBQ0tTIiwiWk9ORV9FQ0hPX0xJTUlUIiwicmVzb2x2ZWROYXRpdmVQcm9taXNlIiwibmF0aXZlUHJvbWlzZVByb3RvIiwicmVzb2x2ZWRHbG9iYWxQcm9taXNlIiwiZ2xvYmFsUCIsInJlc29sdmUiLCJjcnlwdG8iLCJzdWJ0bGUiLCJuYXRpdmVQIiwiZGlnZXN0IiwiVWludDhBcnJheSIsIm5hdGl2ZVByb21pc2VUaGVuIiwiTmF0aXZlUHJvbWlzZSIsInBhdGNoR2xvYmFsUHJvbWlzZSIsInN0YWNrX2JlaW5nX2dlbmVyYXRlZCIsInNjaGVkdWxlUGh5c2ljYWxUaWNrIiwicGh5c2ljYWxUaWNrIiwiTXV0YXRpb25PYnNlcnZlciIsImhpZGRlbkRpdiIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm9ic2VydmUiLCJhdHRyaWJ1dGVzIiwic2V0QXR0cmlidXRlIiwiYXNhcCIsImNhbGxiYWNrIiwibWljcm90aWNrUXVldWUiLCJuZWVkc05ld1BoeXNpY2FsVGljayIsImlzT3V0c2lkZU1pY3JvVGljayIsInVuaGFuZGxlZEVycm9ycyIsInJlamVjdGluZ0Vycm9ycyIsImN1cnJlbnRGdWxmaWxsZXIiLCJyZWplY3Rpb25NYXBwZXIiLCJnbG9iYWxQU0QiLCJpZCIsInJlZiIsInVuaGFuZGxlZHMiLCJvbnVuaGFuZGxlZCIsImdsb2JhbEVycm9yIiwicGdwIiwiZW52IiwiZmluYWxpemUiLCJ1aCIsIlBTRCIsIm51bVNjaGVkdWxlZENhbGxzIiwidGlja0ZpbmFsaXplcnMiLCJEZXhpZVByb21pc2UiLCJfbGlzdGVuZXJzIiwib251bmNhdGNoZWQiLCJfbGliIiwicHNkIiwiX1BTRCIsIl9zdGFja0hvbGRlciIsIl9wcmV2IiwiX251bVByZXYiLCJfc3RhdGUiLCJfdmFsdWUiLCJoYW5kbGVSZWplY3Rpb24iLCJleGVjdXRlUHJvbWlzZVRhc2siLCJ0aGVuUHJvcCIsIm1pY3JvVGFza0lkIiwidG90YWxFY2hvZXMiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJwb3NzaWJsZUF3YWl0IiwiY2xlYW51cCIsImRlY3JlbWVudEV4cGVjdGVkQXdhaXRzIiwicmVqZWN0IiwicHJvcGFnYXRlVG9MaXN0ZW5lciIsIkxpc3RlbmVyIiwibmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcCIsImxpbmtUb1ByZXZpb3VzUHJvbWlzZSIsIl90aGVuIiwiY2F0Y2giLCJ0eXBlIiwiaGFuZGxlciIsImVyciIsIlByb21pc2VSZWplY3QiLCJmaW5hbGx5Iiwib25GaW5hbGx5Iiwic3RhY2tzIiwiZ2V0U3RhY2siLCJ0aW1lb3V0IiwibXMiLCJJbmZpbml0eSIsImhhbmRsZSIsIlRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJzbmFwU2hvdCIsInpvbmUiLCJhbGwiLCJ2YWx1ZXMiLCJvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMiLCJyZW1haW5pbmciLCJyYWNlIiwibmV3UFNEIiwibmV3U2NvcGUiLCJ1c2VQU0QiLCJzY2hlZHVsZXIiLCJmb2xsb3ciLCJ6b25lUHJvcHMiLCJydW5fYXRfZW5kX29mX3RoaXNfb3JfbmV4dF9waHlzaWNhbF90aWNrIiwiYWxsU2V0dGxlZCIsInBvc3NpYmxlUHJvbWlzZXMiLCJyZXN1bHRzIiwicCIsInN0YXR1cyIsInJlYXNvbiIsIkFnZ3JlZ2F0ZUVycm9yIiwiZmFpbHVyZSIsInByb21pc2UiLCJzaG91bGRFeGVjdXRlVGljayIsImJlZ2luTWljcm9UaWNrU2NvcGUiLCJwcm9wYWdhdGVBbGxMaXN0ZW5lcnMiLCJlbmRNaWNyb1RpY2tTY29wZSIsIl9wcm9taXNlIiwib3JpZ1Byb3AiLCJhZGRQb3NzaWJseVVuaGFuZGxlZEVycm9yIiwibGlzdGVuZXJzIiwibGVuIiwiZmluYWxpemVQaHlzaWNhbFRpY2siLCJsaXN0ZW5lciIsImNiIiwiY2FsbExpc3RlbmVyIiwicmV0IiwibWFya0Vycm9yQXNIYW5kbGVkIiwibGltaXQiLCJlcnJvck5hbWUiLCJwcmV2IiwibnVtUHJldiIsIndhc1Jvb3RFeGVjIiwiY2FsbGJhY2tzIiwidW5oYW5kbGVkRXJycyIsImZpbmFsaXplcnMiLCJmaW5hbGl6ZXIiLCJzb21lIiwid3JhcCIsImVycm9yQ2F0Y2hlciIsIm91dGVyU2NvcGUiLCJzd2l0Y2hUb1pvbmUiLCJ0YXNrIiwiYXdhaXRzIiwiZWNob2VzIiwidGFza0NvdW50ZXIiLCJ6b25lU3RhY2siLCJ6b25lRWNob2VzIiwiem9uZV9pZF9jb3VudGVyIiwiYTEiLCJhMiIsInBhcmVudCIsImdsb2JhbEVudiIsIlByb21pc2VQcm9wIiwibnRoZW4iLCJnZXRQYXRjaGVkUHJvbWlzZVRoZW4iLCJndGhlbiIsImluY3JlbWVudEV4cGVjdGVkQXdhaXRzIiwicG9zc2libGVQcm9taXNlIiwicmVqZWN0aW9uIiwiem9uZUVudGVyRWNobyIsInRhcmdldFpvbmUiLCJ6b25lTGVhdmVFY2hvIiwicG9wIiwiYkVudGVyaW5nWm9uZSIsImN1cnJlbnRab25lIiwiZW5xdWV1ZU5hdGl2ZU1pY3JvVGFzayIsIkdsb2JhbFByb21pc2UiLCJ0YXJnZXRFbnYiLCJhMyIsImpvYiIsIm91dGVyWm9uZSIsIm9yaWdUaGVuIiwib25SZXNvbHZlZCIsIlVOSEFORExFRFJFSkVDVElPTiIsImV2ZW50IiwiZXZlbnREYXRhIiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJDdXN0b21FdmVudCIsImRldGFpbCIsImRpc3BhdGNoRXZlbnQiLCJQcm9taXNlUmVqZWN0aW9uRXZlbnQiLCJvbnVuaGFuZGxlZHJlamVjdGlvbiIsIl8iLCJkZWZhdWx0UHJldmVudGVkIiwiY29uc29sZSIsIndhcm4iLCJ0ZW1wVHJhbnNhY3Rpb24iLCJkYiIsIm1vZGUiLCJzdG9yZU5hbWVzIiwiaWRiZGIiLCJvcGVuQ29tcGxldGUiLCJsZXRUaHJvdWdoIiwiX3ZpcCIsImRiT3BlbkVycm9yIiwiaXNCZWluZ09wZW5lZCIsIl9vcHRpb25zIiwiYXV0b09wZW4iLCJvcGVuIiwiZGJSZWFkeVByb21pc2UiLCJ0cmFucyIsIl9jcmVhdGVUcmFuc2FjdGlvbiIsIl9kYlNjaGVtYSIsIlBSMTM5OF9tYXhMb29wIiwiSW52YWxpZFN0YXRlIiwiaXNPcGVuIiwiX2Nsb3NlIiwiX2NvbXBsZXRpb24iLCJERVhJRV9WRVJTSU9OIiwibWF4U3RyaW5nIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwibWluS2V5IiwiSU5WQUxJRF9LRVlfQVJHVU1FTlQiLCJTVFJJTkdfRVhQRUNURUQiLCJjb25uZWN0aW9ucyIsImlzSUVPckVkZ2UiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJoYXNJRURlbGV0ZU9iamVjdFN0b3JlQnVnIiwiaGFuZ3NPbkRlbGV0ZUxhcmdlS2V5UmFuZ2UiLCJkZXhpZVN0YWNrRnJhbWVGaWx0ZXIiLCJEQk5BTUVTX0RCIiwiUkVBRE9OTFkiLCJSRUFEV1JJVEUiLCJjb21iaW5lIiwiZmlsdGVyMSIsImZpbHRlcjIiLCJBbnlSYW5nZSIsImxvd2VyIiwibG93ZXJPcGVuIiwidXBwZXIiLCJ1cHBlck9wZW4iLCJ3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleSIsIlRhYmxlIiwiX3RyYW5zIiwid3JpdGVMb2NrZWQiLCJfdHgiLCJ0YWJsZU5hbWUiLCJjaGVja1RhYmxlSW5UcmFuc2FjdGlvbiIsInNjaGVtYSIsIk5vdEZvdW5kIiwiaWRidHJhbnMiLCJ0cmFuc2xlc3MiLCJrZXlPckNyaXQiLCJ3aGVyZSIsImZpcnN0IiwiY29yZSIsImhvb2siLCJyZWFkaW5nIiwiZmlyZSIsImluZGV4T3JDcml0IiwiV2hlcmVDbGF1c2UiLCJrZXlQYXRocyIsImVxdWFscyIsImNvbXBvdW5kSW5kZXgiLCJpbmRleGVzIiwicHJpbUtleSIsIml4IiwiY29tcG91bmQiLCJldmVyeSIsInNvcnQiLCJfbWF4S2V5Iiwia2V5UGF0aHNJblZhbGlkT3JkZXIiLCJKU09OIiwic3RyaW5naWZ5IiwiaWR4QnlOYW1lIiwiaWRiIiwiX2RlcHMiLCJpbmRleGVkREIiLCJjbXAiLCJpZHgiLCJmaWx0ZXJGdW5jdGlvbiIsInByZXZJbmRleCIsInByZXZGaWx0ZXJGbiIsImluZGV4IiwibXVsdGkiLCJ0b0NvbGxlY3Rpb24iLCJhbmQiLCJjb3VudCIsInRoZW5TaG9ydGN1dCIsIm9mZnNldCIsIm51bVJvd3MiLCJlYWNoIiwidG9BcnJheSIsIkNvbGxlY3Rpb24iLCJvcmRlckJ5IiwicmV2ZXJzZSIsIm1hcFRvQ2xhc3MiLCJtYXBwZWRDbGFzcyIsInJlYWRIb29rIiwidW5zdWJzY3JpYmUiLCJkZWZpbmVDbGFzcyIsIkNsYXNzIiwiY29udGVudCIsImFkZCIsImF1dG8iLCJvYmpUb0FkZCIsIm11dGF0ZSIsIm51bUZhaWx1cmVzIiwibGFzdFJlc3VsdCIsInVwZGF0ZSIsImtleU9yT2JqZWN0IiwiSW52YWxpZEFyZ3VtZW50IiwiX2EiLCJtb2RpZnkiLCJwdXQiLCJkZWxldGUiLCJjbGVhciIsInJhbmdlIiwiYnVsa0dldCIsImdldE1hbnkiLCJidWxrQWRkIiwib2JqZWN0cyIsImtleXNPck9wdGlvbnMiLCJ3YW50UmVzdWx0cyIsImFsbEtleXMiLCJudW1PYmplY3RzIiwib2JqZWN0c1RvQWRkIiwiYnVsa1B1dCIsIm9iamVjdHNUb1B1dCIsImJ1bGtEZWxldGUiLCJudW1LZXlzIiwiRXZlbnRzIiwiY3R4IiwiZXZzIiwiZXZlbnROYW1lIiwic3Vic2NyaWJlciIsInN1YnNjcmliZSIsImFkZEV2ZW50VHlwZSIsImNoYWluRnVuY3Rpb24iLCJkZWZhdWx0RnVuY3Rpb24iLCJhZGRDb25maWd1cmVkRXZlbnRzIiwiY29udGV4dCIsInN1YnNjcmliZXJzIiwiY2ZnIiwiZmlyZUV2ZW50IiwibWFrZUNsYXNzQ29uc3RydWN0b3IiLCJjcmVhdGVUYWJsZUNvbnN0cnVjdG9yIiwidGFibGVTY2hlbWEiLCJfYWxsVGFibGVzIiwiaXNQbGFpbktleVJhbmdlIiwiaWdub3JlTGltaXRGaWx0ZXIiLCJhbGdvcml0aG0iLCJvciIsImp1c3RMaW1pdCIsInJlcGxheUZpbHRlciIsImFkZEZpbHRlciIsImFkZFJlcGxheUZpbHRlciIsImZhY3RvcnkiLCJpc0xpbWl0RmlsdGVyIiwiY3VyciIsImFkZE1hdGNoRmlsdGVyIiwiaXNNYXRjaCIsImdldEluZGV4T3JTdG9yZSIsImNvcmVTY2hlbWEiLCJpc1ByaW1LZXkiLCJwcmltYXJ5S2V5IiwiZ2V0SW5kZXhCeUtleVBhdGgiLCJTY2hlbWEiLCJvcGVuQ3Vyc29yIiwiY29yZVRhYmxlIiwia2V5c09ubHkiLCJkaXIiLCJ1bmlxdWUiLCJxdWVyeSIsIml0ZXIiLCJjb3JlVHJhbnMiLCJpdGVyYXRlIiwidmFsdWVNYXBwZXIiLCJ1bmlvbiIsImN1cnNvciIsImFkdmFuY2UiLCJzdG9wIiwiZmFpbCIsIl9pdGVyYXRlIiwiY3Vyc29yUHJvbWlzZSIsIm1hcHBlZEZuIiwiYyIsIndyYXBwZWRGbiIsImNvbnRpbnVlIiwiYWR2YW5jZXIiLCJ0YSIsInRiIiwiTmFOIiwiY29tcGFyZVVpbnQ4QXJyYXlzIiwiZ2V0VWludDhBcnJheSIsImNvbXBhcmVBcnJheXMiLCJhbCIsImJsIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJ0c1RhZyIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiX3JlYWQiLCJfY3R4IiwiZXJyb3IiLCJ0YWJsZSIsIl93cml0ZSIsIl9hZGRBbGdvcml0aG0iLCJjbG9uZSIsInJhdyIsIk1hdGgiLCJtaW4iLCJzb3J0QnkiLCJwYXJ0cyIsImxhc3RQYXJ0IiwibGFzdEluZGV4IiwiZ2V0dmFsIiwib3JkZXIiLCJzb3J0ZXIiLCJhVmFsIiwiYlZhbCIsIm9mZnNldExlZnQiLCJyb3dzTGVmdCIsInVudGlsIiwiYkluY2x1ZGVTdG9wRW50cnkiLCJsYXN0IiwiaW5kZXhOYW1lIiwiX29uZGlyZWN0aW9uY2hhbmdlIiwiZGVzYyIsImVhY2hLZXkiLCJlYWNoVW5pcXVlS2V5IiwiZWFjaFByaW1hcnlLZXkiLCJwcmltYXJ5S2V5cyIsInVuaXF1ZUtleXMiLCJmaXJzdEtleSIsImxhc3RLZXkiLCJkaXN0aW5jdCIsInN0cktleSIsImZvdW5kIiwiY2hhbmdlcyIsIm1vZGlmeWVyIiwiYW55dGhpbmdNb2RpZmllZCIsIm91dGJvdW5kIiwiZXh0cmFjdEtleSIsIm1vZGlmeUNodW5rU2l6ZSIsInRvdGFsRmFpbHVyZXMiLCJhcHBseU11dGF0ZVJlc3VsdCIsImV4cGVjdGVkQ291bnQiLCJuZXh0Q2h1bmsiLCJjYWNoZSIsImFkZFZhbHVlcyIsInB1dFZhbHVlcyIsInB1dEtleXMiLCJkZWxldGVLZXlzIiwib3JpZ1ZhbHVlIiwiY3JpdGVyaWEiLCJkZWxldGVDYWxsYmFjayIsImNoYW5nZVNwZWMiLCJjb3JlUmFuZ2UiLCJjcmVhdGVDb2xsZWN0aW9uQ29uc3RydWN0b3IiLCJ3aGVyZUNsYXVzZSIsImtleVJhbmdlR2VuZXJhdG9yIiwia2V5UmFuZ2UiLCJ3aGVyZUN0eCIsInJlYWRpbmdIb29rIiwic2ltcGxlQ29tcGFyZSIsInNpbXBsZUNvbXBhcmVSZXZlcnNlIiwiY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UiLCJUIiwiY29sbGVjdGlvbiIsImVtcHR5Q29sbGVjdGlvbiIsInJhbmdlRXF1YWwiLCJ1cHBlckZhY3RvcnkiLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIiwibG93ZXJGYWN0b3J5IiwibmV4dENhc2luZyIsImxvd2VyS2V5IiwidXBwZXJOZWVkbGUiLCJsb3dlck5lZWRsZSIsImxscCIsImx3cktleUNoYXIiLCJhZGRJZ25vcmVDYXNlQWxnb3JpdGhtIiwibWF0Y2giLCJuZWVkbGVzIiwic3VmZml4IiwiY29tcGFyZSIsInVwcGVyTmVlZGxlcyIsImxvd2VyTmVlZGxlcyIsImRpcmVjdGlvbiIsIm5leHRLZXlTdWZmaXgiLCJuZWVkbGVzTGVuIiwiaW5pdERpcmVjdGlvbiIsIm5lZWRsZUJvdW5kcyIsIm5lZWRsZSIsIm5iIiwiY3JlYXRlUmFuZ2UiLCJmaXJzdFBvc3NpYmxlTmVlZGxlIiwibG93ZXN0UG9zc2libGVDYXNpbmciLCJjYXNpbmciLCJiZXR3ZWVuIiwiaW5jbHVkZUxvd2VyIiwiaW5jbHVkZVVwcGVyIiwiX2NtcCIsImFib3ZlIiwiYWJvdmVPckVxdWFsIiwiYmVsb3ciLCJiZWxvd09yRXF1YWwiLCJzdGFydHNXaXRoIiwic3RyIiwic3RhcnRzV2l0aElnbm9yZUNhc2UiLCJlcXVhbHNJZ25vcmVDYXNlIiwiYW55T2ZJZ25vcmVDYXNlIiwic3RhcnRzV2l0aEFueU9mSWdub3JlQ2FzZSIsIm4iLCJhbnlPZiIsIl9hc2NlbmRpbmciLCJfZGVzY2VuZGluZyIsIm5vdEVxdWFsIiwiaW5BbnlSYW5nZSIsImluY2x1ZGVMb3dlcnMiLCJpbmNsdWRlVXBwZXJzIiwibm9uZU9mIiwicmFuZ2VzIiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsIl9taW4iLCJtYXgiLCJfbWF4IiwiYWRkUmFuZ2UiLCJuZXdSYW5nZSIsInNvcnREaXJlY3Rpb24iLCJyYW5nZVNvcnRlciIsInJhbmdlUG9zIiwia2V5SXNCZXlvbmRDdXJyZW50RW50cnkiLCJrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeSIsImtleVdpdGhpbkN1cnJlbnRSYW5nZSIsImNoZWNrS2V5Iiwic3RhcnRzV2l0aEFueU9mIiwiY3JlYXRlV2hlcmVDbGF1c2VDb25zdHJ1Y3RvciIsIm9yQ29sbGVjdGlvbiIsIl9JREJLZXlSYW5nZSIsIklEQktleVJhbmdlIiwiZXZlbnRSZWplY3RIYW5kbGVyIiwicHJldmVudERlZmF1bHQiLCJ0YXJnZXQiLCJzdG9wUHJvcGFnYXRpb24iLCJERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSIsIlNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSIsImdsb2JhbEV2ZW50cyIsIlRyYW5zYWN0aW9uIiwiX2xvY2siLCJfcmVjdWxvY2siLCJsb2NrT3duZXJGb3IiLCJfdW5sb2NrIiwiX2Jsb2NrZWRGdW5jcyIsIl9sb2NrZWQiLCJmbkFuZFBTRCIsInNoaWZ0IiwiT3BlbkZhaWxlZCIsImFjdGl2ZSIsInRyYW5zYWN0aW9uIiwiZHVyYWJpbGl0eSIsImNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSIsImV2IiwiX3JlamVjdCIsIm9uYWJvcnQiLCJvbiIsIm9uY29tcGxldGUiLCJfcmVzb2x2ZSIsInN0b3JhZ2VtdXRhdGVkIiwiYldyaXRlTG9jayIsIlJlYWRPbmx5IiwiX3Jvb3QiLCJ3YWl0Rm9yIiwicHJvbWlzZUxpa2UiLCJyb290IiwiX3dhaXRpbmdGb3IiLCJfd2FpdGluZ1F1ZXVlIiwic3RvcmUiLCJvYmplY3RTdG9yZSIsInNwaW4iLCJfc3BpbkNvdW50IiwiY3VycmVudFdhaXRQcm9taXNlIiwiYWJvcnQiLCJtZW1vaXplZFRhYmxlcyIsIl9tZW1vaXplZFRhYmxlcyIsInRyYW5zYWN0aW9uQm91bmRUYWJsZSIsImNyZWF0ZVRyYW5zYWN0aW9uQ29uc3RydWN0b3IiLCJkYnNjaGVtYSIsImNvbXBsZXRlIiwid2FzQWN0aXZlIiwiY3JlYXRlSW5kZXhTcGVjIiwic3JjIiwibmFtZUZyb21LZXlQYXRoIiwiY3JlYXRlVGFibGVTY2hlbWEiLCJzYWZhcmlNdWx0aVN0b3JlRml4IiwiZ2V0TWF4S2V5IiwiSWRiS2V5UmFuZ2UiLCJvbmx5IiwiZ2V0S2V5RXh0cmFjdG9yIiwiZ2V0U2luZ2xlUGF0aEtleUV4dHJhY3RvciIsImFycmF5aWZ5IiwiX2lkX2NvdW50ZXIiLCJnZXRLZXlQYXRoQWxpYXMiLCJjcmVhdGVEQkNvcmUiLCJ0bXBUcmFucyIsImV4dHJhY3RTY2hlbWEiLCJ0YWJsZXMiLCJvYmplY3RTdG9yZU5hbWVzIiwiYXV0b0luY3JlbWVudCIsImluZGV4QnlLZXlQYXRoIiwiaXNQcmltYXJ5S2V5IiwiaW5kZXhOYW1lcyIsIm11bHRpRW50cnkiLCJoYXNHZXRBbGwiLCJtYWtlSURCS2V5UmFuZ2UiLCJpZGJSYW5nZSIsInVwcGVyQm91bmQiLCJsb3dlckJvdW5kIiwiYm91bmQiLCJjcmVhdGVEYkNvcmVUYWJsZSIsImlzQWRkT3JQdXQiLCJyZXEiLCJyZXFzIiwiZXJyb3JIYW5kbGVyIiwiYXJnczEiLCJhcmdzMiIsInNvdXJjZSIsIm9wZW5LZXlDdXJzb3IiLCJfX19pZCIsIl9jdXJzb3JDb250aW51ZSIsIl9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkiLCJjb250aW51ZVByaW1hcnlLZXkiLCJfY3Vyc29yQWR2YW5jZSIsImRvVGhyb3dDdXJzb3JJc05vdFN0YXJ0ZWQiLCJkb1Rocm93Q3Vyc29ySXNTdG9wcGVkIiwiZ290T25lIiwiaXRlcmF0aW9uUHJvbWlzZSIsInJlc29sdmVJdGVyYXRpb24iLCJyZWplY3RJdGVyYXRpb24iLCJndWFyZGVkQ2FsbGJhY2siLCJyZXF1ZXN0Iiwibm9uSW5maW5pdExpbWl0IiwiaWRiS2V5UmFuZ2UiLCJnZXRBbGwiLCJnZXRBbGxLZXlzIiwia2V5Q291bnQiLCJjYWxsYmFja0NvdW50Iiwic3VjY2Vzc0hhbmRsZXIiLCJfcG9zIiwidGFibGVNYXAiLCJNSU5fS0VZIiwiTUFYX0tFWSIsImNyZWF0ZU1pZGRsZXdhcmVTdGFjayIsInN0YWNrSW1wbCIsIm1pZGRsZXdhcmVzIiwiZG93biIsImNyZWF0ZU1pZGRsZXdhcmVTdGFja3MiLCJkYmNvcmUiLCJnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MiLCJfbm92aXAiLCJfbWlkZGxld2FyZXMiLCJ0YmwiLCJzZXRBcGlPblBsYWNlIiwib2JqcyIsInRhYmxlTmFtZXMiLCJwcm9wRGVzYyIsImVudW1lcmFibGUiLCJyZW1vdmVUYWJsZXNBcGkiLCJsb3dlclZlcnNpb25GaXJzdCIsIl9jZmciLCJ2ZXJzaW9uIiwicnVuVXBncmFkZXJzIiwib2xkVmVyc2lvbiIsImlkYlVwZ3JhZGVUcmFucyIsImdsb2JhbFNjaGVtYSIsIl9zdG9yZU5hbWVzIiwicmVqZWN0VHJhbnNhY3Rpb24iLCJjcmVhdGVUYWJsZSIsInBvcHVsYXRlIiwidXBkYXRlVGFibGVzQW5kSW5kZXhlcyIsInF1ZXVlIiwidmVyc2lvbnMiLCJfdmVyc2lvbnMiLCJidWlsZEdsb2JhbFNjaGVtYSIsImFueUNvbnRlbnRVcGdyYWRlckhhc1J1biIsInZlcnNUb1J1biIsIm9sZFNjaGVtYSIsIm5ld1NjaGVtYSIsImFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzIiwiZGlmZiIsImdldFNjaGVtYURpZmYiLCJ0dXBsZSIsImNoYW5nZSIsInJlY3JlYXRlIiwiVXBncmFkZSIsImFkZEluZGV4IiwiZGVsZXRlSW5kZXgiLCJkZWwiLCJpZHhOYW1lIiwiY29udGVudFVwZ3JhZGUiLCJ1cGdyYWRlU2NoZW1hIiwiY29udGVudFVwZ3JhZGVJc0FzeW5jIiwicmV0dXJuVmFsdWUiLCJwcm9taXNlRm9sbG93ZWQiLCJkZWNyZW1lbnRvciIsImRlbGV0ZVJlbW92ZWRUYWJsZXMiLCJydW5RdWV1ZSIsImNyZWF0ZU1pc3NpbmdUYWJsZXMiLCJvbGREZWYiLCJuZXdEZWYiLCJkZWYiLCJvbGRJbmRleGVzIiwibmV3SW5kZXhlcyIsIm9sZElkeCIsIm5ld0lkeCIsImNyZWF0ZU9iamVjdFN0b3JlIiwiY29udGFpbnMiLCJzdG9yZU5hbWUiLCJkZWxldGVPYmplY3RTdG9yZSIsImNyZWF0ZUluZGV4IiwiZGJTdG9yZU5hbWVzIiwiaiIsImlkYmluZGV4IiwicmVhZEdsb2JhbFNjaGVtYSIsInZlcm5vIiwidmVyaWZ5SW5zdGFsbGVkU2NoZW1hIiwiaW5zdGFsbGVkU2NoZW1hIiwiY2giLCJfaGFzR2V0QWxsIiwiZGV4aWVOYW1lIiwiaW5kZXhTcGVjIiwiV29ya2VyR2xvYmFsU2NvcGUiLCJwYXJzZUluZGV4U3ludGF4IiwicHJpbUtleUFuZEluZGV4ZXMiLCJpbmRleE51bSIsInRyaW0iLCJyZXBsYWNlIiwiVmVyc2lvbiIsIl9wYXJzZVN0b3Jlc1NwZWMiLCJzdG9yZXMiLCJvdXRTY2hlbWEiLCJzdG9yZXNTb3VyY2UiLCJzdG9yZXNTcGVjIiwidXBncmFkZSIsInVwZ3JhZGVGdW5jdGlvbiIsImNyZWF0ZVZlcnNpb25Db25zdHJ1Y3RvciIsInZlcnNpb25OdW1iZXIiLCJnZXREYk5hbWVzVGFibGUiLCJkYk5hbWVzREIiLCJEZXhpZSQxIiwiYWRkb25zIiwiZGJuYW1lcyIsImhhc0RhdGFiYXNlc05hdGl2ZSIsImRhdGFiYXNlcyIsImdldERhdGFiYXNlTmFtZXMiLCJpbmZvcyIsImluZm8iLCJfb25EYXRhYmFzZUNyZWF0ZWQiLCJfb25EYXRhYmFzZURlbGV0ZWQiLCJ2aXAiLCJpZGJSZWFkeSIsImlzU2FmYXJpIiwidXNlckFnZW50RGF0YSIsImludGVydmFsSWQiLCJ0cnlJZGIiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJkZXhpZU9wZW4iLCJzdGF0ZSIsIm9wZW5DYW5jZWxsZXIiLCJ0aHJvd0lmQ2FuY2VsbGVkIiwicmVzb2x2ZURiUmVhZHkiLCJkYlJlYWR5UmVzb2x2ZSIsInVwZ3JhZGVUcmFuc2FjdGlvbiIsIndhc0NyZWF0ZWQiLCJ0cnlPcGVuREIiLCJkYk5hbWUiLCJhdXRvU2NoZW1hIiwicm91bmQiLCJvbmJsb2NrZWQiLCJfZmlyZU9uQmxvY2tlZCIsIm9udXBncmFkZW5lZWRlZCIsImFsbG93RW1wdHlEQiIsImNsb3NlIiwiZGVscmVxIiwiZGVsZXRlRGF0YWJhc2UiLCJOb1N1Y2hEYXRhYmFzZSIsIm9sZFZlciIsInBvdyIsIm9udmVyc2lvbmNoYW5nZSIsInZjRmlyZWQiLCJvbmNsb3NlIiwib25SZWFkeUJlaW5nRmlyZWQiLCJyZWFkeSIsImZpcmVSZW1haW5kZXJzIiwicmVtYWluZGVycyIsImF3YWl0SXRlcmF0b3IiLCJjYWxsTmV4dCIsImRvVGhyb3ciLCJ0aHJvdyIsIm9uU3VjY2VzcyIsInN0ZXAiLCJvbkVycm9yIiwiZ2V0TmV4dCIsImV4dHJhY3RUcmFuc2FjdGlvbkFyZ3MiLCJfdGFibGVBcmdzXyIsInNjb3BlRnVuYyIsImVudGVyVHJhbnNhY3Rpb25TY29wZSIsInBhcmVudFRyYW5zYWN0aW9uIiwic2NvcGVGdW5jSXNBc3luYyIsIlByZW1hdHVyZUNvbW1pdCIsInBhZCIsImNyZWF0ZVZpcnR1YWxJbmRleE1pZGRsZXdhcmUiLCJpbmRleExvb2t1cCIsImFsbFZpcnR1YWxJbmRleGVzIiwiYWRkVmlydHVhbEluZGV4ZXMiLCJrZXlUYWlsIiwibG93TGV2ZWxJbmRleCIsImtleVBhdGhBbGlhcyIsImluZGV4TGlzdCIsImtleUxlbmd0aCIsImlzVmlydHVhbCIsInZpcnR1YWxJbmRleCIsInZpcnR1YWxLZXlQYXRoIiwiZmluZEJlc3RJbmRleCIsInRyYW5zbGF0ZVJhbmdlIiwidHJhbnNsYXRlUmVxdWVzdCIsImNyZWF0ZVZpcnR1YWxDdXJzb3IiLCJfY29udGludWUiLCJ2aXJ0dWFsQ3Vyc29yIiwidmlydHVhbEluZGV4TWlkZGxld2FyZSIsImxldmVsIiwiZ2V0T2JqZWN0RGlmZiIsInByZngiLCJhcCIsImJwIiwiYXBUeXBlTmFtZSIsImJwVHlwZU5hbWUiLCJnZXRFZmZlY3RpdmVLZXlzIiwiaG9va3NNaWRkbGV3YXJlIiwiZG93bkNvcmUiLCJkb3duVGFibGUiLCJ0YWJsZU1pZGRsZXdhcmUiLCJkeFRyYW5zIiwiZGVsZXRpbmciLCJjcmVhdGluZyIsInVwZGF0aW5nIiwiYWRkUHV0T3JEZWxldGUiLCJkZWxldGVSYW5nZSIsImdldEV4aXN0aW5nVmFsdWVzIiwiZXhpc3RpbmdWYWx1ZXMiLCJjb250ZXh0cyIsImV4aXN0aW5nVmFsdWUiLCJnZW5lcmF0ZWRQcmltYXJ5S2V5Iiwib2JqZWN0RGlmZiIsImFkZGl0aW9uYWxDaGFuZ2VzIiwicmVxdWVzdGVkVmFsdWUiLCJkZWxldGVOZXh0Q2h1bmsiLCJlZmZlY3RpdmVLZXlzIiwiZ2V0RnJvbVRyYW5zYWN0aW9uQ2FjaGUiLCJjYWNoZUV4aXN0aW5nVmFsdWVzTWlkZGxld2FyZSIsImNhY2hlZFJlc3VsdCIsImlzRW1wdHlSYW5nZSIsIm5vZGUiLCJSYW5nZVNldCIsImZyb21PclRyZWUiLCJ0byIsImQiLCJyYW5nZVNldCIsIm1lcmdlUmFuZ2VzIiwiYWRkS2V5IiwiYWRkS2V5cyIsImdldFJhbmdlU2V0SXRlcmF0b3IiLCJsZWZ0IiwicmlnaHQiLCJyIiwicmViYWxhbmNlIiwicmlnaHRXYXNDdXRPZmYiLCJuZXdTZXQiLCJfYWRkUmFuZ2VTZXQiLCJyYW5nZXNPdmVybGFwIiwicmFuZ2VTZXQxIiwicmFuZ2VTZXQyIiwiaTEiLCJuZXh0UmVzdWx0MSIsImkyIiwibmV4dFJlc3VsdDIiLCJrZXlQcm92aWRlZCIsInVwIiwiX2IiLCJyb290Q2xvbmUiLCJvbGRSb290UmlnaHQiLCJjb21wdXRlRGVwdGgiLCJvYnNlcnZhYmlsaXR5TWlkZGxld2FyZSIsIkZVTExfUkFOR0UiLCJ0YWJsZUNsb25lIiwibXV0YXRlZFBhcnRzIiwiZ2V0UmFuZ2VTZXQiLCJwYXJ0IiwicGtSYW5nZVNldCIsImRlbHNSYW5nZVNldCIsIm5ld09ianMiLCJvbGRDYWNoZSIsIm9sZE9ianMiLCJ0cmFja0FmZmVjdGVkSW5kZXhlcyIsImdldFJhbmdlIiwicmVhZFN1YnNjcmliZXJzIiwibWV0aG9kIiwic3Vic2NyIiwicXVlcmllZEluZGV4IiwicXVlcmllZFJhbmdlcyIsImtleXNQcm9taXNlIiwicmVzdWx0aW5nS2V5cyIsInBLZXlzIiwid2FudFZhbHVlcyIsInBrZXkiLCJhZGRBZmZlY3RlZEluZGV4IiwiYWRkS2V5T3JLZXlzIiwib2xkS2V5IiwibmV3S2V5IiwiZGVwcyIsImRlcGVuZGVuY2llcyIsImNhbmNlbE9wZW4iLCJiU3RpY2t5IiwibmV3VmVyc2lvbiIsInVzZSIsImFkZG9uIiwidmVyc2lvbkluc3RhbmNlIiwiX3doZW5SZWFkeSIsInVudXNlIiwibXciLCJoYXNBcmd1bWVudHMiLCJkb0RlbGV0ZSIsImJhY2tlbmREQiIsImhhc0JlZW5DbG9zZWQiLCJoYXNGYWlsZWQiLCJkeW5hbWljYWxseU9wZW5lZCIsIl90cmFuc2FjdGlvbiIsIm9ubHlJZkNvbXBhdGlibGUiLCJpZGJNb2RlIiwiU3ViVHJhbnNhY3Rpb24iLCJlbnRlclRyYW5zYWN0aW9uIiwiSW52YWxpZFRhYmxlIiwic3ltYm9sT2JzZXJ2YWJsZSIsIm9ic2VydmFibGUiLCJPYnNlcnZhYmxlIiwiX3N1YnNjcmliZSIsImV4dGVuZE9ic2VydmFiaWxpdHlTZXQiLCJsaXZlUXVlcnkiLCJxdWVyaWVyIiwiaGFzVmFsdWUiLCJjdXJyZW50VmFsdWUiLCJvYnNlcnZlciIsImV4ZWN1dGUiLCJleGVjIiwiY2xvc2VkIiwiYWNjdW1NdXRzIiwiY3VycmVudE9icyIsInN1YnNjcmlwdGlvbiIsIm11dGF0aW9uTGlzdGVuZXIiLCJxdWVyeWluZyIsInN0YXJ0ZWRMaXN0ZW5pbmciLCJzaG91bGROb3RpZnkiLCJkb1F1ZXJ5IiwiZ2V0VmFsdWUiLCJkb21EZXBzIiwibW96SW5kZXhlZERCIiwid2Via2l0SW5kZXhlZERCIiwibXNJbmRleGVkREIiLCJ3ZWJraXRJREJLZXlSYW5nZSIsIkRleGllIiwiZGF0YWJhc2VOYW1lIiwiZXhpc3RzIiwiaWdub3JlVHJhbnNhY3Rpb24iLCJhc3luYyIsImdlbmVyYXRvckZuIiwic3Bhd24iLCJjdXJyZW50VHJhbnNhY3Rpb24iLCJwcm9taXNlT3JGdW5jdGlvbiIsIm9wdGlvbmFsVGltZW91dCIsInNlbVZlciIsIm1heEtleSIsImFkZEV2ZW50TGlzdGVuZXIiLCJ1cGRhdGVkUGFydHMiLCJwcm9wYWdhdGluZ0xvY2FsbHkiLCJpbml0Q3VzdG9tRXZlbnQiLCJwcm9wYWdhdGVMb2NhbGx5IiwidXBkYXRlUGFydHMiLCJ3YXNNZSIsIkJyb2FkY2FzdENoYW5uZWwiLCJiYyIsInVucmVmIiwiY2hhbmdlZFBhcnRzIiwicG9zdE1lc3NhZ2UiLCJvbm1lc3NhZ2UiLCJkYXRhIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsInRyaWciLCJyYW5kb20iLCJtYXRjaEFsbCIsImluY2x1ZGVVbmNvbnRyb2xsZWQiLCJjbGllbnQiLCJwYXJzZSIsIm5ld1ZhbHVlIiwic3dDb250YWluZXIiLCJzZXJ2aWNlV29ya2VyIiwicHJvcGFnYXRlTWVzc2FnZUxvY2FsbHkiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/dexie/dist/modern/dexie.mjs\n");

/***/ })

};
;